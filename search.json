[{"title":"typescript-1","path":"/2024/01/12/typescript-1/","content":"TypeScript 是什么？ TypeScript 是 JavaScript 的超集，在 JavaScript 的基础之上，为 JavaScript 添加了类型支持。 为什么要有 TypeScript？JavaScript 是一门弱类型语言，其代码中的错误绝大多数是类型错误（Uncaught TypeError）。这些经常出现的错误，严重影响了开发效率。 从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JavaScript 属于动态类型的编程语言。 静态类型：编译期做类型检查 动态类型：执行期做类型检查 因此： 对于 JavaScript 来说，需要等到代码执行的时候才能发现错误（晚）； 对于 TypeScript 来说，在代码编译的时候就能发现错误（早），配合开发工具，可以提前到在编写代码的时候就能发现代码中的错误（更早）。 另外，对于 TypeScript 编辑器的代码提示更丰富，开发体验更好。 类型注解1let age: number = 18 形如 : number 这部分代码叫类型注解，作用是为变量添加类型约束。浏览器据此可以进行报错和代码提示。 JavaScript 已有类型： 原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined 复杂类型：数组、对象、方法 TypeScript 新增类型：联合、自定义、接口、元组、字面量、枚举、void 等 12345678910let name: string = &#x27;&#x27;let age: number = &#x27;&#x27;let bool: boolean = falselet gender: undefined = undefinedlet hobby: null = null// 声明数组的方式 1let arr1: number[] = [1, 2, 3]// 声明数组的方式 2，范型let arr2: Array&lt;number&gt; = [1, 2, 3] 联合类型123// 联合类型let arr: (number | string)[] = [1, 2, 3, &#x27;abc&#x27;]// 会丢失一部分代码提示，只能提示共有的方法和属性 类型别名12345678type ArrType = (number | string)[]let arr1: ArrType = [1, 2, 3, &#x27;abc&#x27;]let arr2: ArrType = [1, 2, 3, &#x27;abc&#x27;]let arr3: ArrType = [1, 2, 3, &#x27;abc&#x27;]type ItemType = number | stringlet arr4: ItemType[] = [1, 2, 3, &#x27;abc&#x27;] 函数类型123456function add1(a: number, b: number): number &#123; return a + b&#125;const add2 = (a: number, b: number): number =&gt; &#123; return a + b&#125; 函数的类型别名函数的类型别名通常是给箭头函数 &#x2F; 函数表达式使用，不会给函数声明使用 123456789type FnType = (a: number, b: number) =&gt; numberconst add: FnType = function (a, b) &#123; return a + b&#125;const sub: FnType = (a, b) =&gt; &#123; return a - b&#125; void 类型如果函数不写 return，默认返回值是 undefined，但是 TypeScript 类型推断为 void。在 TypeScript 中写 : undefined 的意思是必须返回一个 undefined。TypeScript 提供了一个返回值类型 : void 意思就是没有返回值。 123const show = (content: string): void =&gt; &#123; console.log(content)&#125; 可选参数 在 JavaScript 中定义了形参，调用函数时可以不传实参 在 TypeScript 中定义了形参，调用函数时必须传入实参，否则报错 如果要实现可选参数，加一个 ?，可选参数只能放在参数列表的最后。 123const print = (name?: string, gender?: string) =&gt; &#123; console.log(name, gender)&#125; 对象类型","tags":["TypeScript"]},{"title":"pinia-2","path":"/2024/01/09/pinia-2/","content":"接下来，将 src&#x2F;main.js 中对于 pinia 的引用改成对自己实现的引用。 123// src/main.js// import &#123; createPinia &#125; from &#x27;pinia&#x27;import &#123; createPinia &#125; from &#x27;@/pinia&#x27; 新建 src&#x2F;pinia&#x2F;index.js 作为库的入口文件。前面的 TodoList 中用到了两个方法：createPinia 和 defineStore。 12345// src/pinia/index.jsimport createPinia from &#x27;./createPinia&#x27;import defineStore from &#x27;./defineStore&#x27;export &#123; createPinia, defineStore &#125; 观察 app.use(createPinia()) 可知，createPinia 是一个方法，返回一个包含 install 方法的对象，可以作为 app.use 方法的参数。 1234567// src/pinia/createPinia.jsexport default () =&gt; &#123; function install(app) &#123;&#125; return &#123; install, &#125;&#125; 创建一个总的 Store，来存储所有通过 defineStore 方法创建的 store。 123456789101112// src/pinia/createPinia.jsimport &#123; reactive &#125; from &#x27;vue&#x27;export default () =&gt; &#123; const piniaStore = reactive(&#123;&#125;) function install(app) &#123;&#125; return &#123; install, &#125;&#125; 要把 piniaStore 暴露出来供 defineStore 调用，可以使用 vue 提供的 provide 方法。 1234567891011121314// src/pinia/createPinia.jsimport &#123; reactive &#125; from &#x27;vue&#x27;export default () =&gt; &#123; const piniaStore = reactive(&#123;&#125;) function install(app) &#123; app.provide(&#x27;piniaStore&#x27;, piniaStore) &#125; return &#123; install, &#125;&#125; 但是把整个 Store 暴露出来并不十分合理，可以改成把存入 store 的方法 setSubStore 暴露出来。 123456789101112131415161718192021// src/pinia/createPinia.jsimport &#123; reactive &#125; from &#x27;vue&#x27;export default () =&gt; &#123; const piniaStore = reactive(&#123;&#125;) function setSubStore(name, store) &#123; if (!piniaStore[name]) &#123; piniaStore[name] = store &#125; return piniaStore &#125; function install(app) &#123; app.provide(&#x27;setSubStore&#x27;, setSubStore) &#125; return &#123; install, &#125;&#125; 一些公共的 api 比如 $patch 可以在这里传入。新建一个文件 src&#x2F;pinia&#x2F;apis.js。 12345678// src/pinia/apis.jsexport function patch(&#123; value &#125;) &#123; const store = this for (let key in value) &#123; store[key] = value[key] &#125;&#125; 给 store 添加上公共的 api。 1234567891011121314151617181920212223// src/pinia/createPinia.jsimport &#123; reactive &#125; from &#x27;vue&#x27;import &#123; patch &#125; from &#x27;./apis&#x27;export default () =&gt; &#123; const piniaStore = reactive(&#123;&#125;) function setSubStore(name, store) &#123; if (!piniaStore[name]) &#123; piniaStore[name] = store piniaStore[name].$patch = patch &#125; return piniaStore &#125; function install(app) &#123; app.provide(&#x27;setSubStore&#x27;, setSubStore) &#125; return &#123; install, &#125;&#125; 观察 src&#x2F;store&#x2F;todoList.js 中对 defineStore 方法的调用可知，该方法第一个参数是 store 的名称，第二个参数是 options 对象。 1234567891011// src/pinia/defineStore.jsexport default ( name, &#123; state, // function getters, actions, &#125;) =&gt; &#123; const store = &#123;&#125;&#125; 先来实现 state，并将 store 打印出来。 123456789101112131415161718192021222324// src/pinia/defineStore.jsimport &#123; reactive, toRef &#125; from &#x27;vue&#x27;export default ( name, &#123; state, // function getters, actions, &#125;) =&gt; &#123; const store = &#123;&#125; if (state &amp;&amp; typeof state === &#x27;function&#x27;) &#123; const _state = state() store.$state = reactive(_state) for (let key in _state) &#123; store[key] = toRef(store.$state, key) &#125; &#125; console.log(store)&#125; 然后来实现 actions。 12345678// src/pinia/defineStore.js// ...if (actions &amp;&amp; Object.keys(actions).length &gt; 0) &#123; for (let method in actions) &#123; store[method] = actions[method] &#125;&#125;// ... 再来实现 getters。getters 里面的方法都： 接收一个 state 参数； 其中的 this 指向 state； 可以通过形如 this.anotherGetter() 这样的语句调用其他 getter。 123456789// src/pinia/defineStore.js// ...if (getters &amp;&amp; Object.keys(getters).length &gt; 0) &#123; for (let getter in getters) &#123; store[getter] = getters[getter].bind(store.$state, store.$state) store.$state[getter] = store[getter] &#125;&#125;// ... 优化一下代码，将 state、actions、getters 的处理拆分到单个文件中。 1234567891011// src/pinia/options/state.jsimport &#123; reactive, toRef &#125; from &#x27;vue&#x27;export function createStates(store, state) &#123; const _state = state() store.$state = reactive(_state) for (let key in _state) &#123; store[key] = toRef(store.$state, key) &#125;&#125; 123456// src/pinia/options/action.jsexport function createActions(store, actions) &#123; for (let method in actions) &#123; store[method] = actions[method] &#125;&#125; 123456789// src/pinia/options/getter.jsimport &#123; computed &#125; from &#x27;vue&#x27;export function createGetters(store, getters) &#123; for (let getter in getters) &#123; store[getter] = computed(getters[getter].bind(store.$state, store.$state)) store.$state[getter] = store[getter] &#125;&#125; 123456// src/pinia/options/index.jsimport &#123; createStates &#125; from &#x27;./state&#x27;import &#123; createActions &#125; from &#x27;./action&#x27;import &#123; createGetters &#125; from &#x27;./getter&#x27;export &#123; createStates, createActions, createGetters &#125; 1234567891011121314151617181920212223242526// src/pinia/defineStore.jsimport &#123; inject, reactive &#125; from &#x27;vue&#x27;import &#123; createStates, createActions, createGetters &#125; from &#x27;./options&#x27;export default ( name, &#123; state, // function getters, actions, &#125;) =&gt; &#123; const store = &#123;&#125; state &amp;&amp; typeof state === &#x27;function&#x27; &amp;&amp; createStates(store, state) actions &amp;&amp; Object.keys(actions).length &gt; 0 &amp;&amp; createActions(store, actions) getters &amp;&amp; Object.keys(getters).length &gt; 0 &amp;&amp; createGetters(store, getters) return () =&gt; &#123; const setSubStore = inject(&#x27;setSubStore&#x27;) const piniaStore = setSubStore(name, reactive(store)) return piniaStore[name] &#125;&#125; TodoList 的功能完美实现，将 store 打印出来看，有一点小瑕疵，但总体上前面分析的都实现了。 本小节完。","tags":["vue3","pinia"]},{"title":"pinia-1","path":"/2024/01/06/pinia-1/","content":"本系列文章是本人研究 Pinia 的相关记录。 Pinia 是近年比较热门的 Vue 相关状态管理库，我对其的学习步骤如下： 使用 pinia.js 实现一个简单的 TodoList 功能； 观察 pinia.js 的 api 和数据结构，自己实现一个伪 pinia，并将 TodoList 的依赖转为伪 pinia； 对比 pinia.js 源码和自己的实现。 （一）使用 pinia.js 实现一个简单的 TodoList 功能首先在 main.js 中引入： 1234// src/main.jsimport &#123; createPinia &#125; from &#x27;pinia&#x27;createApp(App).use(createPinia()).mount(&#x27;#app&#x27;) 在 src&#x2F;store 目录下新建 todoList.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// src/store/todoList.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export default defineStore(&#x27;todoList&#x27;, &#123; state: () =&gt; (&#123; todos: [], // id: number, text: string, isFinished: boolean filter: &#x27;all&#x27;, // &#x27;all&#x27; &#x27;finished&#x27; &#x27;unfinished&#x27; nextId: 0 &#125;), actions: &#123; addTodo(text) &#123; this.todos.push(&#123; id: this.nextId++, text, isFinished: false &#125;) &#125;, toggleTodo(id) &#123; this.todos = this.todos.map(todo =&gt; &#123; if (todo.id === id) &#123; todo.isFinished = !todo.isFinished &#125; return todo &#125;) &#125;, removeTodo(id) &#123; this.todos = this.todos.filter(todo =&gt; todo.id !== id) &#125; &#125;, getters: &#123; finishedTodos(state) &#123; return state.todos.filter(todo =&gt; todo.isFinished) &#125;, unFinishedTodos(state) &#123; return state.todos.filter(todo =&gt; !todo.isFinished) &#125;, filteredTodos(state) &#123; switch (this.filter) &#123; case &#x27;finished&#x27;: return this.finishedTodos case &#x27;unfinished&#x27;: return this.unFinishedTodos default: return this.todos &#125; &#125; &#125;&#125;) 在 src&#x2F;store 目录下新建 index.js 12345import useTodoListStore from &#x27;./todoList&#x27;export &#123; useTodoListStore&#125; 如此，就能在 src&#x2F;App.vue 中引入： 123456// src/App.vueimport &#123; useTodoListStore &#125; from &#x27;./store&#x27;;const todoListStore = useTodoListStore()console.log(todoListStore) 将 todoListStore 打印出来观察： 这是一个 Proxy 对象； 有 $dispose、$id、$onAction、$patch、$reset、$subscribe 等一些由 pinia 定义的属性以及一些继承的属性； 在 state 中定义的 filter、nextId、todos 都是 ObjectRefImpl 类型的对象，都成为了 todoListStore 的属性； 在 actions 中定义的 addTodo、removeTodo、toggleTodo 等方法都成为了 todoListStore 的属性； 在 getters 中定义的 filteredTodos、finishedTodos、unfinishedTodos 都是 ComputedRefImpl 类型的对象，都成为了 todoListStore 的属性。 观察完后将 src&#x2F;App.vue 的代码改成： 1234567&lt;template&gt; &lt;todo-list&gt;&lt;/todo-list&gt;&lt;/template&gt;&lt;script setup&gt; import TodoList from &#x27;@/components/TodoList/index.vue&#x27;&lt;/script&gt; 下面来具体写 TodoList 组件： 1234567891011121314&lt;!-- src/components/TodoList/index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;todo-tab&gt;&lt;/todo-tab&gt; &lt;todo-form&gt;&lt;/todo-form&gt; &lt;todos&gt;&lt;/todos&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt; import TodoTab from &#x27;./TodoTab.vue&#x27; import TodoForm from &#x27;./TodoForm.vue&#x27; import Todos from &#x27;./Todos.vue&#x27;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- src/components/TodoList/TodoTab.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;a href=&quot;javascript:;&quot; :class=&quot;&#123; active: todoListStore.filter === &#x27;all&#x27; &#125;&quot; @click=&quot;setFilter(&#x27;all&#x27;)&quot; &gt;All&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; :class=&quot;&#123; active: todoListStore.filter === &#x27;finished&#x27; &#125;&quot; @click=&quot;setFilter(&#x27;finished&#x27;)&quot; &gt;Finished&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; :class=&quot;&#123; active: todoListStore.filter === &#x27;unfinished&#x27; &#125;&quot; @click=&quot;setFilter(&#x27;unfinished&#x27;)&quot; &gt;Unfinished&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useTodoListStore &#125; from &#x27;@/store&#x27;const todoListStore = useTodoListStore()const setFilter = (filter) =&gt; &#123; todoListStore.$patch(&#123; filter &#125;)&#125;&lt;/script&gt;&lt;style scoped&gt;a &#123; margin-right: 15px;&#125;.active &#123; text-decoration: none; color: #000;&#125;&lt;/style&gt; 1234567891011121314151617181920&lt;!-- src/components/TodoList/TodoForm.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;input placeholder=&quot;Input something...&quot; type=&quot;text&quot; v-model=&quot;inputRef&quot;&gt; &lt;button @click=&quot;addTodo&quot;&gt;Add Todo&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; useTodoListStore &#125; from &#x27;@/store&#x27;const todoListStore = useTodoListStore()const inputRef = ref(&#x27;&#x27;)const addTodo = () =&gt; &#123; todoListStore.addTodo(inputRef.value) inputRef.value = &#x27;&#x27;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526&lt;!-- src/components/TodoList/Todos.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;item of todoListStore.filteredTodos&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot; :checked=&quot;item.isFinished&quot; @click=&quot;todoListStore.toggleTodo(item.id)&quot; /&gt; &lt;span :class=&quot;&#123; finished: item.isFinished &#125;&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt; &lt;button @click=&quot;todoListStore.removeTodo(item.id)&quot;&gt;Delete&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useTodoListStore &#125; from &#x27;@/store&#x27;const todoListStore = useTodoListStore()&lt;/script&gt;&lt;style scoped&gt;.finished &#123; text-decoration: line-through;&#125;&lt;/style&gt; 本小节完，下一小节开始自己实现 pinia 相关的功能。","tags":["vue3","pinia"]},{"title":"Vite 学习笔记（三）","path":"/2024/01/04/vite-03/","content":"Vite 学习笔记（三）vite 环境变量配置 环境变量：不同代码环境有不同值的变量叫做环境变量 代码环境： 开发环境 测试环境 预发布环境 灰度环境 生产环境 常见环境变量： 各种 sdk 的 key 后端的 api 地址 放在不同的文件中： .env：所有环境中值相同的环境变量 .env.development：开发环境（默认情况下 vite 将开发环境取名为 development） .env.production：生产环境（默认情况下 vite 将生产环境取名为 production） 在服务端中可以通过 loadEnv 方法读取。 在客户端中，vite 会将以 VITE_ 开头的环境变量注入到 import.meta.env。VITE_ 这个前缀可以在 vite 配置文件中的 envPrefix 的值处更改。","tags":["vite"]},{"title":"Vite 学习笔记（二）","path":"/2024/01/02/vite-02/","content":"Vite 学习笔记（二）vite 配置文件处理细节123456// vite.config.jsexport default &#123; optimizeDeps: &#123; exclude: [] &#125;&#125; 编辑 vite 配置文件时，有的编辑器默认会有语法提示，如果没有，则可以： 找相关的插件 通过引入 defineConfig 方法 12345678// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;export default defineConfig(&#123; optimizeDeps: &#123; exclude: [] &#125;&#125;) 由于 vite 是由 TypeScript 编写的，defineConfig 的参数类型是设定好的，只要编辑器支持 TypeScript，则编写配置的时候也会有语法提示。 通过 jsdoc 指定类型从而获得语法提示 1234567// vite.config.js/** @type import(&#x27;vite&#x27;).UserConfig */const viteConfig = &#123; optimizeDeps: &#123; exclude: [] &#125;&#125; 环境配置使用 webpack 的时候，有时要在不同的文件中分别写不同环境的配置： webpack.dev.config webpack.prod.config webpack.base.config 而在 vite 的配置文件里可以这样写 123456789101112131415// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import ViteBaseConfig from &#x27;./vite.base.config.js&#x27;import ViteDevConfig from &#x27;./vite.dev.config.js&#x27;import ViteProdConfig from &#x27;./vite.prod.config.js&#x27;// 策略模式const envResolver = &#123; &quot;build&quot;: () =&gt; Object.assign(&#123;&#125;, viteBaseConfig, viteProdConfig), &quot;serve&quot;: () =&gt; Object.assign(&#123;&#125;, viteBaseConfig, viteDevConfig)&#125;export default defineConfig((&#123; command &#125;) =&gt; &#123; return envResolver[command]()&#125;)","tags":["vite"]},{"title":"Vite 学习笔记（一）","path":"/2024/01/01/vite-01/","content":"Vite 学习笔记（一）什么是构建工具成熟的企业级项目里可能会具备哪些功能？ TypeScript React&#x2F;Vue less&#x2F;sass&#x2F;postcss&#x2F;component-style 语法降级：babel —&gt; 将 es 的新语法降级为旧版浏览器可以接受的语法 体积优化 …… 要做的事情很多很杂，需要一个工具将以上的步骤全部集成到一起；开发者能将更多的注意力放在业务代码上。 这个工具就是构建工具。 一个构建工具到底承担了哪些脏活累活： 模块化开发支持：支持直接从 node_modules 中引入代码 + 多种模块化（es6 module&#x2F;commonjs） 将处理代码兼容性的工具集成进来进行自动化处理 提高项目性能：压缩文件、代码分割 优化开发体验 监听文件变化，自动调用对应的工具并刷新浏览器（热更新 HMR） 开发服务器：跨域 市面上主流的构建工具： webpack vite parcel esbuild rollup grunt gulp Vite 相较于 webpack 的优势webpack 更关注兼容性，支持多种模块化（es modules&#x2F;commonjs），开始编译时必须要统一模块化代码，必须要将所有的依赖全部读一遍；vite 关注浏览器端的开发体验，限定了 es modules 的模块化。 webpack 先解析完所有依赖才启动开发服务器；vite 先启动开发服务器，再根据 entry 进行按需加载。 依赖预构建对于 commonjs 导出的模块，vite 会调用 esbuild 将其转换成 esmodule 规范，放在 &#x2F;node_modules&#x2F;.vite&#x2F;deps 目录下。 解决了 3 个问题 不同的第三方包会有不同的导出格式 对路径的处理上可以直接使用 .vite&#x2F;deps，方便路径补全 无论某个库有多少额外的 export 和 import，vite 都会尽可能的将它们集成到最后只生成一个或几个模块，减少浏览器的加载数量（lodash-es）","tags":["vite"]},{"title":"浏览器缓存小结","path":"/2019/11/10/browser-cache/","content":"关于浏览器缓存的小结。 浏览器收到服务器的响应后，会检查响应头信息，一般用于缓存相关的头信息有 4 个： ETag Cache-Control Expires Last-Modified ETag ETag（Entity Tag）是一个用于缓存校验的 token 字符串，通常以文件的哈希值来表示。 浏览器在文件的响应头中接收到 ETag，当文件过期后，浏览器再次向服务器请求该文件时会附上先前接收到的 ETag；服务器通过对比 ETag 和文件的哈希值判断资源是否变化，如果没有则返回 304，浏览器就知道缓存中的资源是安全的。 注意：仅当缓存中的文件过期了，ETag 才会被用在请求中。 Cache-Control Cache-Control 常用于设置资源的缓存行为、过期时间、验证等。 缓存行为 Cache-Control: public：资源可以被任意缓存（浏览器、CDN 等） Cache-Control: private：资源只能被浏览器缓存 Cache-Control: no-store：资源不被缓存，浏览器总是请求服务器获取最新文件 Cache-Control: no-cache：资源被浏览器缓存，但使用前总会先请求服务器检查文件（常用于 html 文件） 过期时间 Cache-Control: max-age=60：指定资源应该被缓存多少秒 Cache-Control: s-max-age=60：同上，用于中间缓存（CDN 等） Cache-Control: must-revalidate：资源被使用前必须去验证过期状态 ExpiresExpires 来自 http 1.0 时代，该字段指定了一个日期，超过这个日期就代表资源是无效的，如果已经指定了 Cache-Control 中的 max-age，则浏览器就会忽略 expires。 1Expires: Wed, 25 Jul 2018 21:00:00 GMT Last-ModifiedLast-Modified 也是来自 http 1.0 时代，该字段包含了资源最后修改的日期和时间。 1Last-Modified: Mon, 12 Dec 2016 14:45:00 GMT HTML Meta Tag在 HTML5 版本之前，在 html 中使用元标签（meta）指定 cache-control 是一个有效的方式 1&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot;&gt; 但在 HTML5 中不推荐这么做，因为只有浏览器可以识别这个标签，中间缓存（CDN）是识别不了的。 HTTP Response一个简单的 http 响应： 1234567891011Accept-Ranges: bytesCache-Control: max-age=3600Connection: Keep-AliveContent-Length: 4361Content-Type: image/pngDate: Tue, 25 Jul 2017 17:26:16 GMTETag: &quot;1109-554221c5c8540&quot;Expires: Tue, 25 Jul 2017 18:26:16 GMTKeep-Alive: timeout=5, max=93Last-Modified: Wed, 12 Jul 2017 17:26:05 GMTServer: Apache 第 2 行告诉我们 max-age 为 1 小时 第 5 行告诉我们这是一个 png 图片资源 第 7 行告诉我们 ETag 将在 1 个消失后去验证资源是否改变过 第 8 行，Expires 头会被忽略，因为已经设置了 Cache-Control: max-age&#x3D;3600 第 10 行，Last-Modified 头展示了图片资源的最后修改时间 Cache BustingCache Busting 会使一个资源文件失效，强制浏览器去服务器端重新获取数据。 我们可以通过改变文件名来命令浏览器去避开缓存，对于浏览器来说，这是一份全新的资源，所以会去请求最新的数据。 版本号我们可以给资源添加一个版本号。 1assets/js/app-v2.min.js 指纹（fingerpring）我们可以基于文件内容添加一个指纹值。 1assets/js/app-d41d8cd98f00b204e9800998ecf8427e.min.js 拼接查询参数我们可以在文件名的末尾拼接一个查询参数。 1assets/js/app.min.js?version=2 最佳实践推荐 对于静态资源来说，使用 Cache-Control 和 ETag 头部来控制缓存的行为 设置一个比较长的 max-age 值，以此来获得浏览器缓存带来的好处 针对 Cache Busting，使用指纹值（或 hash 值）和版本号的方式 不推荐 使用 html 元标签去指定缓存的行为 使用查询参数的方式实现 Cache Busting"},{"title":"《Progressive Web Apps》读书笔记十","path":"/2019/02/03/pwa-10/","content":"第十章 流式数据 10.1 理解 Web Stream如果不使用流，在网页上显示一张图片需要： 通过网络获取图片数据 处理数据并将其解压为原始像素数据 将结果数据渲染到页面中 如果使用流，可以一块块地返回下载结果并进行处理，使得屏幕上的渲染更快。还可以并行地获取及处理数据。 10.1.1 Web Stream 有什么优势 知道开始与结束：流知道到它们从哪里开始、在哪里结束，尽管流也可能是无限的。 缓冲：流可以缓冲尚未读取的值。不使用流，这些数据将会丢失。 通过管道连接：可以用管道将流组合成一个异步序列。 内置的错误处理：发生的任何错误都将沿管道进行传播。 可取消：可以取消流并将其传回管道中。 10.1.2 可读流可读流表示可以从中读取数据的数据源。可读流只允许数据流出，不允许流入。 可读流使用的数据源有两种类型：推送（push）源和读取（pull）源。 12345var stream = new ReadableStream(&#123; start(controller) &#123;&#125;, pull(controller) &#123;&#125;, cancel(controller) &#123;&#125;&#125;, queuingStrategy) start(controller) 方法，会立即调用它并用它来设置任何基础数据源，只有当这个 Promise 成功完成后才会调用 pull(controller)。 pull(controller) 方法，当流的缓冲区未满时，会调用该方法，而且会重复调用，直到缓冲区满为止。只有当前一个 pull(controller) 成功完成后，才会调用下一个 pull(controller)。 cancel(controller) 方法，当消费者表示他们不再对流感兴趣时，会调用该方法来取消任何基础数据源。 queuingStrategy 是一个对象，决定了流如何根据内部队列的状态来发出过载信号。 10.2 基础示例1234567891011121314151617181920212223242526272829303132333435self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; event.respondWith(htmlStream()) // 进入fetch事件并用HTML流进行响应&#125;)function htmlStream() &#123; const html = &#x27;html goes here...&#x27; // 将要返回的HTML字符串 const stream = new ReadableStream(&#123; // 创建一个ReadableStream start: controller =&gt; &#123; const encoder = new TextEncoder() // 需要使用TextEncoder将文本转换成字节 let pos = 0 let chunkSize = 1 function push() &#123; // 将结果推送到Web Stream中 if (pos &gt;= html.length) &#123; // 检查是否超出了HTML的长度，如果超出，则关闭controller controller.close() return &#125; controller.enqueue(encoder.encode(html.slice(pos, pos + chunkSize))) // 将下一个HTML块编码并放入队列中 pos += chunkSize setTimeout(push, 50) // 强制延迟500ms，以降低渲染速度 &#125; push() // 开始推送流 &#125; &#125;) return new Response(stream, &#123; // 返回流的结果作为新的Response对象 headers: &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125; &#125;)&#125; 以上代码为了演示浏览器的流功能，使用 Web Stream 的同时还故意减缓了页面的渲染速度，实际应用中不这样做。 浏览器从刚接收到数据就开始渲染页面，而不是等到所有数据下载完才渲染。 10.3 页面渲染加速↓ 在 Service Worker 安装期间将资源添加到缓存中 123456789101112131415161718192021const cacheName = &#x27;latestNews-v1&#x27;self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; self.skipWaiting() // Service Worker 应该尽早开始控制不受前一个 Service Worker 控制的客户端 event.waitUntil( // 在安装阶段缓存资源 caches.open(cacheName) .then(cache =&gt; cache.addAll([ &#x27;./js/main.js&#x27;, &#x27;./images/newspaper.svg&#x27;, &#x27;./css/site.css&#x27;, &#x27;./header.html&#x27;, // 在安装阶段缓存 header.html 和 footer.html &#x27;/footer.html&#x27;, &#x27;offline-page.html&#x27; ])) )&#125;)self.addEventListener(&#x27;activate&#x27;, event =&gt; &#123; self.clients.claim() // 强制激活当前的 Service Worker&#125;) ↓ 在 Web Stream 中拼装 HTML 12345678910111213141516function getQueryString(field, url = window.location.href) &#123; // 从查询字符串中获取指定字段的值 const reg = new RegExp(&#x27;[?&amp;]&#x27; + field + &#x27;=([^&amp;#]*)&#x27;, &#x27;i&#x27;) const result = reg.exec(url) return result ? result[1] : null&#125;self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; // 进入 fetch 事件 const url = new URL(event.request.url) if (url.pathname.endsWith(&#x27;/article.html&#x27;)) &#123; // 是否请求文章的路由 const articleId = getQueryString(&#x27;id&#x27;) // 获取文章的 ID const articleUrl = `data-$&#123;articleId&#125;` // 建立文章的 URL event.respondWith(streamArticle(articleUrl)) // 使用流结果进行响应 &#125;&#125;) ↓ 在 Web Stream 响应中拼装 HTML 1234567891011121314151617181920212223242526272829303132333435363738394041function streamArticle(url) &#123; try &#123; new ReadableStream(&#123;&#125;) // 检查当前浏览器是否支持 Web Stream API &#125; catch (e) &#123; return new Response(&#x27;Streams not supported&#x27;) &#125; const stream = new ReadableStream(&#123; // 创建 ReadableStream start(controller) &#123; const startFetch = caches.match(&#x27;header.html&#x27;) // 从缓存中获取 header.html const bodyData = fetch(`data/$&#123;url&#125;.html`) // 使用 Fetch API 来获取页面的主体部分 .catch(() =&gt; new Response(&#x27;Body fetch failed&#x27;)) const endFetch = caches.match(&#x27;footer.html&#x27;) // 从缓存中获取 footer.html function pushStream(stream) &#123; // 使用 pushStream 函数来将下一个数据块推送到流中 const reader = stream.getReader() function read() &#123; return reader.read().then(result =&gt; &#123; if (result.done) return controller.enqueue(result.value) return read() &#125;) &#125; return read() &#125; startFetch // 开始获取标题数据并将其推送到流中 .then(response =&gt; pushStream(response.body)) .then(() =&gt; bodyData) .then(response =&gt; pushStream(response.body)) // 开始获取正文数据并将其推送到流中 .then(() =&gt; endFetch) .then(response =&gt; pushStream(response.body)) // 开始获取页脚数据并将其推送到流中 .then(() =&gt; controller.close()) &#125; &#125;) return new Response(stream, &#123; // 创建 Response 对象并返回流的结果 headers: &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125; &#125;)&#125; 使用 Service Worker 缓存和流，将页面数据“缝合”在一起，这意味着首次渲染几乎是瞬时的，然后通过网络传输小块内容，这样做是比服务端渲染有优势的。因为内容会通过常规的 HTML 解析器，所以你得到的是流，而且与手动把内容添加到 DOM 中并没有任何行为上的差异。 10.4 Web Stream API 的未来能够利用浏览器流的好处是可以开始使用 JavaScript 来访问如下内容： Gzip&#x2F;deflate 音频&#x2F;视频解码器 图片解码器 HTML&#x2F;XML 的流解析器"},{"title":"《Progressive Web Apps》读书笔记九","path":"/2019/01/25/pwa-9/","content":"第九章 保持数据同步 BackgroundSync API 允许用户在离线工作时对需要发送到服务器的数据进行排队，一旦用户再次上线，会将排队中的数据发送给服务器。 9.1 理解后台同步9.1.1 准备开始注册后台同步 123456789101112131415161718if (&#x27;serviceWorker&#x27; in navigator &amp;&amp; &#x27;SyncManager&#x27; in window) &#123; navigator.serviceWorker.register(&#x27;./sw.js&#x27;) .then(registration =&gt; navigator.serviceWorker.ready) .then(registration =&gt; &#123; document.getElementById(&#x27;submit&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 为id为submit的按钮添加单击事件监听器 registration.sync.register(&#x27;contact-email&#x27;) .then(() =&gt; &#123; // 为该事件注册同步并使用contact-email作为标签名 var payload = &#123; name: document.getElementById(&#x27;name&#x27;).value, email: document.getElementById(&#x27;email&#x27;).value, subject: document.getElementById(&#x27;subject&#x27;).value, message: document.getElementById(&#x27;message&#x27;).value &#125; idbKeyval.set(&#x27;sendMessage&#x27;, payload) // 从页面中取得payload数据并将其保存到IndexedDB中 &#125;) &#125;) &#125;)&#125; 注：idb-keyval 库是一个 IndexedDB 库。 9.1.2 Service Worker响应同步事件 123456789101112131415161718importScripts(&#x27;./js/idb-keyval.js&#x27;)self.addEventListener(&#x27;sync&#x27;, event =&gt; &#123; // 为同步事件添加事件监听器 if (event.tag === &#x27;contact-email&#x27;) &#123; // 检查当前同步的标签名，以确保出发的是正确的代码 event.waitUntil( idbKeyval.get(&#x27;sendMessaage&#x27;).then(value =&gt; &#123; // 从IndexedDB中获取有效载荷值 fetch(&#x27;/sendMessaage/&#x27;, &#123; // 使用fetchAPI向服务器发起POST请求 method: &#x27;POST&#x27;, headers: new Headers(&#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;), body: JSON.stringify(value) // 将从IndexedDB中获取的有效载荷值作为参数传递给服务器 &#125;).then(response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; idbKeyval.delete(&#x27;sendMessaage&#x27;) // 从IndexedDB中移除有效载荷值 &#125; &#125;) &#125;) ) &#125;&#125;) 9.1.3 提供备用方案12345if (&#x27;serviceWorker&#x27; in navigator &amp;&amp; &#x27;SyncManager&#x27; in window) &#123; // ...&#125; else &#123; // ...&#125; 9.3 定期同步123456789101112navigator.serviceWorker.ready.then(function (registration) &#123; registration.periodicSync.register(&#123; tag: &#x27;get-latest-news&#x27;, // 同步事件的标签名 minPeriod: 12 * 60 * 60 * 1000, // 两次成功的同步事件之间的最小时间间隔 powerState: &#x27;avoid-draining&#x27;, // 确定同步的电池需求。可设置为&#x27;auto&#x27;或&#x27;avoid-draining&#x27; networkState: &#x27;avoid-cellular&#x27; // 确定同步的网络需求。可以设置为&#x27;online&#x27;（默认）、&#x27;avoid-cellular&#x27;或&#x27;any&#x27; &#125;).then(function (periodicSyncReg) &#123; // 成功 &#125;, function () &#123; // 失败 &#125;)&#125;) powerState: auto：允许在电池消耗过程中进行同步，但如果设备启用了省电模式，则可能会受到限制。 avoid-draining：电池未充电时，推迟电池供电的设备的同步。 networkState： avoid-cellular：设备连接到蜂窝网络时推迟同步。"},{"title":"《Progressive Web Apps》读书笔记八","path":"/2019/01/17/pwa-8/","content":"第八章 构建更富弹性的应用 8.1 现代网站所面临的网络问题lie-fi 即使信号满格也无法下载任何东西。 单点故障（SPOF） 浏览器加载过程中，当解析器遇到脚本或 CSS 文件时，必须停止并执行文件，然后才能继续解析 HTML。若网页中引用的第三方网站出现加载时间过长或者宕机，那么网页应用将会收到影响。但第三方应用完全不受控制，可以用 Service Worker 来弹性处理这些问题。 8.2 Service Worker 的营救在网速慢时返回 408 响应 123456789101112131415161718function timeout(delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; resolve(new Response(&#x27;&#x27;, &#123; status: 408, statusText: &#x27;Request timed out.&#x27; &#125;)) &#125;, delay) &#125;)&#125;self.addEventListener(&#x27;fetch&#x27;, function (event) &#123; if (/googleapis/.test(event.request.url)) &#123; event.respondWith(Promise.race([timeout(3000), fetch(event.request.url)])) &#125; else &#123; event.respondWith(fetch(event.request)) &#125;&#125;) 8.3 使用 Workbox使用 Workbox 处理网络超时 123456789importScripts(&#x27;workbox-sw.prod.js&#x27;)const workboxSW = new self.WorkboxSW()workboxSW.router.registerRoute(&#x27;https://fonts.googleapis.com/(.*)&#x27;, // 选择缓存任何匹配“googleapis.com”域名的资源 workboxSW.strategies.cacheFirst(&#123; // 使用缓存优先策略来缓存资源 cacheName: &#x27;googleapis&#x27;, networkTimeoutSeconds: 4 // 如果网络请求4s还没响应，降级至缓存版本&#125;))"},{"title":"《Progressive Web Apps》读书笔记七","path":"/2019/01/10/pwa-7/","content":"第七章 离线浏览 7.1 解锁缓存在没有网络时，用户尝试访问 Web 应用，Service Worker 能拦截 HTTP 请求，返回用户要查看的页面的缓存版本。 7.2 提供离线文件↓ 将离线页面添加到 Service Worker 缓存中 12345678910const cacheName = &#x27;offline-cache&#x27;const offlineUrl = &#x27;offline-page.html&#x27;self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; event.waitUntil( caches.open(cacheName).then(function (cache) &#123; return cache.addAll([offlineUrl]) &#125;) )&#125;) ↓ 当用户没有连接时提供离线页面 123456789self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; if (event.request.method === &#x27;GET&#x27; &amp;&amp; event.request.headers.get(&#x27;accept&#x27;).includes(&#x27;text/html&#x27;)) &#123; event.respondWith(fetch(event.request.url).catch(error =&gt; &#123; return caches.match(offlineUrl) &#125;)) &#125; else &#123; event.respondWith(fetch(event.request)) &#125;&#125;) ↓ 如果资源没有存储在缓存中，则降级成默认的离线页面 123456789101112131415161718192021222324252627282930313233343536373839404142const cacheName = &#x27;latestNews-v1&#x27;const offlineUrl = &#x27;offline-page.html&#x27;self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ &#x27;./js/main.js&#x27;, &#x27;./js/article.js&#x27;, &#x27;./images/newspaper.svg&#x27;, &#x27;./css/site.css&#x27;, &#x27;./data/latest.json&#x27;, &#x27;./data/data-1.json&#x27;, &#x27;./article.html&#x27;, &#x27;./index.html&#x27;, offlineUrl ])) )&#125;)self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; event.respondWith(caches.match(event.request).then(function (response) &#123; if (response) return response var fetchRequest = event.request.clone() return fetch(fetchRequest).then(function (response) &#123; if (!response || response.status !== 200) return response var responseToCache = response.clone() caches.open(cacheName).then(function (cache) &#123; cache.put(event.request, responseToCache) &#125;) return response &#125;).catch(error =&gt; &#123; // 如果由于任何原因 fetch 事件失败，就检查用户是否跳转至其他页面并且请求的是 HTML 网页 if (event.request.method === &#x27;GET&#x27; &amp;&amp; event.request.headers.get(&#x27;accept&#x27;).includes(&#x27;text/html&#x27;)) &#123; return caches.match(offlineUrl) // 返回在 Service Worker 安装阶段存储在缓存中的离线页面 &#125; &#125;) &#125;))&#125;) 上一段代码永远会先从缓存中寻找资源，如果缓存中找不到，才会转而去发起请求。如果它无法通过网络来获取下一个网页，又会降级成缓存的离线页面。 7.3 几个需要注意的问题是否需要在 Service Worker 安装期间将整个网站缓存？ 当提供离线功能时，请考虑用户需求及用户量。用户是如何访问你的网站的？他们是否需要一次下载完整个网站，或者当它们访问某个新页面时再去获取？ 7.4 缓存是非永久性的每个站点都具有一定量的可用空间，这些空间可以与其他所有基于 Web 的存储器（LocalStorage、IndexedDB 和设备上的文件系统）共享。 7.5 离线用户体验12345678910111213var offlineNotification = document.getElementById(&#x27;offline&#x27;)function showIndicator() &#123; // 当用户离线时，此函数用来显示离线通知 offlineNotification.innerHTML = &#x27;You are currently offline.&#x27; offlineNotification.className = &#x27;showOfflineNotification&#x27;&#125;function hideIndicator() &#123; // 当用户再次上线时，此函数用来隐藏离线通知 offlineNotification.className = &#x27;hideOfflineNotification&#x27;&#125;window.addEventListener(&#x27;online&#x27;, hideIndicator)window.addEventListener(&#x27;offline&#x27;, showIndicator) 7.6 跟踪离线使用情况如果用户处于离线状态，则无法使用传统的 Web 分析方法来跟踪它们。在没有网络连接的情况下，分析请求将无法发出，用户的操作行为将会丢失。 Google 的开源工具库 Workbox 提供了一个叫 googleAnalytics 的离线分析工具。当用户离线时，这个库会将所有分析请求放入队列中等候，一旦用户重新连接网络，会将队列中的请求发送到分析服务器。"},{"title":"《Progressive Web Apps》读书笔记六","path":"/2019/01/02/pwa-6/","content":"第六章 消息推送 6.1 与用户互动推送通知最大的优点是即使用户没有浏览你的网站也会收到这些通知内容。 要给用户发送推送通知，首先需要用户的授权。 6.2 Weather Channel天气预报网站 Weather Channel 的数据，略。 6.3 浏览器支持Web 推送标准：http://www.w3.org/TR/push-api。 6.4 第一个推送通知发送推送通知需要三个步骤： 提示用户并获得他们的订阅细节 将这些细节信息保存在服务器上 在需要时发送任何消息 6.4.1 订阅通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var endpointvar keyvar authSecretvar vapidPublicKey = &#x27;...&#x27; // 客户端和服务器端都需要公钥，以确保消息是加密过的function urlBase64ToUnit8Array(base64String) &#123; // 将VAPID密钥从base64字符串转换成Unit8数组，这是VAPID规范要求的 const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4) const base64 = (base64String + padding).replace(/\\-/g, &#x27;+&#x27;).replace(/_/g, &#x27;/&#x27;) const rawData = window.atob(base64) const outputArray = new Unit8Array(rawData.length) for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i) &#125; return outputArray&#125;if (&#x27;serviceWorker&#x27; in navigator) &#123; navigator.serviceWorker.register(&#x27;sw.js&#x27;) .then(function (registration) &#123; return registration.pushManager.getSubscription() // 获取任何已存在的订阅 .then(function (subscription) &#123; if (subscription) return // 如果已经订阅过了，则无需再次注册 return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: urlBase64ToUnit8Array(vapidPublicKey) &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27; // 从订阅对象中获取密钥和authSecret key = rawKey ? btoa(String.fromCharCode.apply(null, new Unit8Array(rawKey))) : &#x27;&#x27; var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Unit8Array(rawAuthSecret))) : &#x27;&#x27; endpoint = subscription.endpoint return fetch(&#x27;./register&#x27;, &#123; // 将详细信息发送给服务器以注册用户 method: &#x27;post&#x27;, headers: new Headers(&#123; &#x27;content-type&#x27;: &#x27;application/json&#x27; &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret &#125;) &#125;) &#125;) &#125;) &#125;).catch(function (err) &#123; console.log(&#x27;serviceWorker registration failed: &#x27;, err) &#125;)&#125; VAPID（Voluntary Application Server Identification，自主应用服务器标识）协议，本质上定义了应用服务器和推送服务之间的握手，并允许推送服务器确认哪个站点正在发送消息。 成功注册了 Service Worker 之后，可以使用 registration 对象中的 pushManager 来检测用户是否已经订阅过了。如果用户在这台机器上已经订阅过了，便不需要再发送信息给服务器。每个订阅对象包含一个唯一的订阅 ID。 如果用户还没订阅，就用 pushManager.subscribe() 函数来提示用户订阅，该函数使用 VAPID 公钥识别自己。 最后，使用 Fetch API 来发送 POST 请求到服务器上的端点，密钥和 authSecret 将用于存储用户的详细信息。 6.4.2 发送通知12345678910111213141516171819202122232425262728293031323334353637383940const webpush = require(&#x27;web-push&#x27;) // 添加必要的依赖const express = require(&#x27;express&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const app = express()webpush.setVapidDetails( // 设置VAPID详情 &#x27;mailto:contact@deanhume.com&#x27;, &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;, &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;)app.post(&#x27;/register&#x27;, function (req, res) &#123; // 监听指向 /register 的POST请求 var endpoint = req.body.endpoint saveRegistrationDetails(endpoint, key, authSecret) // 保存用户注册详情，这样可以在稍后阶段向他们发送消息 const pushSubscription = &#123; // 构建pushSubscription对象 endpoint: req.body.endpoint, keys: &#123; auth: req.body.authSecret, p256dh: req.body.key &#125; &#125; var body = &#x27;Thank you for registering&#x27; var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27; webpush.sendNotification(pushSubscription, // 发送Web推送消息 JSON.stringify(&#123; msg: body, url: &#x27;http://localhost: 3111&#x27;, icon: iconUrl &#125;) ) .then(result =&gt; res.sendStatus(201)) .catch(err =&gt; console.log(err))&#125;)app.listen(3111, function () &#123; console.log(&#x27;Web push app listening on port 3111!&#x27;)&#125;) 6.4.3 接收通知并与之互动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 在 Service Worker 中接收推送通知self.addEventListener(&#x27;push&#x27;, function (event) &#123; var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27; // 检查服务器端是否发送了任何有效载荷数据 var title = &#x27;Progressive Times&#x27; event.waitUntil( self.registration.showNotification(title, &#123; // 使用提供的信息来显示Web推送通知 body: payload.msg, url: payload.url, icon: payload.icon &#125;) )&#125;)// 注：payload定义是数据类型，为什么当对象来用？// 处理用户与推送通知的交互self.addEventListener(&#x27;click&#x27;, function (event) &#123; event.notification.close() // 一旦单击了通知标题，它便会关闭 event.waitUntil( // 检查当前窗口是否已经打开，如果已打开则切换至当前窗口 clients.matchAll(&#123; type: &#x27;window&#x27; &#125;) .then(function (clientList) &#123; for (var i = 0; i &lt; clientList.length; i++) &#123; var client = clientList[i] if (client.url === &#x27;/&#x27; &amp;&amp; &#x27;focus&#x27; in client) return client.focus() &#125; if (clients.openWindow) return clients.openWindow(&#x27;http://localhost:3111&#x27;) &#125;) )&#125;)// 添加通知动作以及自定义振动模式self.addEventListener(&#x27;push&#x27;, function (event) &#123; var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27; var title = &#x27;Progressive Times&#x27; event.waitUntil( self.registration.showNotification(title, &#123; body: payload.msg, url: payload.url, icon: payload.icon, actions: [ &#123; action: &#x27;voteup&#x27;, title: &#x27;Vote Up&#x27; &#125;, // 出现在通知中的操作 &#123; action: &#x27;votedown&#x27;, title: &#x27;Vote Down&#x27; &#125; ], vibrate: [300, 100, 400] // 振动300ms，暂停100ms，再振动400ms &#125;) )&#125;)// 在 Service Worker 中处理通知动作self.addEventListener(&#x27;click&#x27;, function (event) &#123; event.notification.close() // 一旦单击了通知标题，它便会关闭 if (event.action === &#x27;voteup&#x27;) &#123; // 确定用户选择了哪个操作 clients.openWindow(&#x27;http://localhost:/voteup&#x27;) &#125; else &#123; // 根据用户的选择，将他们引导至正确的URL clients.openWindow(&#x27;http://localhost:/votedown&#x27;) &#125;&#125;, false) 6.4.4 取消订阅12345678910111213141516navigator.serviceWorker.ready .then(serviceWorkerRegistration =&gt; &#123; serviceWorkerRegistration.pushManager.getSubscription() // 检查用户是否已经订阅 .then(subscription =&gt; &#123; if (!subscription) return subscription.unsubscribe() // 如果用户已订阅就取消订阅 .then(function () &#123; console.log(&#x27;Successfully unsubscribed!&#x27;) &#125;) .catch(e =&gt; &#123; logger.error(&#x27;Error thrown while unsubscribing from push messaging&#x27;, e) &#125;) &#125;) &#125;)document.getElementById(&#x27;unsubscribe&#x27;).addEventListener(&#x27;click&#x27;, unsubscribe) // 为取消订阅按钮添加单击事件的事件监听器 6.5 第三方推送通知如果不想自己搭建推送通知服务器，而是使用 SaaS 产品，有一些现成的第三方解决方案。如 OneSignal、Roost 和 Aimtell 等。"},{"title":"《Progressive Web Apps》读书笔记五","path":"/2018/12/23/pwa-5/","content":"第五章 观感 5.1 Web 应用清单Web 清单文件是简单的 JSON 文件，描述了应用相关的有用信息（名称、作者、图标和描述等），可使用户将 Web 应用安装到设备的主屏幕上，允许开发者自定义启动页面、模板颜色、URL。 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;Progressive Times Web App&quot;, &quot;short_name&quot;: &quot;Progressive Times&quot;, &quot;start_url&quot;: &quot;/index.html&quot;, &quot;display&quot;: &quot;standalone&quot;, &quot;theme_color&quot;: &quot;#FFDF00&quot;, &quot;background_color&quot;: &quot;FFDF00&quot;, &quot;icons&quot;: [ &#123; &quot;src&quot;: &quot;homescreen.png&quot;, &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;homescreen-144.png&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; &#125; ]&#125; name：用作当提示用户安装应用时出现的文本。 short_name：用作当应用安装后出现在用户主屏幕上的文本。 start_url：决定了当用户从设备的主屏幕开启 Web 应用时所出现的第一个页面。 根据构建的 Web 应用类型，可能需要预设如何首次加载。display 字段表示开发者希望他们的 Web 应用如何向用户展示。 通过使用 theme_color 字段，可以对浏览器的地址栏进行着色，以符合网站的主色调。 icons 字段决定了当把 Web 应用添加到设备主屏幕上时所显示的颜色。 在页面中引入清单文件： 1&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; 5.2 添加到主屏幕要显示添加到主屏幕，需要满足几个条件： 需要 manifest.json 文件 清单文件需要启动 URL 需要 144 x 144 像素的 PNG 图标 网站必须使用通过 HTTPS 运行的 Service Worker 用户至少需要访问过网站两次，并且两次访问间隔在 5min 之上（浏览器内置的条件，确保该功能不会引起用户反感） 5.2.1 定制图标1234567&quot;icon&quot;: [ &#123; &quot;src&quot;: &quot;homescreen.png&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;] 5.2.2 添加启动画面用户单击主屏幕上 Web 应用的图标后，在浏览器渲染页面的第一帧，将显示一个临时的“启动页面”。启动页面的内容是根据清单文件生成的。主要用到 name、background_color、icon 几个属性。 5.2.3 设置启动样式和 URL显示模式决定了你想如何在用户的设备上呈现你的 Web 应用，启动 URL 是用户单击主屏幕图标时将到达的第一个页面。 start_url 用来指定当用户从设备启动应用时加载的 URL。如果给定的是相对路径，那么基础路径就是清单的路径。 显示模式表示 Web 应用在操作系统环境中的展现方式： fullscreen：打开 Web 应用并占用整个可用的显示区域 standalone：打开 Web 应用以看起来像一个独立的原生应用。用户代理将排除诸如 URL 栏等标准浏览器 UI 元素，但可以包括诸如状态栏和系统返回按钮的其他系统 UI 元素。 minimal-ui：类似 fullscreen，但为用户提供了可访问的最小 UI 元素集合，例如后退按钮、前进按钮、重载按钮以及查看网页地址的一些方式。 browser：使用操作系统内置的标准浏览器打开 Web 应用。 display 是可选项，默认以 browser 模式来显示。 5.3 添加到主屏幕的高级用法5.3.1 取消提示如果不希望显示添加到主屏幕操作栏，可以取消该操作。 1234window.addEventListener(&#x27;beforeinstallprompt&#x27;, function (e) &#123; e.preventDefault() return false&#125;) 5.3.2 判断使用情况通过监听 beforeinstallprompt 事件，可以判断出用户是否决定添加 Web 应用到主屏幕或者直接关掉提示。 12345678910window.addEventListener(&#x27;beforeinstallprompt&#x27;, function (event) &#123; event.userChoice.then(function (result) &#123; // 判断用户的选择并返回 promise console.log(result.outcome) if (result.outcome == &#x27;dismissed&#x27;) &#123; // 根据用户的选择来决定如何执行 // 发送数据进行分析 &#125; else &#123; // 发送数据进行分析 &#125; &#125;)&#125;) 5.3.3 推迟提示结合以上代码使得用户可以控制是否要添加网站，而不是浏览器决定何时显示操作栏。 12345678910111213141516171819202122232425var btnSave = document.getElementById(&#x27;btnSave&#x27;)var savedPromptwindow.addEventListener(&#x27;beforeinstallprompt&#x27;, function (e) &#123; e.preventDefault() btnSave.removeAttribute(&#x27;disabled&#x27;) savedPrompt = e return false&#125;)btnSave.addEventListener(&#x27;click&#x27;, function () &#123;\tif (savedPrompt !== undefined) &#123; savedPrompt.prompt() savedPrompt.userChoice.then(function (result) &#123; if (result.outcome === &#x27;dismissed&#x27;) &#123; console.log(&#x27;User dismissed homescreen install&#x27;) &#125; else &#123; console.log(&#x27;User added to homescreen&#x27;) &#125; savedPrompt = null &#125;)\t&#125;&#125;) 5.4 调试清单文件Chrome 开发者工具的 Application 标签中，有 Manifest 菜单可快速有效查看和调整。"},{"title":"《Progressive Web Apps》读书笔记四","path":"/2018/12/16/pwa-4/","content":"第四章 拦截网络请求 本章会深入讨论 fetch 事件并展示它所提供的诸多用例。 4.1 Fetch API传统上，从服务器获取数据是通过使用 XMLHttpRequest 对象，也成为 AJAX。 12345678910111213var requestvar requestif (window.XMLHttpRequest) &#123; request = new XMLHttpRequest()&#125; else &#123; try &#123; request = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;) &#125; catch (e) &#123; try &#123; request = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) &#125; catch (e) &#123;&#125; &#125;&#125; 使用 XMLHttpRequest 对象来编写代码会相当棘手，逻辑越复杂，代码就越复杂。 Fetch API 是 Service Worker 全局作用域的一部分，可以用来在任何 Service Worker 中发起 HTTP 请求。 12345678910111213141516fetch(&#x27;/some/url&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;auth&#x27;: &#x27;1234&#x27; &#125;, body: JSON.stringify(&#123; name: &#x27;dean&#x27;, login: &#x27;dean123&#x27; &#125;)&#125;).then(function (data) &#123; console.log(&#x27;Request success: &#x27;, data)&#125;).catch(function (error) &#123; console.log(&#x27;Request failure: &#x27;, error)&#125;) 4.2 fetch 事件在 Service Worker 中创建自定义 HTTP 响应 1234567self.addEventListener(&#x27;fetch&#x27;, function (event) &#123; if (/\\.jpg$/.test(event.request.url)) &#123; event.respondWith( new Response(&#x27;&lt;p&gt;This is a response that comes from your Service Worker!&lt;/p&gt;&#x27;, &#123; header: &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;) ) &#125;&#125;) Service Worker 生命周期前文说过，只有当 Service Worker 安装完成并且用户刷新了页面或者跳转到网站的其他页面时，Service Worker 才会激活并开始拦截请求。 123self.addEventListener(&#x27;install&#x27;, function (event) &#123; event.waitUntil(self.skipWaiting())&#125;) skipWaiting() 函数强制等待中的 Service Worker 成为激活的 Service Worker。该函数还可以与 self.clients.claim() 一起使用，以确保底层 Service Worker 的更新立即生效。 123self.addEventListener(&#x27;activate&#x27;, function (event) &#123; event.waitUntil(self.clients.claim())&#125;) 4.3 fetch 实战4.3.1 使用 WebP 图片的示例支持 WebP 格式的浏览器会在每个 HTTP 请求中添加 accept: image/webp 请求头来告知服务端它支持 WebP 格式。现在 Service Worker 可以拦截请求，将 WebP 图片进行返回。 1234567891011121314151617181920self.addEventListener(&#x27;fetch&#x27;, function (event) &#123; if (/\\.jpg$|.png$/.test(event.request.url)) &#123; var supportsWebp = false if (event.request.headers.has(accept)) &#123; supportsWebp = event.request.headers.get(&#x27;accept&#x27;).includes(&#x27;webp&#x27;) &#125; if (supportsWebp) &#123; var req = event.request.clone() var returnUrl = req.url.substr(0, req.url.lastIndexOf(&#x27;.&#x27;)) + &#x27;.webp&#x27; event.resondWith( fetch(returnUrl, &#123; mode: &#x27;no-cors&#x27; &#125;) ) &#125; &#125;&#125;) 4.3.2 使用 Save-Data 请求头的示例使用最新版本浏览器，有一个节省流量的选项，启用该功能则会为每个 HTTP 请求添加一个新的请求头 saveData。 123456789self.addEventListener(&#x27;fetch&#x27;, function (event) &#123; if (event.request.headers.get(&#x27;save-data&#x27;)) &#123; // 为了节省流量限制了图标和字体 if (event.request.url.includes(&#x27;fonts.googleapis.com&#x27;)) &#123; // 不返回任何内容 event.respondWith(new Response(&#x27;&#x27;, &#123; status: 417, statusText: &#x27;Ignore fonts to save data.&#x27; &#125;)) &#125; &#125;&#125;)"},{"title":"《Progressive Web Apps》读书笔记三","path":"/2018/12/07/pwa-3/","content":"第三章 缓存 3.1 HTTP 缓存基础浏览器发起请求时，服务器返回的资源附带了一些 HTTP 响应头，告知浏览器这个资源是什么类型的，要缓存多长时间，是否压缩过等等。 使用 HTTP 缓存意味着要依赖服务器来告知何时缓存资源以及资源何时过期。如果内容具有相关性，任何更新都可能导致服务器发送的到期日期变得很容易不同步，并影响网站。 3.2 Service Worker 缓存基础Service Worker 缓存无需由服务器来告知浏览器资源需要缓存多久，可以全权掌握。 3.2.1 在 Service Worker 安装过程中预缓存12345678910var cacheName = &#x27;helloWorld&#x27; // 缓存的名称self.addEventListener(&#x27;install&#x27;, event = &#123; // 进入 Service Worker 的安装事件 event.waitUntil( caches.open(cacheName) // 使用指定的换名名称来打开缓存 .then(cache =&gt; cache.addAll([ // 把 JavaScript 和图片文件添加到缓存中 &#x27;/js/script.js&#x27;, &#x27;/images/hello.png&#x27; ])) )&#125;) 一旦缓存开启，就可以开始把资源添加进去。接下来，调用了 cache.addAll() 并传入文件数组。event.waitUntil() 方法使用了 JavaScript 的 Promise 来知晓安装所需的时间以及是否安装成功。 如果所有的文件都成功缓存了，那么 Service Worker 便会安装完成。如果有任何文件下载失败了，安装过程也随之失败。 1234567891011self.addEventListener(&#x27;fetch&#x27;, function() &#123; // 添加 fetch 事件的事件监听器 event.respondWith( caches.match(event.request) // 检查传入的请求 URL 是否匹配当前缓存中存在的任何内容 .then(function(response) &#123; if (response) &#123; // 如果有 response 并且不是未定义的或空的，就将它返回 return response &#125; return fetch(event.request) // 否则，只是如往常一样继续，通过网络获取预期的资源 &#125;) )&#125;) 3.2.2 拦截并缓存123456789101112131415161718192021222324252627282930var cacheName = &#x27;helloWorld&#x27;self.addEventListener(&#x27;fetch&#x27;, function() &#123; // 添加 fetch 事件的事件监听器 event.respondWith( caches.match(event.request) // 检查传入的请求 URL 是否匹配当前缓存中存在的任何内容 .then(function(response) &#123; if (response) &#123; // 如果有 response 并且不是未定义的或空的，就将它返回 return response &#125; var requestToCache = event.request.clone() // 复制请求。请求是一个流，只能使用一次 return fetch(requestToCache) .then(function(response) &#123; if (!response || response.status !== 200) &#123; // 如果请求失败或者服务器响应了错误代码，则立即返回错误消息 return response &#125; var responseToCache = response.clone() caches.open(cacheName) .then(function(cache) &#123; cache.put(requestToCache, responseToCache) // 将响应添加到缓存中 &#125;) return response &#125;) &#125;) )&#125;) 首先，要检查请求的资源是否存在于缓存中。如果存在于缓存中，可以就此返回缓存并不再继续执行代码。 如果缓存中没有请求资源，就按原计划发起网络请求。在代码进一步执行之前，需要复制请求，请求是一个流，只能使用一次。因为之前已经通过缓存使用了一次请求，接下来发起 HTTP 请求还要再使用一次，所以需要在此时复制请求。然后检查 HTTP 响应，确保服务器返回的是成功响应并且没有任何问题。 如果成功响应，会再次复制响应。因为想要浏览器和缓存都能够使用响应，所以需要复制它，这样就有了两个流。 最后，在代码中使用这个响应并将其添加至缓存中，以便下次再使用它。 在上面的示例中，每次返回成功的 HTTP 响应时，都能够动态地向缓存中添加资源。如果想要缓存资源但不太确定它们可能更改的频率或确切地来自哪里，这种方案可能会适合。 3.2.3 整合所有代码123456789101112131415161718192021222324252627282930313233343536373839404142var cacheName = &#x27;latestNews-v1&#x27;// 在安装过程中缓存已知的资源self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ // 在安装期间打开缓存并存储一组资源进行缓存 &#x27;./js/main.js&#x27;, &#x27;./js/article.js&#x27;, &#x27;./images/newspaper.svg&#x27;, &#x27;./css/site.css&#x27;, &#x27;./data/latest.json&#x27;, &#x27;./data/data-1.json&#x27;, &#x27;./article.html&#x27;, &#x27;./index.html&#x27; ])) )&#125;)// 缓存任何获取的新资源self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; // 监听 fetch 事件 event.respondWith( caches.match(event.request, &#123; ignoreSearch: true &#125;) // 忽略任何查询字符串参数，这样便不会造成任何缓存未命中 .then(function (response) &#123; if (response) return response // 如果发现了成功的匹配，就在此刻返回缓存并不再继续执行 var requestToCache = event.request.clone() return fetch(requestToCache) // 如果没在缓存中找到任何内容，则发起请求 .then(function (response) &#123; if (!response || response.status !== 200) &#123; return response &#125; var requestToCache = response.clone() caches.open(cacheName) // 存储在缓存中，这样便不需要再次发起请求 .then(function (cache) &#123; cache.put(requestToCache, requestToCache) &#125;) &#125;) &#125;) )&#125;) 如上代码是安装期间的预缓存和获取资源时进行缓存的组合应用。该 Web 应用使用了应用外壳架构，意味着可以利用 Service Worker 缓存来只请求填充页面所需的数据。你已经成功存储了外壳的资源，所以剩下的就是来自服务器的动态新闻内容。 3.3 缓存前后的性能对比WebPagetest.org，略。 3.4 深入 Service Worker 缓存3.4.1 对文件进行版本控制理念是每次更改文件时创建一个全新的文件名，以确保浏览器可以获取最新的内容。 3.4.2 处理额外的查询参数 ignoreSearch，忽略请求参数和缓存请求中 URL 的查询部分 ignoreMethod，忽略请求参数的方法 ignoreVary，忽略已缓存响应中的 vary 响应头 3.4.3 需要多少内存略。 3.4.4 将缓存提升到一个新的高度：WorkboxWorkbox，是一个由谷歌团队编写的辅助库，帮助快速创建 Service Worker，涵盖了最常见的网络策略。 12345678// sw.jsimportScripts(&#x27;workbox-sw.prod.v1.1.0.js&#x27;) // 加载 Workbox 库const workboxSW = new self.WorkboxSW()workboxSW.router.registerRoute( // 开始缓存匹配&#x27;/css&#x27;路径的任何请求 &#x27;https://test.org/css/(.*)&#x27;, workboxSW.strategies.cacheFirst()) 更多用法详见 Workbox 文档。"},{"title":"《Progressive Web Apps》读书笔记二","path":"/2018/12/03/pwa-2/","content":"第二章 构建 PWA 的第一步 2.1 建立在现有基础上使用 Lighthouse 对现有的 Web 应用进行性能分析和信息审核。 2.2 构建 PWA 的前端架构方式2.2.1 应用外壳架构Service Worker 可以缓存网站的 UI 外壳，以便用户重复访问。 UI 外壳是指用户界面所必须的最小化的 HTML、CSS 和 JavaScript。可能回事类似网站头部、底部和导航这样没有任何动态内容的部分。 2.2.2 性能优势对于首次访问的用户，由于是首次获取这些资源，所以该网站需要更长的下载时间。一旦所有的资源下载完成，首次访问的用户大约在 4s 后就能够与网站进行完整的交互。 对于再次访问的用户，此时 Service Worker 服务已经安装并运行，即使此时动态内容还没有从服务器返回，UI 外壳也会首先加载完成。此刻可以向用户展示一些有意义的东西，比如，通知他们目前处于离线状态或为其提供已缓存的内容。 2.2.3 应用外壳架构实战当用户首次访问网站时，Service Worker 会开始下载并自行安装。在安装阶段，可以进入这个事件并准备缓存 UI 外壳所需的所有资源，即基础的 HTML 页面和任何可能需要的 CSS 或 JavaScript。 对于不支持 Service Worker 的浏览器，此法依然有效，只是它们没有缓存 UI 外壳的资源，不会获得额外的加速性能。 把动态内容加载到网站中，网站会正常运行。当进入这些请求的 fetch 事件时，可以决定是否要缓存它们。 2.3 逐步剖析现有的 PWA以 Twitter Lite 为例。 2.3.1 前端架构在底层，Twitter Lite 是使用应用外壳架构构建的。此外还针对使用响应式网页设计的不同屏幕尺寸进行了优化。 2.3.2 缓存Service Worker 能够拦截 HTTP 请求和响应，并根据需要调整和缓存它们。Twitter Lite 使用了一个叫做 Service Worker Toolbox 的库，包含了一些使用 Service Worker 进行尝试并验证过的缓存技术。Twitter Lite 使用这项技术来缓存它们的 emoji 表情。 1234567891011toolbox.router.get(&#x27;/emoji/v2/svg/:icon&#x27;, function(event) &#123; // 拦截路径为 &#x27;/emoji/v2/svg/:icon&#x27; 的任意请求 return caches.open(&#x27;twemoji&#x27;).then(function(response) &#123; // 打开一个名为 twemoji 的已存在的缓存 return response.match(event.request).then(function(response) &#123; // 检查当前请求是否匹配缓存中的内容 return response || fetch(event.request) // 如果匹配，则立即返回缓存内容；否则，继续按照一般方式运行 &#125;) &#125;).catch(function() &#123; return fetch(event.request) // 如果在打开缓存时出现问题，继续按照一般方式运行 &#125;)&#125;, &#123; origin: /abs.*\\.twimg\\.com$/ // 只检查 twimg.com 域名下的资源&#125;) 上述代码中，寻找 URL 匹配 /emoji/v2/svg/ 并且来自 *.twimg.com 站点的任何请求。一旦拦截到匹配此路由规则的任意 HTTP 请求，就会把它们存储在名为 twemoji 的缓存之中。等下次用户再次发起匹配此路由的请求时，呈现给用户的将是缓存的结果。 2.3.3 离线浏览Service Worker 缓存可将网站资源保存到用户的设备上。基于这点可以构建离线页面。如 Twitter Lite 在没有网络连接的情况下会展现一个自定义的离线页面。 2.3.4 观感1&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; 这个文件只是简单的 JSON 文件，遵循 Web App Manifest 规范。它提供 Web 应用的信息，比如名称、作者、图标和描述。它使浏览器能够将 Web 应用安装到设备的主屏幕上，以便为用户提供更快捷的访问和更丰富的体验。通过在清单文件中设置品牌颜色，可以自定义浏览器自动显示的启动画面。还允许你自定义浏览器的地址栏以匹配你的品牌颜色。 2.3.5 最终产品Twitter Lite 的特点： 响应式的——适应较小的屏幕尺寸。 连接无关的——由于 Service Worker 缓存，它可以离线工作。 应用式的交互——它使用应用外壳架构进行构建。 始终保持最新——由于 Service Worker 的更新过程，它会不断更新。 安全的——它通过 HTTPS 进行工作。 可发现的——搜索引擎可以找到它。 可安装的——使用清单文件可以进行安装。 可链接的——可以通过 URL 来轻松分享。"},{"title":"《Progressive Web Apps》读书笔记一","path":"/2018/11/12/pwa-1/","content":"第一章 理解PWA 1.1 PWA有什么优势 响应式 独立于网络连接 类似原生应用的交互体验 始终保持更新 安全 可发现 可重连 可安装 可链接 1.2 PWA基础 这些应用不通过应用商店进行打包和部署，它们只是汲取了所需要的原生应用功能的网站而已。 1.3 Service Worker：PWA的关键PWA 功能的关键在于 Service Worker。如果浏览器不支持 Service Worker，也能简单降级为普通的网站。 1.3.1 理解 Service WorkerService Worker 有以下几个特点： 运行在它自己的全局脚本上下文中； 不绑定到具体的网页； 无法修改网页中的元素，因为它无法访问 DOM； 只能使用 HTTPS。 Service Worker 运行在 worker 上下文中，意味着它无法访问 DOM，与应用的主要 JavaScript 运行在不同的线程中，不会被阻塞。 1.3.2 Service Worker 生命周期 用户导航到一个 URL； 在注册（调用 register 函数）过程中，浏览器下载、解析和执行 Service Worker； 一旦 Service Worker 执行，就激活安装事件； 如果成功，Service Worker 现在就可以控制客户端并处理功能事件。 如果失败，register() 返回的 Promise 会执行 reject 操作，并且 Service Worker 会被废弃。 当第一次加载页面时，Service Worker 还没有激活，所以不会处理任何请求。只有刷新页面或者导航到另一个页面，Service Worker 内的逻辑才会启动。 1.3.3 Service Worker 基础示例假设创建了一个 Service Worker 文件，命名为 sw.js。需要在页面 HTML 中做如下操作： 1234567891011if (&#x27;serviceWorker&#x27; in navigator) &#123; navigator.serviceWorker.register(&#x27;./sw.js&#x27;) .then(function(registration) &#123; // 注册成功 console.log(&#x27;Service Worker registration successful with scope: &#x27;, registration.scope); &#125;) .catch(function(err) &#123; // 注册失败 console.log(&#x27;ServiceWorker registration failed: &#x27;, &#x27;err&#x27;); &#125;);&#125; Service Worker 是事件驱动的，最强大的功能之一就是允许通过进入不同的事件来监听任何网络请求。 12345self.addEventListener(&#x27;fetch&#x27;, function(event) &#123; if (/\\.jpg$/.test(event.request.url)) &#123; event.respondWith(fetch(&#x27;/images/unicon.jpg&#x27;)); &#125;&#125;) 上例监听了 fetch 事件，如果 HTTP 请求的是 JPG 文件，就拦截请求并强制返回一张指定图片。 1.3.4 安全考虑为了让 Service Worker 能在网站上运行，需要通过 HTTPS 来提供服务。"},{"title":"记一次 nginx 配置错误排查","path":"/2018/11/01/nginx-debug/","content":"Nginx 入门级选手记录某日配置错误的排查经过。 进入正文前先介绍一下本站的基本架构：我把本站的几个基础业务分在了不同的二级域名下，通过 nginx 进行反向代理。如接口在 api 二级域名下，管理后台在 admin 下等。 由于浏览器的同源策略，当 admin 的页面访问 api 的接口时会报出跨域的错误，需要通过在 nginx 设置 CORS 来解决。 123456789101112131415161718# 前略if ($http_origin = &#x27;http://admin.jackatlas.com&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS, PUT, DELETE&#x27;;&#125;if ($request_method = &#x27;OPTIONS&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With&#x27;; add_header &#x27;Access-Control-Max-Age&#x27; 1728000; add_header &#x27;Content-Length&#x27; 0; add_header &#x27;Content-Type&#x27; &#x27;text/plain, charset=utf-8&#x27;; return 204;&#125;# 后略 如上配置后，在 admin 访问 api 下的 login 接口一切正常，再访问 user 接口获取用户信息则报出两个错误：服务器 500 及跨域。 查阅 nginx 官方文档发现默认配置下只在返回 20X 和 30X 状态码时会返回自定义的请求头，即 500 状态下不会返回上面配置的请求头。 继续排查发现 500 的原因是 session 为空，则 session 中的用户信息 undefined 引起了错误。 原因是没有配置允许 cookies 跨域，需要在配置中加入： 1add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;; 并在前端访问时加上 withCredentials: true 的请求头。 如此配置后，admin 可以顺利访问 api 的接口了。但还有若干疑问尚未解决： 有几条重复的添加请求头的语句，如果把 OPTIONS 条件分支下的那几条重复的删掉，prelight 就会不通过； 尝试过把 OPTIONS 条件分支及其中的 prelight 配置都放进前面的条件分支语句中，运行 nginx -t 会报出语法错误。 PS. 感谢朱西同学的协助和解答。"},{"title":"《习惯的力量》读书笔记","path":"/2018/10/15/power-of-habit/","content":"第一章 习惯的回路 习惯是如何运作的 第二章 渴求的大脑 如何创造新习惯 第三章 习惯改变的黄金法则 为什么习惯会发生变化 第四章 核心习惯 最重要的习惯 第五章 星巴克和成功的习惯 让意志力变成自发意识 第六章 危机就是转机 领导者怎样通过事故创造新习惯 第七章 连锁销售商能预知消费者的行为 企业如何能预测操纵你的习惯 第八章 蒙哥马利公交车抵制事件 社会运动如何发生 第九章 自由意志的神经学 我们是否要为我们的习惯负责 第一章 习惯的回路 习惯是如何运作的习惯是一个由三步组成的回路。第一步，存在一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或者情感方面的。第三部则是奖赏，让大脑辨别出是否应该记下这个回路，以备将来之用。 慢慢地，这个由暗示、惯常行为、奖赏组成的回路变得越来越自动化。线索和奖赏交织在一起，直到强烈的参与意识与欲望出现。最终，习惯诞生了。 习惯回路揭示了一个基本的事实，就是在习惯出现时，大脑不再完全参与决策，要么完全静下来，要么集中去做其他的任务。 习惯往往是在未经意识的情况下出现的，但可以通过调整习惯的各个部分来重塑习惯。习惯对我们生活的影响程度超过我们的认识，实际上，习惯非常强大，能让人的大脑依赖它们，同时将逻辑等其他一切排除在外。 第二章 渴求的大脑 如何创造新习惯心理基础的基本规律： 找出一种简单又明显的暗示。 清楚地说明有哪些奖赏。 习惯能创造出神经渴求，在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，往往看不到它们的影响。 选择一个暗示（比如每次一醒来就去健身房），然后找一个奖赏（比如每次健身后来一杯奶昔）。想想奶昔或者你会感觉到身体里涌出的内啡肽。让自己去期待奖赏的出现，最终，这种渴求会让你每天更想去健身。 是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。 第三章 习惯改变的黄金法则 为什么习惯会发生变化要改变习惯，你必须留住旧习惯回路中的暗示，提供旧习惯回路中的奖赏，但要插入一个新的惯常行为。 这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。 为了永久改变习惯，人们必须相信改变是可能的。当处于团体之中时，信仰更容易建立。 习惯是不能被消除的，而只能被代替。当使用改变习惯的黄金法则时，习惯最具可塑性：如果我们保持一样的暗示和奖赏，就能植入一种新的惯常行为。但这还不够，为了保持这个习惯，人们还得相信改变是可能的。而大多数时候，只有在团体的助力下，才能形成信仰。 第四章 核心习惯 最重要的习惯一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。 核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。最重要的习惯是那些自身改变后，会驱动和重塑其他行为模式的习惯。 如果你注重改变或培养核心习惯，就能引发广泛的变化。然而，核心习惯并不容易发现，你得先知道从哪里着眼。核心习惯能为人提供“小成功”。它们通过建设新的结构以利于其他习惯的形成，并在变化扩散之处建立起某些文化。 小成功在实现胜利过程中，有着巨大的影响力。小成功其实是细微优势的稳定作用，一旦一个小成功完成了，就会推动下一个小成功的出现。小成功能够带来改造性的变化，因为它能够将细微的优势转变为一种模式，让人们相信更大的胜利即将到来。 核心习惯推动广泛变化的最后一种方法：建立能融入新价值观的文化。核心习惯会让艰难的选择变得容易。 第五章 星巴克和成功的习惯 让意志力变成自发意识意志力不是一种技能，而是一种有限的力量，用力过猛会感到疲累，剩余的力量就不足以供给其他活动。 通过锻炼意志力的活动（如体育、理财等），增加意志力的总量。 意志力转化成习惯的过程：在困境发生之前想好解决措施，然后在困境来临时依法处理。 同样的活动，消耗意志力多少的关键在于在其中是否有掌控感。当去做一些需要自我克制的事情时，如果参与者认为这是个选择或者因为可以帮助别人而让自己开心，用到的意志力就会少很多。如果他们感到自己没有自主权，只是单纯地接受命令，意志力消耗的速度就会加快。 第六章 危机就是转机 领导者怎样通过事故创造新习惯在那些没有精心设计习惯的组织中，最终会形成一种病态的模式。一个精心构建的习惯可以创造令人惊喜的改变，同样，错误的习惯会带来灾难性的结果。 几乎所有破坏性习惯都是轻率的产物，是那些拒绝构建企业文化、任其放任自流的领导者种下的恶果。没有制度习惯的组织是不存在的，一些组织没有去精心设计习惯，没有深谋远虑去创造习惯，所以往往在发展的过程中会有争斗和恐惧相伴。有时，一些能够审时度势、抓住机遇的领导者，能够转化破坏性的习惯。有时，在危机的煎熬中，正确的习惯也会应运而生。 在企业中，敌对情绪依然存在，但出于体制习惯，这种情绪会被控制在适当范围内，公司的业务也能蓬勃发展。 组织要想正常运作，领导者必须在组织中培养出一种习惯，可以创造出真实与平衡的和平，有些矛盾的是，领导者还必须清楚地定下由谁负责。 一个组织如何才能在按习惯平衡权力的同时，甄选出一个凌驾于其他人之上而拥有优先权的个人和目标？ 领导者抓住源自危机的可能。在变化动荡之中，组织习惯会变得极具可塑性，足以让人重新分配责任，创造出更加公平的权力均衡。 一个企业，无论它的组织习惯产生了怎样恶性的“和谐”氛围，无论这些习惯是出于轻率还是疏忽，都有可能做出同样的改变。可能由于领导者的命令，一个存在功能障碍习惯的企业很难做出改变。但明智的领导者会寻求危机甚至创造危机感，并让大家都有需要改变的感觉，直到最后所有人都作好准备来彻底改变他们以往习惯的行为模式。 第七章 连锁销售商能预知消费者的行为 企业如何能预测操纵你的习惯第八章 蒙哥马利公交车抵制事件 社会运动如何发生社会习惯有巨大的影响力，在于许多运动的根源： 运动的起因是友情或者亲密的熟人之间牢固的联系所形成的社会习惯。 运动的发展在于群体的习惯，以及社区与党派之间脆弱的联系。 而运动的持续在于运动领袖让参与者形成了新的习惯，树立了新的认同感和主人翁感。 通常来说，只有当以上三个过程都满足之后，一个运动才能自我推进并达到临界状态。 第九章 自由意志的神经学 我们是否要为我们的习惯负责即便习惯曾经根植于我们的头脑之中，但也不是一成不变的。在知道怎么做之后，我们可以选择自己的习惯。 要想改变习惯，那就必须有决心去改。你必须有意识地去努力寻找驱动着你的习惯每天发生的暗示和奖赏，并且找到它们的替代品。你必须知道自己可以控制习惯，也有足够的意识去使用习惯。 如果你相信你可以改变，如果你将其变成一种习惯，那么改变就是真是可行的。这就是习惯的真正力量：你的选择决定了你的习惯。一旦做出选择，并且成了自发行为，那这个选择不仅真实可行，而且似乎是无法避免的。 附录 读者实践指南理解框架 找出惯常行为 用各种奖赏进行试验 将暗示隔离出来 制订计划 第一步：找出惯常行为习惯的回路包含三部分：暗示、惯常行为和奖赏。 要弄清楚自己的习惯回路，第一步是找出自己的惯常行为。 然后要找出这一惯常行为的暗示和奖赏。 第二步：用奖赏做实验为了确定是哪些渴求在驱动习惯，就要用不同的奖赏做实验。也许会花费几天、一周或者更长的时间。在这段时间里，你在做出切实的改变时不应感到任何压力，把自己想像成数据手机阶段的科学家就行。 通过用不同的奖赏进行试验，你可以将你实际渴求的对象分隔出来，这就是重塑习惯的最基本的要素。 试了4～5个不同的奖赏后，就可以用老办法寻找其中的规律：每次活动之后，拿支笔在纸上写下你当时想到的头三样东西。 就算写下的词毫无意义也要写，原因有二。其一，迫使自己此刻意识到自己在想什么或者感觉如何。其二，写几个单词有助于今后回忆起自己当时在想什么。 第三步：分隔出暗示 之所以很难发现诱发人习惯的暗示，原因在于我们的行为包含了太多的信息量，远远超过了我们的处理能力。 事先定好有哪几类行为需要注意，以便让你发现其中的规律。几乎所有的习惯性暗示都可以归为以下五大类中的一类： 地点 时间 情绪状态 其他人 之前紧挨着的动作 每次发生惯常行为时都记录下这 5 点，通过对比若干天的记录可以发现暗示。 第四步：制订计划通过围绕暗示设计，选择能够满足你渴求的奖赏的行为，就可以改善习惯。"},{"title":"《计算机专业导论》课程笔记 第1讲","path":"/2018/09/17/ji-01/","content":"计算机、计算和计算思维 学什么课程内容组织的基本脉络自然&#x2F;社会问题 –&gt; 自然&#x2F;社会问题的求解结果 人-计算（数学计算） –&gt; 机器-自动计算（计算机科学） –&gt; 机器-难于计算（计算机科学） 针对具体的自然&#x2F;社会问题如何计算？ 计算如何与社会&#x2F;自然进行融合？ 机器-自动计算： 程序是如何被机器自动执行的：程序 vs 系统？ 如何编写机器可以执行的程序：语言 vs 编译？ 如何构造求解问题的算法：问题 -&gt; 算法 -&gt; 程序？ 机器-难于计算： 可求解 vs 难求解？ 如何降低计算量：计算 vs 算法？ 怎样研究算法？ 需要学习的计算思维奠基性思维： 0 和 1 程序 递归 计算环境： 冯·诺伊曼机 个人计算环境 并行分布环境 云计算环境 两种研究手段： 算法思维（数学建模） 系统思维（非数学建模） 抽象机制： 语言 模型 协议 自动化机制： 编译器 系统 编解码器 机制关系： 语言与编译器：人与计算机 协议与编解码器：计算机与计算机 其他思维： 数据化 网络化 怎样学知识构建次序 核心：抽象与自动化 第一层：符号化-计算化-自动化（0和1）、组合-抽象与构造：程序与系统、构造之基本手段：迭代和递归 第二层：计算系统：冯·诺伊曼计算机 –&gt; 个人计算机 –&gt; 并行分布计算环境 –&gt; 云计算环境 第三层：问题求解之算法与程序设计 第四层：网络化思维 第五层：数据化思维 第六层：面向某类学科&#x2F;方向的计算 贯通的知识才是思维语义符号化 –&gt; 符号计算化 –&gt; 计算01化 –&gt; 01自动化 –&gt; 分层构造化 –&gt; 构造继承化 社会自然现象 –&gt; 逻辑 –&gt; 二进制 –&gt; 电路 –&gt; 集成电路 –&gt; 计算机 表层意义 –&gt; 深层意义 –&gt; 集成意义 知识 vs 思维 vs 能力人-计算与机器-计算人进行计算： 一条规则可能很复杂，但计算量却可能很小 人需要知道具体的计算规则 特定规则，只能求解特定类型问题 机器-自动计算 一条规则可能很简单，但计算量却可能很大 机器也可以采用人所使用的计算规则（需要转化成程序） 一般性的规则，可以求解任意类似问题 自动计算需要解决的问题自动计算需要解决的问题数据与计算规则的表示、自动存取（表示两种状态的零件比表示十种状态的元器件更易获取，因此二进制比十进制更适合机器），计算规则的自动执行。 元器件的发展轨迹，每个阶段需要解决的问题从表示-自动存储-自动执行的角度： 电子管-可自动控制0和1变化的元件 晶体管 集成电路-可自动实现一定变化的元件 超大规模集成电路 计算 vs 计算系统输入 –&gt; 控制与计算（微处理器、中央处理单元CPU）、存储设备（内存与外存） –&gt; 输出 计算系统计算系统的发展： 微处理器：字长（表示一次处理的数据位数）（8位、16位、32位、62位）、主频（表示单位时间内完成的操作次数，Hz）（5M、20M、60M、1G、10G）、晶体管数目（1万颗、10万颗、300万颗、2800万颗、3亿颗、&gt;10亿颗） 存储设备：汞延迟线、磁带&#x2F;磁芯&#x2F;磁鼓存储、半导体存储（ROM&#x2F;RAM）、磁盘存储（硬盘与软盘）、光盘存储（CD-ROM，CD R&#x2F;W，DVD）、Flash Disk、固态硬盘，USB、纳米存储&#x2F;量子存储 输入设备：穿孔纸带（0&#x2F;1输入）、键盘输入（字符输入）、鼠标输入（点输入）、感知输入（接触式&#x2F;非接触式） 输出设备：CRT阴极射线管（模拟显示器：黑白与彩色）、CRT字符发生器（向量式模拟显示器）、CRT数字光栅扫描显示器（基于内存的显示）、数字显示器（液晶、等离子技术）、3D显示器 计算系统发展趋势 微型化：可嵌入、可携带 大型化：可进行大规模、复杂运算 智能化：理解自然语言，具有自适应性、自主完成复杂功能 网络化"},{"title":"《计算机专业导论》课程笔记 第2讲","path":"/2018/09/17/ji-02/","content":"符号化-计算化-自动化 0和1的思维概述基本的抽象自动化思维：语义符号化 -&gt; 符号计算化 -&gt; 计算01化 -&gt; 01自动化 -&gt; 分层构造化 -&gt; 构造集成化 信息如何用 0 和 1 表示(1)基本思维数值与非数值性信息 -(符号化)-&gt; 用字母-符号的组合编码 -(计算化)-&gt; 二进制（0和1） -(计算化)-&gt; 基于二进制的计算 -(支持)-&gt; 基于字母-符号的运算 -(再语意化)-&gt; 数值与非数值性信息 (2)进位制 进位制：用数码和带有权值的数位来表示有大小关系的数值性信息的表示方法。 (3)编码与ASCII码非数值性信息可以用编码表示 编码：编码是以若干位数码或符号的不同组合来表示非数值性信息的方法，它是认为地将若干位数码或符号的每一种组合指定一种唯一的含义。 ASCII 码 — 英文字母符号的编码 ASCII 码是英文字母与符号的 0，1 型编码方法，是用 8 位 0 和 1 的不同组合（首位为0）来表示 10 个数字、26 个英文大写字母、26 个英文小写字母及其一些特殊符号的编码方法，是信息交换的标准编码。 American Standard Code for Information Interchange (4)汉字与汉字编码 汉字内码：汉字在计算机内部采用汉字内码存储，汉子内码是一两字节且最高位均为 1 的 0，1型编码 汉字输入码是用键盘上的字母符号编码每一汉字的编码，它使人们通过键入字母符号代替键入汉字 汉字字形码是用 0 和 1 编码无亮点和有亮点像素，形成汉字字形的一种编码。依据字形码通过显示器或打印机输出汉字 汉字处理过程：通过汉字外码输入，以汉字内码存储，以汉字字形码输出 如何用 0 和 1 进行计算(1)易经如何基于 0 和 1 计算略 (2)看逻辑如何基于 0 和 1 计算一个命题由语句表述，即内容为“真”或为“假”的一个判断语句！如果命题由 X，Y，Z 等表示，其值可能为“真”或为“假”，则两个命题 X，Y 之间是可以进行计算的： “与”运算（AND）：当 X 和 Y 都为真时，X AND Y 也为真；其他情况，X AND Y 均为假。 “或”运算（OR）：当 X 和 Y 都为假时，X OR Y 也为假；其他情况，X OR Y 均为真。 “非”运算（NOT）：当 X 为真时，NOT X 为假；当 X 为假时，NOT X 为真。 “异或”运算（XOR）：当 X 和 Y 都为真或都为假时，X XOR Y 为假；否则，X XOR Y 为真 用 0 和 1 表示逻辑运算（1 表示真，0 表示假） “与”运算（AND）：有 0 为 0，全 1 为 1 “或”运算（OR）：有 1 为 1，全 0 为 0 “非”运算（NOT）：非 0 则 1，非 1 则 0 “异或”运算（XOR）：相同为 0，不同为 1 将减法变为加法(1)数值的符号如何表示——机器数及其原码、反码和补码 十进制数 +244 -244 二进制数 +11110100 -11110100 机器数-原码 011110100 111110100 机器数-反码 011110100 100001011 机器数-补码 011110100 100001100（反码最后一位+1） 正数的原码、反码和补码形式是一样的。最高位为 0 表示正数。 负数原码的最高位为 1，表示负数。其余同真实数值的二进制数。 负数反码的最高位为 1，表示负数。其余在真实数值的二进制数基础上逐位取反。 负数补码的最高位为 1，表示负数。其余在反码基础上最低位加 1 后形成。它的负数不包括0，但包括 -2n。 机器数由于受到表示数值的位数的限制，只能表示一定范围内的数。超出此范围则为“溢出”。 (2)使用补码可使减法变加法数值的正负符号也可和数值一样参与运算 加减乘除都可转换成加法来实现，加法又可由与、或、非、异或等逻辑运算来实现——只要实现了基本逻辑运算，便可实现任何的运算 用逻辑实现加法，用硬件实现加法(1)一位二进制数的加减法计算规则简单，与逻辑运算能够统一起来。 (2)用电路开关实现基本逻辑运算(3)用基本电子元件实现基本逻辑运算用二极管、三极管可实现基本的集成电路：与门、或门和非门 这些电路被封装成集成电路（芯片），即所谓的门电路。"},{"title":"炸牛奶","path":"/2017/06/22/fry-milk/","content":"分为奶糊和脆皮浆两部分 奶糊材料：鲜牛奶 250 克、玉米淀粉 30 克、炼乳 2 大勺、白糖少量 做法： 把牛奶、炼乳、玉米淀粉、白糖混匀搅拌至无颗粒，放入锅中，用中小火慢慢加热，边加热边搅拌，煮成糊状，熄火； 将煮好的奶糊倒入方形容器中抹平，放入冰箱冷冻 5-6 小时； 将凝固的奶糊去除切成大小适宜的方块，裹上脆皮浆炸至两面金黄（约 3-4 分钟）。 脆皮浆材料：低筋面粉 50 克、玉米淀粉 15 克、泡打粉 2 克、沙拉油 10 克、盐少许、温水 60 克 做法： 将面粉、玉米粉、泡打粉和盐放入小盆，慢慢加入温水并搅拌均匀，注意变换搅拌方向； 最后才加入沙拉油调匀，放置 20 分钟可用。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 22","path":"/2017/06/12/js-design-patterns-22/","content":"第二十二章 代码重构 22.1 提炼函数如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另一个独立的函数中。好处： 避免出现超大函数。 独立出来的函数有助于代码复用。 独立出来的函数更容易被覆写。 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。 22.2 合并重复的条件片段如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码，就有必要进行合并去重工作。 22.3 把条件分支语句提炼成函数复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。把条件分支语句提炼成单独的函数，既能更准确表达代码的意思，函数名本身又能起到注释的作用。 22.4 合理使用循环在函数体内，如果有些代码实际上负责的是一些重复性的工作，合理利用循环不仅可以完成同样的功能，还可以使代码量更少。 22.5 提前让函数退出代替嵌套条件分支嵌套的条件分支语句相比平铺的在阅读和理解上更加困难。用《重构》里的话说，嵌套的条件分支往往是由一些深信“每个函数只能有一个出口”的程序员写出的。但实际上如果对函数的剩余部分不感兴趣，就应该立即退出。 1234567891011var del = function (obj) &#123; if (obj.isReadOnly) &#123; return; &#125; if (obj.isFolder) &#123; return deleteFolder(obj) &#125; if (obj.isFile) &#123; return deleteFile(obj) &#125;&#125; 22.6 传递对象代替过长的参数列表参数的数量越多，函数就越难理解和使用。我们可以把参数都放入一个对象内，然后把该对象传入函数，函数需要的数据可以自行从该对象里获取。现在不用再关心参数的数量和顺序，只要保证参数对应的 key 值不变就可以了。 22.7 尽量减少参数数量22.8 少用三目运算符如果条件分支逻辑简单且清晰，这无碍我们使用三目运算符。 但如果条件分支逻辑非常复杂，最好的选择还是按部就班编写 if、else。 22.9 合理使用链式调用在 JavaScript 中可以很容易实现方法的链式调用，即让方法调用结束后返回对象自身： 1234567891011121314var User = function () &#123; this.id = null; this.name = null;&#125;;User.prototype.setId = function(id) &#123; this.id = id; return this;&#125;;User.prototype.setName = function(name) &#123; this.name = name; return this;&#125;; 或者： 123456789101112var User = &#123; id: null, name: null, setId: function (id) &#123; this.id = id; return this; &#125;, setName: function (name) &#123; this.name = name; return this; &#125;&#125;; 链式调用的坏处就是在调试的时候非常不方便。 如果该链条的结构相对稳定，后期不易发生修改，那么使用链式调用无可厚非。 22.10 分解大型类"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 21","path":"/2017/06/04/js-design-patterns-21/","content":"第二十一章 接口和面向接口编程 接口通常会涉及以下几种含义： 一个库或者模块通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。 一些语言提供的关键字，比如 Java 的 interface。 面向接口编程中的接口。接口是对象能响应的请求的集合。 本章主要讨论的是第二和第三种。 21.1 Java 的抽象类抽象类的一些作用： 向上转型。让 Duck 对象和 Chicken 对象的类型都隐藏在 Animal 类型身后，隐藏对象的具体类型之后，duck 对象和 chicken 对象才能被交换使用。 建立一些契约。继承自抽象类的具体类都会继承对象类里的 abstract 方法，并且要求覆盖它们。比如在命令模式中，各个子命令类都必须实现 execute 方法，才能保证在调用 command.execute 的时候不会抛出异常。 不关注对象的具体类型，而仅仅针对超类型中的“契约方法”来编写程序，可以产生可靠性高的程序，也可以极大地减少子系统实现之间的相互依赖关系： 面向接口编程，而不是面向实现编程。 从过程上看，“面向接口编程”其实是“面向超类型编程”。当对象的具体类型被隐藏在超类型身后，这些对象就可以相互替换使用，我们的关注点才能从对象的类型上转移到对象的行为上。“面向接口编程”也可以看成面向抽象编程，即针对超类型中的 abstract 方法编程，接口在这里被当成 abstract 方法中约定的契约行为。这些契约行为暴露了一个类或者对象能够做什么，但是不关心具体如何去做。 21.2 interface使用 interface 实际上也是继承的一种方式，叫做接口继承。 相对于单继承的抽象类，一个类可以实现多个 interface。抽象类中除了 abstract 方法外还有一些供子类公用的具体方法。interface 则产生一个完全抽象的类，不提供具体实现和方法体，允许创建者确定方法名、参数列表和返回类型。 interface 同样可用于向上转型。 21.3 JavaScript 语言是否需要抽象类和 interface抽象类和 interface 的作用主要是两点： 通过向上转型来隐藏对象的真正类型，以表现对象的多态性。 约定类与类之间的一些契约行为。 JavaScript 是一门动态类型语言，除了 number、string、boolean 等基本数据类型之外，其他的对象都可以被堪称“天生”被“向上转型”成 Object 类型。 因为不需要进行向上转型，接口在 JavaScript 中的最大作用就退化到了检查代码的规范性。比如检查某个对象是否实现了某个方法，或者检查是否给函数传入了预期类型的参数。 作为一门解释执行的动态类型语言，没有编译器帮助我们检查代码的规范性，只能手动编写一些接口检查的代码。 21.4 用鸭子类型进行接口检查鸭子类型是动态类型语言面向对象设计的一个重要概念。利用鸭子类型的思想，不必借助超类型的帮助，就能在动态类型语言中轻松地实现本章提到的设计原则：面向接口编程，而不是面向实现编程。 当然在 JavaScript 开发中，总是进行接口检查是不明智的，也是没必要的。 21.5 用 TypeScript 编写基于 interface 的命令模式1234567891011121314151617181920212223242526272829303132interface Command &#123; execute: Function;&#125;class RefreshMenuBarCommand implements Command &#123; constructor() &#123;&#125; execute() &#123; console.log(&#x27;刷新菜单界面&#x27;) &#125;&#125;class AddSubMenuCommand implements Command &#123; constructor() &#123;&#125; execute() &#123; console.log(&#x27;增加子菜单&#x27;) &#125;&#125;class DelSubMenuCommand implements Command &#123; constructor() &#123;&#125; // 忘记重写 execute 方法&#125;var refreshMenuBarCommand = new RefreshMenuBarCommand(), addSubMenuCommand = new AddSubMenuCommand(), delSubMenuCommand = new DelSubMenuCommand();refreshMenuBarCommand.execute(); // 输出：刷新菜单界面addSubMenuCommand.execute(); // 输出：增加子菜单delSubMenuCommand.execute(); // 输出：Uncaught TypeError:undefined is not a function 如图，TypeScript 提供的编译器及时给出了错误信息。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 20","path":"/2017/05/29/js-design-patterns-20/","content":"第二十章 开放-封闭原则 20.2 开放和封闭开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 20.3 用对象的多态性消除条件分支利用多态的思想，把程序中不变的部分隔离出来，然后把可变的部分封装起来。 1234567891011121314151617181920212223242526var makeSound = function (animal) &#123; animal.sound();&#125;;var Duck = function () &#123;&#125;;Duck.prototype.sound = function() &#123; console.log(&#x27;嘎嘎嘎&#x27;);&#125;;var Chicken = function () &#123;&#125;;Chicken.prototype.sound = function() &#123; console.log(&#x27;咯咯咯&#x27;);&#125;;makeSound(new Duck()); // 嘎嘎嘎makeSound(new Chicken()); // 咯咯咯// 增加动物狗，不用改动原有的 makeSound 函数var Dog = function () &#123;&#125;;Dog.prototype.sound = function() &#123; console.log(&#x27;汪汪汪&#x27;);&#125;; 20.4 找出变化的地方通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，只需要替换容易变化的部分，如果这些部分已经被封装好，替换起来也相对容易。 除了利用对象的多态性之外，还有其他方式可以帮助编写遵守开放-封闭原则的代码。 20.4.1 放置挂钩在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。 关于模板方法模式中的挂钩应用，可以参考第十一章。 20.4.2 使用回调函数回调函数是一种特殊的挂钩。可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。 20.5 设计模式中的开放-封闭模式20.5.1 发布-订阅模式发布-订阅模式用来降低多个对象之间的依赖关系，可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行修改；当发布者需要改变时，订阅者也不会受到影响。 20.5.2 模板方法模式在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现是可变的，于是把这部分变化的逻辑封装到子类中。增加新的子类能给系统增加新的功能，不需要改动抽象父类以及其他的子类。 20.5.3 策略模式策略模式将各种算法都封装成单独的策略类，可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。增加新的策略类不用修改之前的代码。 20.5.4 代理模式预加载图片的功能和给图片设置 src 的功能被隔离在两个函数里，它们可以单独改变而不影响。myImage 不知晓代理的存在，它可以继续专注于自己的职责——给图片设置 src。 20.5.5 职责链模式第十四章中，把一个巨大的订单函数拆成 3 个函数。这 3 个函数通过职责链连接在一起，客户的请求会在这条链条里依次传递。 当增加一个新类型的订单函数时，不需要改动原有的订单函数代码，只需在链条中增加一个新的节点。 20.6 开放-封闭原则的相对性实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 19","path":"/2017/05/22/js-design-patterns-19/","content":"第十九章 最少知识原则 最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。 19.1 减少对象之间的联系单一职责原则指导我们把对象划分成较小的粒度，可以提高对象的复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象与对象耦合在一起，可能会降低复用性。 最少知识原则要求设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。 19.2 设计模式中的最少知识原则19.2.1 中介者模式第十四章博彩公司的例子。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好概率，彩民赢了钱从博彩公司拿，输了赔钱给博彩公司。 中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。 19.2.2 外观模式外观模式主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使子系统更加容易使用。 外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高层接口，高层接口会把用户的请求转发给子系统来完成具体的功能实现。但如果外观不能满足客户的个性化需求，客户也可以选择越过外观来直接访问子系统。 比如全自动洗衣机的“一键洗衣”功能，客户可以选择一键洗衣，也可以手动控制。 简单的外观模式示例： 12345678910111213141516var A = function () &#123; a1(); a2();&#125;;var B = function () &#123; b1(); b2();&#125;;var facade = function () &#123; A(); B();&#125;;facade(); 外观模式的作用主要有两点： 为一组子系统提供一个简单便利的访问入口。 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。 从第二点来看，外观模式是符合最少知识原则的。外观系统将客户和子系统隔开之后，如果修改子系统内部，只要外观不变，就不会影响客户的调用。同样，对外观的修改也不会影响到子系统，它们可以分别变化而互不影响。 19.3 封装在最少知识原则中的体现封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。 封装也用来限制变量的作用域。在 JavaScript 中对变量作用域的规定是： 变量在全局声明，或者在代码的任何位置隐式声明（不用 var），则该变量全局可见； 变量在函数内显式声明（使用 var），则在函数内可见。 把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不想关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。 假如要编写一个具有缓存效果的计算乘积的函数 function mult () &#123;&#125;，需要一个对象 var cache = &#123;&#125; 来保存已经计算过的结果。cache 对象只对 mult 有用，把 cache 对象放在 mult 形成的闭包中，显然比把它放在全局作用域更加合适，代码如下： 12345678910111213141516var mult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, &#x27;,&#x27;); if (cache[args]) &#123; return cache[args]; &#125;; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125;; return cache[args] = a; &#125;;&#125;)();mult(1, 2, 3); // 输出：6"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 18","path":"/2017/05/15/js-design-patterns-18/","content":"第十八章 单一职责原则 就一个类而言，应该仅有一个引起它变化的原因。 在 JavaScript 中，需要用到类的场景并不太多，单一职责原则更多地是被运用在对象或者方法级别上。 单一职责（SRP）原则体现为：一个对象（方法）只做一件事情。 18.1 设计模式中的 SRP 原则18.1.1 代理模式如第六章的图片预加载例子。通过增加代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅负责往页面中添加 img 标签。 myImage 负责往页面中添加 img 标签： 123456789var myImage = (function () &#123; var imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)(); proxyImage 负责预加载图片，并在预加载完成之后把请求交给本体 myImage： 1234567891011121314var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function (src) &#123; myImage.setSrc(&#x27;xxx.gif&#x27;); img.src = src; &#125; &#125;;&#125;)();proxyImage.setSrc(&#x27;abc.jpg&#x27;); 18.1.2 迭代器模式有一段这样的代码，先遍历一个集合，然后往页面中添加一些 div，这些 div 的 innerHTML 分别对应一个集合里的元素： 123456789var appendDiv = function (data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = data[i]; document.body.appendChild(div); &#125;&#125;;appendDiv([1, 2, 3, 4, 5, 6]); appendDiv 函数承担了遍历聚合对象和渲染数据的职责，有必要把遍历 data 的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。 当把迭代聚合对象的职责单独封装在 each 函数中后，即使以后还要增加新的迭代方式，我们只需要修改 each 函数即可，appendDiv 函数不会受到牵连： 1234567891011121314151617181920212223242526272829var each = function (obj, callback) &#123; var value, i = 0, length = obj.length, isArray = isArrayLike(obj); // isArrayLike 函数此处未实现，仅作示意 if (isArray) &#123; // 迭代 object 对象 for (; i &lt; length; i++) &#123; callback.call(obj[i], i, obj[i]); &#125; &#125; else &#123; for (i in obj) &#123; // 迭代 object 对象 value = callback.call(obj[i], i, obj[i]); &#125; &#125; return obj;&#125;;var appendDiv = function (data) &#123; each(data, function (i, n) &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = n; document.body.appendChild(div); &#125;);&#125;;appendDiv([1, 2, 3, 4, 5, 6]);appendDiv(&#123; a: 1, b: 2, c: 3, d: 4 &#125;); 18.1.3 单例模式第四章实现过一个惰性单例： 12345678910111213var createLoginLayer = (function () &#123; var div; return function () &#123; if (!div) &#123; div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录浮窗&#x27;; div.style.display = &#x27;none&#x27;; document.body.appendChild(div); &#125;; return div; &#125;&#125;)(); 现在可以把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里： 1234567891011121314151617181920var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;;var createLoginLayer = function () &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录浮窗&#x27;; document.body.appendChild(div); return div;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);var loginLayer1 = createSingleLoginLayer();var loginLayer2 = createSingleLoginLayer();console.log(loginLayer1 === loginLayer2); // 输出：true 18.1.4 装饰者模式使用装饰者模式的时候，通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责。 第十五章的例子，把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面： 123456789101112131415161718Function.prototype.after = function(afterfn) &#123; var __self = this; return function () &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;;&#125;;var showLogin = function () &#123; console.log(&#x27;打开登录浮窗&#x27;);&#125;;var log = function () &#123; console.log(&#x27;上报标签为：&#x27; + this.getAttribute(&#x27;tag&#x27;));&#125;;document.getElementById(&#x27;button&#x27;).onclick = showLogin.after(log); 18.2 何时应该分离职责并不是所有的职责都应该一一分离。 一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没必要分开。 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但还没有发生改变的征兆，也许没有必要主动分离它们，在代码需要重构的时候再分离也不迟。 18.4 SRP 原则的优缺点SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，有助于代码的复用，也有利于单元测试。 最明显的缺点是增加编写代码的复杂度。当把对象分解成更小的粒度之后，实际上也增大了对象之间相互联系的难度。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 17","path":"/2017/05/07/js-design-patterns-17/","content":"第十七章 适配器模式 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 假如正在编写一个渲染广东地图的页面。目前从第三方资源里获得了广东省的所有城市以及对应的 ID，并成功渲染到页面中： 123456789101112131415161718192021var getGuangdongCity = function () &#123; var guangdongCity = [ &#123; name: &#x27;shenzhen&#x27;, id: 11 &#125;, &#123; name: &#x27;guangzhou&#x27;, id: 12 &#125; ]; return guangdongCity;&#125;;var render = function (fn) &#123; console.log(&#x27;开始渲染广东省地图&#x27;); document.write(JSON.stringify(fn()));&#125;;render(getGuangdongCity); 后来从另一个第三方资源获得了另外一些数据，但数据结构和正在运行的项目不一致： 12345var guangdongCity = &#123; shenzhen: 11, guangzhou: 12, zhuhai: 13&#125; 除了大动干戈地改写渲染页面的前端代码之外，更简便的方法是新增一个数据格式转换的适配器： 12345678910111213141516171819202122232425262728293031323334var getGuangdongCity = function () &#123; var guangdongCity = [ &#123; name: &#x27;shenzhen&#x27;, id: 11 &#125;, &#123; name: &#x27;guangzhou&#x27;, id: 12 &#125; ]; return guangdongCity;&#125;;var render = function (fn) &#123; console.log(&#x27;开始渲染广东省地图&#x27;); document.write(JSON.stringify(fn()));&#125;;var addressAdapter = function (oldAddressfn) &#123; var address = &#123;&#125;, oldAddress = oldAddressfn(); for (var i = 0, c; c = oldAddress[i++];) &#123; address[c.name] = c.id; &#125; return function () &#123; return address; &#125;&#125;;render(addressAdapter(getGuangdongCity)); 接下来就是把代码中调用 getGuangdongCity 的地方，用经过 addressAdapter 适配器转换之后的新函数来替代。 17.3 小结适配器与装饰者模式、代理模式和外观模式之间的区别。 适配器模式主要用来解决两个已有接口之间不匹配的问题，不考虑这些接口是怎样实现的，也不考虑将来会如何演化。不改变已有接口，就能够使它们协同作用。 装饰者模式和代理模式也不改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。 有人把外观模式堪称一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 16","path":"/2017/04/30/js-design-patterns-16/","content":"第十六章 状态模式 16.1 模拟面向对象的状态模式实现16.1.1 电灯程序12345678910111213141516171819202122232425262728var Light = function () &#123; this.state = &#x27;off&#x27;; this.button = null;&#125;Light.prototype.init = function() &#123; var button = document.createElement(&#x27;button&#x27;), self = this; button.innerHTML = &#x27;开关&#x27;; this.button = document.body.appendChild(button); this.button.onclick = function () &#123; self.buttonWasPressed(); &#125;;&#125;;Light.prototype.buttonWasPressed = function() &#123; if (this.state === &#x27;off&#x27;) &#123; console.log(&#x27;开灯&#x27;); this.state = &#x27;off&#x27;; &#125; else if (this.state === &#x27;on&#x27;) &#123; console.log(&#x27;关灯&#x27;); this.state = &#x27;off&#x27;; &#125;;&#125;;var light = new Light();light.init(); 上述程序的缺点： buttonWasPressed 违反“开放-封闭”原则，每次新增或者修改 light 的状态，都需要改动其中的代码，使其非常不稳定。 所有和状态有关的行为，都封装在 buttonWasPressed 方法中，无法预计以后会膨胀到什么地步。 状态的切换不明显，仅仅表现为对 state 变量赋值。在实际开发中，这样的操作容易被不小心漏掉。也无法一目了然知道一共有多少种状态，除非读完 buttonWasPressed 里的所有代码。 状态之间的切换关系，不过是往 buttonWasPressed 方法里堆砌 if、else 语句，增加或修改一个状态可能需要改变若干操作，使其难以阅读和维护。 16.1.2 状态模式改进电灯程序通常谈到封装，一般优先封装对象的行为，而不是对象的状态。但状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以 button 被按下的时候，只需在上下文中，把这个请求委托给当前的状态对象即可，该状态对象负责渲染它自身的行为。 定义三个状态类，每个类都有一个原型方法 buttonWasPressed，代表在各自状态下，按钮被按下时将发生的行为。 1234567891011121314151617181920212223242526272829// OffLightStatevar OffLightState = function (light) &#123; this.light = light;&#125;;OffLightState.prototype.buttonWasPressed = function() &#123; console.log(&#x27;弱光&#x27;); // offLightState 对应的行为 this.light.setState(this.light.weakLightState); // 切换状态到 weakLightState&#125;;// WeakLightStatevar WeakLightState = function (light) &#123; this.light = light;&#125;;WeakLightState.prototype.buttonWasPressed = function() &#123; console.log(&#x27;强光&#x27;); // weakLightState 对应的行为 this.light.setState(this.light.strongLightState); // 切换状态到 strongLightState&#125;;// StrongLightStatevar OffLightState = function (light) &#123; this.light = light;&#125;;StrongLightState.prototype.buttonWasPressed = function() &#123; console.log(&#x27;弱光&#x27;); // strongLightState 对应的行为 this.light.setState(this.light.offLightState); // 切换状态到 offLightState&#125;; 在 Light 类的构造函数里为每个状态类都创建一个状态对象，可以明显看到一共有多少种状态。 123456var Light = function () &#123; this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.button = null;&#125;; 在 button 按钮被按下的事件里，Context 也不再直接进行任何实质性的操作，而是通过 self.currState.buttonWasPressed() 将请求委托给当前持有的状态对象去执行： 123456789101112Light.prototype.init = function() &#123; var button = document.createElement(&#x27;button&#x27;), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = &#x27;开关&#x27;; this.currState = this.offLightState; // 设置当前状态 this.button.onClick = function () &#123; self.currState.buttonWasPressed(); &#125;;&#125;; 状态对象可以通过 setState 方法来切换 light 对象的状态。 123Light.prototype.setState = function(newState) &#123; this.currState = newState;&#125;; 上述写法的好处是，可以使每一种状态和对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类中，便于阅读和管理代码。 16.2 状态模式的定义 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 前半句的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的变化。 后半句的是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来，实际上是使用了委托的效果。 16.3 状态模式的通用结构首先定义了 Light 类，也被称为上下文（Context）。在 Light 的构造函数中，要创建每一个状态类的实例对象，Context 将持有这些对象的引用，以便把请求委托给状态对象。用户的请求（即点击 button 的动作）也是实现在 Context 中的。 接下来需要编写各种状态类，light 对象被传入状态类的构造函数，状态对象也需要持有 light 对象的引用，以便调用 light 中的方法或者直接操作 light 对象。 16.4 缺少抽象类的变通方式JavaScript 既不支持抽象类，也没有接口的概念。所以在使用状态模式的时候需要格外小心，如果编写一个状态子类时，忘记给其实现 buttonWasPressed 方法，则会在状态切换时抛出异常。因为 Context 总会将请求委托给状态对象的 buttonWasPressed 方法。 解决方案是让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现。 12345678910111213141516var State = function () &#123;&#125;State.prototype.buttonWasPressed = function() &#123; throw new Error(&#x27;父类的 buttonWasPressed 方法必须被重写。&#x27;)&#125;;var SuperStrongLightState = function (light) &#123; this.light = light;&#125;;SuperStrongLightState.prototype = new State(); // 继承抽象父类SuperStrongLightState.prototype.buttonWasPressed = function() &#123; console.log(&#x27;关灯&#x27;) this.light.setState(this.light.offLightState)&#125;; 16.5 文件上传示例16.5.1 更复杂的切换条件 文件在扫描状态中，不能进行任何操作。扫描完成后，根据文件的 md5 值判断，若确认该文件已经存在于服务器，则直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况才进入上传中状态。 上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传。 扫描和上传过程中，点击删除按钮无效。只有在暂停、上传完成、上传失败之后，才能删除文件。 16.5.2 一些准备工作上传是一个异步过程，所以控件会不停调用 JavaScript 提供的一个全局函数 window.external.upload，来通知 JavaScript 目前的上传进度，控件会把当前的文件状态作为参数 state 塞进 window.external.upload。 1234// 模拟的方法window.external.upload = function (state) &#123; console.log(state); // 可能为 sign、uploading、done、error&#125;; 需要在页面中放置一个用于上传的插件对象： 123456789101112131415161718192021222324252627282930var plugin = (function () &#123; var plugin = document.createElement(&#x27;embed&#x27;); plugin.style.display = &#x27;none&#x27;; plugin.type = &#x27;application/txftn-webkit&#x27;; plugin.sign = function () &#123; console.log(&#x27;开始文件扫描&#x27;); &#125;; plugin.pause = function () &#123; console.log(&#x27;暂停文件上传&#x27;); &#125;; plugin.uploading = function () &#123; console.log(&#x27;开始文件上传&#x27;); &#125;; plugin.del = function () &#123; console.log(&#x27;删除文件上传&#x27;); &#125;; plugin.done = function () &#123; console.log(&#x27;文件上传完成&#x27;); &#125;; document.body.appendChild(plugin); return plugin;&#125;)(); 16.5.3 具体代码先定义 Upload 类，控制上传过程的对象将从 Upload 类中创建而来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var Upload = function (fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.state = &#x27;sign&#x27;; // 设置初始状态为 waiting&#125;;Upload.prototype.init = function() &#123; var that = this; this.dom = document.createElement(&#x27;div&#x27;); this.dom.innerHTML = &#x27;&lt;span&gt;文件名称：&#x27; + this.fileName + &#x27;&lt;/span&gt;\\ &lt;button data-action=&quot;button1&quot;&gt;扫描中&lt;/button&gt;\\ &lt;button data-action=&quot;button2&quot;&gt;删除&lt;/button&gt;&#x27;; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector(&#x27;[data-action=&quot;button1&quot;]&#x27;); this.button2 = this.dom.querySelector(&#x27;[data-action=&quot;button2&quot;]&#x27;); this.bindEvent();&#125;;Upload.prototype.bindEvent = function() &#123; var self = this; this.button1.onclick = function () &#123; if (self.state === &#x27;sign&#x27;) &#123; // 扫描状态下，任何操作无效 console.log(&#x27;扫描中，点击无效……&#x27;); &#125; else if (self.state === &#x27;uploading&#x27;) &#123; // 上传中，点击切换到暂停 self.changeState(&#x27;pause&#x27;); &#125; else if (self.state === &#x27;pause&#x27;) &#123; // 暂停中，点击切换到上传中 self.changeState(&#x27;uploading&#x27;); &#125; else if (self.state === &#x27;done&#x27;) &#123; console.log(&#x27;文件上传完成，点击无效&#x27;); &#125; else if (self.state === &#x27;error&#x27;) &#123; console.log(&#x27;文件上传失败，点击无效&#x27;); &#125;; &#125;; this.button2.onclick = function () &#123; if (self.state === &#x27;done&#x27; || self.state === &#x27;error&#x27; || self.state === &#x27;pause&#x27;) &#123; // 上传完成、上传失败和暂停状态下可以删除 self.changeState(&#x27;del&#x27;); &#125; else if (self.state === &#x27;sign&#x27;) &#123; console.log(&#x27;文件正在扫描中，不能删除&#x27;); &#125; else if (self.state === &#x27;uploading&#x27;) &#123; console.log(&#x27;文件正在上传中，不能删除&#x27;); &#125;; &#125;;&#125;;Upload.prototype.changeState = function(state) &#123; switch (state) &#123; case &#x27;sign&#x27;: this.plugin.sign(); this.button1.innerHTML = &#x27;扫描中，任何操作无效&#x27;; break; case &#x27;uploading&#x27;: this.plugin.uploading(); this.button1.innerHTML = &#x27;正在上传中，点击暂停&#x27;; break; case &#x27;pause&#x27;: this.plugin.pause(); this.button1.innerHTML = &#x27;已暂停，点击继续上传&#x27;; break; case &#x27;done&#x27;: this.plugin.done(); this.button1.innerHTML = &#x27;上传完成&#x27;; break; case &#x27;error&#x27;: this.button1.innerHTML = &#x27;上传失败&#x27;; break; case &#x27;del&#x27;: this.plugin.del(); this.dom.parentNode.removeChild(this.dom); console.log(&#x27;删除完成&#x27;); break; &#125;; this.state = state;&#125;; 测试： 1234567891011121314151617var uploadObj = new Upload(&#x27;JavaScript设计模式与开发实践&#x27;);uploadObj.init();window.external.upload = function (state) &#123; // 插件调用 JavaScript 的方法 uploadObj.changeState(state);&#125;;window.external.upload(&#x27;sign&#x27;);setTimeout(function () &#123; window.external.upload(&#x27;uploading&#x27;); // 1 秒后开始上传&#125;, 1000);setTimeout(function () &#123; window.external.upload(&#x27;done&#x27;); // 5 秒后上传完成&#125;, 5000); 16.5.4 状态模式重构第一步提供 window.external.upload 函数，在页面中模拟创建上传插件 plugin，这部分代码没有变化。 第二步改造 Upload 构造函数，在构造函数中为每种状态子类都创建一个实例对象： 123456789101112var Upload = function (fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.signState = new SignState(this); // 设置初始状态为 waiting this.uploadingState = new UploadingState(this); this.pauseState = new PauseState(this); this.doneState = new DoneState(this); this.errorState = new ErrorState(this); this.currState = this.signState; // 设置当前状态&#125;; 第三步，Upload.prototype.init 方法无需改变。 第四步，负责具体的按钮事件实现，在点击了按钮之后，Context 并不做任何具体的操作，而是把请求委托给当前的状态类来执行： 123456789Upload.prototype.bintEvent = function() &#123; var self = this; this.button1.onclick = function () &#123; self.currState.clickHandler1(); &#125;; this.button2.onclick = function () &#123; self.currState.clickHandler2(); &#125;;&#125;; 把状态对应的逻辑行为放在 Upload 类中： 1234567891011121314151617181920212223242526272829303132Upload.prototype.sign = function() &#123; this.plugin.sign; this.currState = this.signState;&#125;;Upload.prototype.uploading = function() &#123; this.button1.innerHTML = &#x27;正在上传，点击暂停&#x27;; this.plugin.uploading(); this.currState = this.uploadingState;&#125;;Upload.prototype.pause = function() &#123; this.button1.innerHTML = &#x27;已暂停，点击继续上传&#x27;; this.plugin.pause(); this.currState = this.pauseState;&#125;;Upload.prototype.done = function() &#123; this.button1.innerHTML = &#x27;上传完成&#x27;; this.plugin.done(); this.currState = this.doneState;&#125;;Upload.prototype.error = function() &#123; this.button1.innerHTML = &#x27;上传失败&#x27;; this.currState = this.errorState;&#125;;Upload.prototype.del = function() &#123; this.plugin.del(); this.dom.parentNode.removeChild(this.dom);&#125;; 第五步，编写各个状态类的实现。这里使用了 StateFactory，从而避免 JavaScript 中没有抽象类所带来的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var StateFactory = (function () &#123; var State = function () &#123;&#125;; State.prototype.clickHandler1 = function() &#123; throw new Error(&#x27;子类必须重写父类的 clickHandler1 方法&#x27;); &#125;; State.prototype.clickHandler2 = function() &#123; throw new Error(&#x27;子类必须重写父类的 clickHandler2 方法&#x27;); &#125;; return function (param) &#123; var F = function (uploadObj) &#123; this.uploadObj = uploadObj; &#125;; F.prototype = new State(); for (var i in param) &#123; F.prototype[i] = param[i]; &#125;; return F; &#125;;&#125;)();var SignState = StateFactory(&#123; clickHandler1: function () &#123; console.log(&#x27;扫描中，点击无效……&#x27;); &#125;, clickHandler2: function () &#123; console.log(&#x27;文件正在上传中，不能删除&#x27;); &#125;;&#125;);var UploadingState = StateFactory(&#123; clickHandler1: function () &#123; this.uploadObj.pause(); &#125;, clickHandler2: function () &#123; console.log(&#x27;文件正在上传中，不能删除&#x27;); &#125;;&#125;);var PauseState = StateFactory(&#123; clickHandler1: function () &#123; this.uploadObj.uploading(); &#125;, clickHandler2: function () &#123; this.uploadObj.del(); &#125;;&#125;);var DoneState = StateFactory(&#123; clickHandler1: function () &#123; console.log(&#x27;文件已完成上传，点击无效&#x27;); &#125;, clickHandler2: function () &#123; this.uploadObj.del(); &#125;;&#125;);var ErrorState = StateFactory(&#123; clickHandler1: function () &#123; console.log(&#x27;文件上传失败，点击无效&#x27;); &#125;, clickHandler2: function () &#123; this.uploadObj.del(); &#125;;&#125;); 测试： 123456789101112131415var uploadObj = new Upload(&#x27;JavaScript设计模式与开发实践&#x27;);window.external.upload = function (state) &#123; uploadObj[state]();&#125;;window.external.upload(&#x27;sign&#x27;);setTimeout(function () &#123; window.external.upload(&#x27;uploading&#x27;); // 1秒后开始上传&#125;, 1000);setTimeout(function () &#123; window.external.upload(&#x27;done&#x27;); // 5 秒后上传完成&#125;, 5000); 16.6 状态模式的优缺点优点： 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支。 用对象代替字符串来记录当前状态，使得状态的切换一目了然。 Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 缺点是会在系统中定义许多状态类，编写状态类是一个枯燥的工作，而且会因此增加不少对象。另外，由于逻辑分布在状态类中，虽然避开了条件分支语句，但也造成了逻辑分散的问题，无法在一个地方看到整个状态机的逻辑。 16.7 状态模式中的性能优化点 有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果 state 对象比较庞大，可以用第一种方式来节省内存，可以避免创建不会用到的对象并及时回收。但如果状态的改变很频繁，最好一开始就把这些 state 对象都创建出来，也没必要销毁因为很快将再次用到。 在本章例子中，每个 Context 对象都创建了一组 state 对象，实际上这些对象之间是可以共享的，各 Context 对象共享一个 state 对象，这也是享元模式的应用场景之一。 16.8 状态模式与策略模式策略模式和状态模式的相同点是，都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。 区别是策略模式中的各个策略之间是平等有平行的，没有任何联系，所以客户必须熟知这些策略类的作用，以便随时主动切换算法；状态模式中，状态和状态对应的行为早已被封装好，状态之间的切换也早已被规定完成，“改变行为”这件事情发生在状态模式内部，对客户来说，不需要了解这些细节。 16.9 JavaScript 版本的状态机前面的示例都是模拟传统面向对象语言的状态模式实现，为每个状态定义一个状态子类，然后在 Context 中持有这些状态对象的引用，以便把 currState 设置为当前的状态对象。 在 JavaScript 这种“无类”语言中，没有规定让状态对象一定要从类中创建出来。且 JavaScript 可以非常方便使用委托技术，并不需要事先让一个对象持有另一个对象。 通过 Function.prototype.call 方法把请求委托给某个字面量对象来执行。 123456789101112131415161718192021222324252627282930313233343536var Light = function () &#123; this.currState = FSM.off; // 设置当前状态 this.button = null;&#125;;Light.prototype.init = function() &#123; var button = document.createElement(&#x27;button&#x27;), self = this; button.innerHTML = &#x27;已关灯&#x27;; this.button = document.body.appendChild(button); this.button.onclick = function () &#123; self.currState.buttonWasPressed.call(self); // 把请求委托给 FSM 状态机 &#125;;&#125;;var FSM = &#123; off: &#123; buttonWasPressed: function () &#123; console.log(&#x27;关灯&#x27;); this.button.innerHTML = &#x27;下一次按我是开灯&#x27;; this.currState = FSM.on; &#125; &#125;, on: &#123; buttonWasPressed: function () &#123; console.log(&#x27;开灯&#x27;); this.button.innerHTML = &#x27;下一次按我是关灯&#x27;; this.currState = FSM.off; &#125; &#125;&#125;;var light = new Light();light.init(); 利用下面的 delegate 函数来完成状态机编写。这是面向对象和闭包互换的一个例子，前者把变量保存为对象的属性，后者把变量封闭在闭包形成的环境中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var delegate = function (client, delegation) &#123; return &#123; buttonWasPressed: function () &#123; // 将客户的操作委托给 delegation 对象 return delegation.buttonWasPressed.apply(client, arguments); &#125;; &#125;;&#125;;var FSM = &#123; off: &#123; buttonWasPressed: function () &#123; console.log(&#x27;关灯&#x27;); this.button.innerHTML = &#x27;下一次按我是开灯&#x27;; this.currState = this.onState; &#125; &#125;, on: &#123; buttonWasPressed: function () &#123; console.log(&#x27;开灯&#x27;); this.button.innerHTML = &#x27;下一次按我是关灯&#x27;; this.currState = this.offState; &#125; &#125;&#125;;var Light = function () &#123; this.offState = delegate(this, FSM.off); this.onState = delegate(this, FSM.on); this.currState = this.offState; // 设置初始状态为关闭 this.button = null;&#125;;Light.prototype.init = function() &#123; var button = document.createElement(&#x27;button&#x27;), self = this; button.innerHTML = &#x27;已关灯&#x27;; this.button = document.body.appendChild(button); this.button.onclick = function () &#123; self.currState.buttonWasPressed(); &#125;&#125;;var light = new Light();light.init(); 16.10 表驱动的有限状态机 状态A 状态B 状态C 条件X … … … 条件Y … 状态C … 条件Z … … … 12345678910111213141516171819var fsm = StateMachine.create(&#123; initial: &#x27;off&#x27;, events: [ &#123; name: &#x27;buttonWasPressed&#x27;, from: &#x27;off&#x27;, to: &#x27;on&#x27; &#125;, &#123; name: &#x27;buttonWasPressed&#x27;, from: &#x27;on&#x27;, to: &#x27;off&#x27; &#125; ], callbacks: &#123; onButtonWasPressed: function (event, from, to) &#123; console.log(arguments); &#125; &#125;, error: function (eventName, from, to, args, errorCode, errorMessage) &#123; console.log(arguments); // 从一种状态试图切换到一种不可能到达的状态的时候 &#125;&#125;);button.onclick = function () &#123; fsm.buttonWasPressed();&#125;; github 上有一个对应的库实现：https://github.com/jakesgordon/javascript-state-machine。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 15","path":"/2017/04/22/js-design-patterns-15/","content":"第十五章 装饰者模式 在程序开发中，很多时候并不希望某个类天生就非常庞大，一次性包含许多职责。装饰者模式可以动态给某个对象添加一些额外的职责，不会影响从这个类中派生出的其他对象。 在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：以方便导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，超类的内部细节是对子类可见的，继承这种功能复用方式常常被认为破坏了封装性。 使用继承完成一些功能复用时，有可能创建出大量的子类，使子类的数量爆炸性增长。 装饰者模式能在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。 15.1 模拟传统面向对象语言的装饰者模式作为一门解释执行的语言，给 JavaScript 中的对象动态添加或者改变职责是一件简单的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式不一样，但更符合 JavaScript 的语言特色。 123456var obj = &#123; name: &#x27;sven&#x27;, address: &#x27;深圳市&#x27;&#125;obj.address = obj.address + &#x27;福田区&#x27; 传统面向对象语言的装饰者模式模拟： 1234567891011121314151617181920212223var Plane = function()&#123;&#125;Plane.prototype.fire = function() &#123; console.log(&#x27;发射普通子弹&#x27;)&#125;var MissileDecorator = function(plane) &#123; this.plane = plane&#125;MissileDecorator.prototype.fire = function() &#123; this.plane.fire() console.log(&#x27;发射导弹&#x27;)&#125;var AtomDecorator = function(plane) &#123; this.plane = plane&#125;AtomDecorator.prototype.fire = function() &#123; this.plane.fire() console.log(&#x27;发射原子弹&#x27;)&#125; 导弹类和原子弹类的构造函数都接受参数 plane 对象，并且保存好这个对象，在它们的 fire 方法中，除了执行自身的操作之外，还调用 plane 对象的 fire 方法。 这种给对象动态增加职责的方式，没有真正改动对象自身，而是将对象放入另一个对象中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都有相同的接口（fire 方法），当请求到达链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。 因为装饰者和它所装饰的对象有一致的接口，所以对使用该对象的客户来说是透明的，被装饰的对象也不需要了解它曾被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。 12345var plane = new Plane()plane = new MissileDecorator(plane)plane = new AtomDecorator(plane)plane.fire() // 分别输出：发射普通子弹、发射导弹、发射原子弹 15.2 装饰者也是包装器从功能上看，decorator 能很好地描述这个模式，从结构上看，wrapper 的说法更加贴切。装饰者模式将一个对象嵌入另一个对象中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递给所有对象，每个对象都有处理这条请求的机会。 15.3 JavaScript 的装饰者JavaScript 语言动态改变对象相当容易，可以直接改写对象或者对象的某个方法，不需要用“类”来实现装饰者模式： 1234567891011121314151617181920212223242526272829var plane = &#123; fire: function() &#123; console.log(&#x27;发射普通子弹&#x27;) &#125;&#125;var missileDecorator = function() &#123; console.log(&#x27;发射导弹&#x27;)&#125;var atomDecorator = function() &#123; console.log(&#x27;发射原子弹&#x27;)&#125;var fire1 = plane.fireplane.fire = function() &#123; fire1() missileDecorator()&#125;var fire2 = plane.fireplane.fire = function() &#123; fire2() atomDecorator()&#125;plane.fire() // 分别输出：发射普通子弹、发射导弹、发射原子弹 15.4 装饰函数需要一个办法，在不改变原函数代码的情况下增加功能。 可通过保存原引用的方式改写某个函数： 12345678window.onload = function() &#123;&#125;var _onload = window.onload || function() &#123;&#125;window.onload = function() &#123; _onload() alert(1)&#125; 但是这种方式存在两个问题： 必须维护 _onload 中间变量，如果函数的装饰链较长，或者需要装饰的函数变多，中间变量的数量也会变多。 this 被劫持。在 window.onload 中没有，是因为调用普通函数 _onload 时，this 也指向 window，跟调用 window.onload 时一样。现在把 window.onload 换成 document.getElementById 12345678910var _getElementById = document.getElementByIddocument.getElementById = function(id) &#123; alert(1) return _getElementById(id)&#125;var button = document.getElementById(&#x27;button&#x27;)// 输出：Uncaught TypeError: Illegal invocation 此时的 _getElementById 是一个全局函数，this 指向 window，而 document.getElementById 方法的内部实现需要使用 this 引用，this 在这个方法内部预期是指向 document 而不是 window。 需要手动把 document 当作上下文 this 传入 _getElementById： 1234567var _getElementById = document.getElementByIddocument.getElementById = function() &#123; alert(1) return _getElementById.apply(document, arguments)&#125;var button = document.getElementById(&#x27;button&#x27;) 15.5 用 AOP 装饰函数123456789101112131415161718Function.prototype.before = function(beforefn) &#123; var __self = this // 保存原函数的引用 return function() &#123; // 返回包含了原函数和新函数的“代理”函数 beforefn.apply(this, arguments) // 执行新函数，且保证 this 不被劫持，新函数接受的参数 // 也会被原封不动地传入原函数，新函数在原函数之前执行 return __self.apply(this, arguments) // 执行原函数并返回原函数的执行结果， // 并且保持 this 不被劫持 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var __self = this return function() &#123; var ret = __self.apply(this, arguments) afterfn.apply(this, arguments) return ret &#125;&#125; 回到之前的例子： 1234567891011window.onload = function() &#123; alert(1)&#125;window.onload = (window.onload || function() &#123;&#125;).after(function() &#123; alert(2)&#125;).after(function() &#123; alert(3)&#125;).after(function() &#123; alert(4)&#125;) 上面的实现是在 Function.prototype 上添加 before 和 after 方法，但许多人不喜欢这种污染原型的方法，可以把原函数和新函数都作为参数传入： 123456789101112131415var before = function(fn, beforefn) &#123; return function() &#123; beforefn.apply(this, arguments) return fn.apply(this, arguments) &#125;&#125;var a = function() &#123; function() &#123;alert(3)&#125; function() &#123;alert(4)&#125;&#125;a = before(a, function() &#123;alert(1)&#125;)a() 15.6 应用实例15.6.1 数据统计上报123456789var showLogin = function() &#123; console.log(&#x27;打开登录浮层&#x27;)&#125;var log = function() &#123; console.log(&#x27;上报标签为：&#x27; + this.getAttribute(&#x27;tag&#x27;))&#125;showLogin = showLogin.after(log) 15.6.2 用 AOP 动态改变函数的参数1234567Function.prototype.before = function(beforefn) &#123; var __self = this return function() &#123; beforefn.apply(this, arguments) // (1) return __self.apply(this, arguments) // (2) &#125;&#125; 在 1 和 2 处可以看到，beforefn 和原函数 __self 共用一组参数列表 arguments，当在 beforefn 函数体内改变 arguments 的时候，原函数 __self 接收的参数列表也会变化。 下面例子展示如何通过 Function.prototype.before 方法给函数 func 的参数 param 动态添加属性 b： 123456789var func = function(param) &#123; console.log(param)&#125;func = function(function(param) &#123; param.b = &#x27;b&#x27;&#125;)func(&#123; a: &#x27;a&#x27; &#125;) 如，用 AOP 方法给 ajax 函数动态装饰上 Token 参数，保证 ajax 函数是一个相对纯净的函数，提高其复用性。 123456789101112131415var ajax = function(type, url, param) &#123; console.log(param)&#125;var getToken = function() &#123; return &#x27;Token&#x27;&#125;ajax = ajax.before(function(type, url, param) &#123; param.Token = getToken()&#125;)ajax(&#x27;get&#x27;, &#x27;http://xx.com/userinfo&#x27;, &#123; name: &#x27;sven&#x27; &#125;)// 输出：&#123; name: &#x27;sven&#x27;, Token: &#x27;Token&#x27; &#125; 15.6.3 插件式的表单验证分离校验输入和提交 ajax 请求的代码。 12345678910111213141516171819202122232425262728293031Function.prototype.before = function(beforefn) &#123; var __self = this return function() &#123; if (beforefn.apply(this, arguments) === false) &#123; // beforefn 返回 false 的情况则 return，不再实行后面的原函数 return &#125; return __self.apply(this, arguments) &#125;&#125;var validate = function() &#123; if (username.value === &#x27;&#x27;) &#123; alert(&#x27;用户名不能为空&#x27;) return false &#125; if (password.value === &#x27;&#x27;) &#123; alert(&#x27;密码不能为空&#x27;) return false &#125;&#125;var formSubmit = function() &#123; var param = &#123; username: username.value, password: password.value &#125; ajax(&#x27;http://xx.com/login&#x27;, param)&#125;formSubmit = formSubmit.before(validate) validate 成为一个即插即用的函数，甚至可以被写成配置文件的形式，有利于我们分开维护。再利用策略模式稍加改造，就可以把这些校验规则都写成插件的形式，用在不同的项目中。 因为新函数通过 Function.prototype.before 或者 Function.prototype.after 被装饰之后，返回的实际上是一个新函数，如果在原函数上保存了一些属性，那么这些属性会丢失。 另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会有影响。 15.7 装饰者模式和代理模式装饰者模式和代理模式最重要的区别在于它们的意图和设计目的。 代理模式的目的是，当直接访问本体不方便或者不符合需求时，为这个本体提供一个替代者。本体定义了关键功能，代理提供或者拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是对对象动态加入行为。代理模式强调一种关系，这种关系可以静态的表达，即一开始就可以被确定。装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层“代理-本体”的引用，装饰者模式经常会形成一条装饰链。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 14","path":"/2017/04/15/js-design-patterns-14/","content":"第十四章 中介者模式 在程序里，也许一个对象会保持对其他多个对象的引用，当对象很多，难免会形成网状的交叉引用。当改变或删除其中一个对象时，需要通知所有引用到它的对象。 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需通知中介者对象即可。中介者模式使网状的多对多关系变成了相对简单的一对多关系。 14.2 中介者模式的例子——泡泡堂游戏首先是定义 Player 构造函数和 player 对象的原型方法，在 player 对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象 playerDirector。 1234567891011121314151617181920212223242526function Player(name, teamColor) &#123; this.name = name this.teamColor = teamColor this.state = &#x27;alive&#x27;&#125;Player.prototype.win = function() &#123; console.log(this.name + &#x27;won&#x27;)&#125;Player.prototype.lose = function() &#123; console.log(this.name + &#x27;lost&#x27;)&#125;Player.prototype.die = function() &#123; this.state = &#x27;dead&#x27; playerDirector.ReceiveMessage(&#x27;playerDead&#x27;, this)&#125;Player.prototype.remove = function() &#123; playerDirector.ReceiveMessage(&#x27;removePlayer&#x27;, this)&#125;Player.prototype.changeTeam = function() &#123; playerDirector.ReceiveMessage(&#x27;changeTeam&#x27;, this, color)&#125; 工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义 123456var playerFactory = function(name, teamColor) &#123; var newPlayer = new Player(name, teamColor) playerDirector.ReceiveMessage(&#x27;addPlayer&#x27;, newPlayer) return newPlayer&#125; 实现中介者 playerDirector 对象一般有两种方式 发布-订阅模式。将 playerDirector 实现为订阅者，各 player 作为发布者。 在 playerDirector中开放一些接收消息的接口，各 player 可以直接调用该接口来给 playerDirector 发送消息，player 只需传递一个参数给 playerDirector，这个参数的目的是使 playerDirector 可以识别发送者。同样，playerDirector 接收到消息之后会将处理结果反馈给其他 player。 这里我们使用第二种方式，playerDirector 开放一个对外暴露的接口 ReceiveMessage，负责接收 player 对象发送的消息，而 player 对象发送消息的时候，总是把自身 this 作为参数发送给 playerDirector，以便 playerDirector 识别。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var playerDirector = (function() &#123; var players = &#123;&#125;, operations = &#123;&#125; operations.addPlayer = function(player) &#123; var teamColor = player.teamColor players[teamColor] = players[teamColor] || [] players[teamColor].push(player) &#125; operations.removePlayer = function(player) &#123; var teamColor = player.teamColor, teamPlayers = players[teamColor] || [] for (var i = teamPlayers.length - 1; i &gt;= 0; i--) &#123; if (teamPlayers[i] === player) &#123; teamPlayers.splice(i, 1) &#125; &#125; &#125; operations.changeTeam = function(player, newTeamColor) &#123; operations.removePlayer(player) player.teamColor = newTeamColor operations.addPlayer(player) &#125; operations.playerDead = function(player) &#123; var teamColor = player.teamColor, teamPlayers = players[teamColor] var all_dead = true for (var i = 0, player; player = teamPlayers[i++];) &#123; if (player.state !== &#x27;dead&#x27;) &#123; all_dead = false break &#125; &#125; if (all_dead === true) &#123; for (var i = 0, player; player = teamPlayers[i++];) &#123; player.lose() &#125; for (var color in players) &#123; if (color !== teamColor) &#123; var teamPlayers = players[color] for (var i = 0, player; player = teamPlayers[i++];) &#123; player.win() &#125; &#125; &#125; &#125; &#125; var ReceiveMessage = function() &#123; var message = Array.prototype.shift.call(arguments) operations[message].apply(this, arguments) &#125; return &#123; ReceiveMessage: ReceiveMessage &#125;&#125;)(); 除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。我们还可以给中介者扩展更多功能。 14.4 小结中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他对象。而在中介者模式中，对象之间几乎不知道彼此的存在，只能通过中介者对象来相互影响对方。 中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。 中介者模式最大的缺点是系统中会增加一个中介者对象，因为对象之间"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 13","path":"/2017/04/08/js-design-patterns-13/","content":"第十三章 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。 13.4链中的各个节点需要可以灵活拆分和重组。 1234567891011121314151617181920212223var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log(&#x27;500元定金预购，得到100优惠券&#x27;) &#125; else &#123; return &#x27;nextSuccessor&#x27; // 我不知道下一个节点是谁，反正把请求往后传递 &#125;&#125;var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log(&#x27;200元定金预购，得到50优惠券&#x27;) &#125; else &#123; return &#x27;nextSuccessor&#x27; // 我不知道下一个节点是谁，反正把请求往后传递 &#125;&#125;var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log(&#x27;普通购买，无优惠券&#x27;) &#125; else &#123; console.log(&#x27;手机库存不足&#x27;) &#125;&#125; 接下来把函数装进职责链节点，定义一个构造函数 Chain，在 new Chain 的时候传递的参数即为需要被包装的函数，同时它还有一个实例属性 this.successor，表示在链中的下一个节点。 此外 Chain 的 prototype 中还有两个函数，作用如下： 12345678910111213141516171819// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function(fn) &#123; this.fn = fn this.successor = null&#125;Chain.prototype.setNextSuccessor = function(successor) &#123; return this.successor = successor&#125;Chain.prototype.passRequest = function() &#123; var ret = this.fn.apply(this, arguments) if (ret === &#x27;nextSuccessor&#x27;) &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments) &#125;&#125; 把3个订单函数分别包装成职责链的节点： 123var chainOrder500 = new Chain(order500)var chainOrder200 = new Chain(order200)var chainOrderNormal = new Chain(orderNormal) 然后指定节点在职责链中的顺序： 12chainOrder500.setNextSuccessor(chainOrder200)chainOrder200.setNextSuccessor(chainOrderNormal) 把请求传递给第一个节点 1chainOrder500.passRequest(1, true, 500) // 输出：500元定金预购，得到100优惠券 如此，可灵活增加、删除和修改链中的节点顺序。 13.5 异步的职责链给 Chain 类再增加一个原型方法 Chain.prototype.next，表示手动传递请求给职责链中的下一个节点： 123Chain.prototype.next = function() &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)&#125; 例子： 12345678910111213141516171819var fn1 = new Chain(function() &#123; console.log(1) return &#x27;nextSuccessor&#x27;&#125;)var fn2 = new Chain(function() &#123; console.log(2) var self = this setTimeout(function() &#123; self.next() &#125;, 1000)&#125;)var fn3 = new Chain(function() &#123; console.log(3)&#125;)fn1.setNextSuccessor(fn2).setNextSuccessor(fn3)fn1.passRequest() 请求在链中的节点里传递，但节点有权决定什么时候把请求交给下一个节点。可以想象，一部的职责链加上命令模式（把ajax请求封装成命令对象，详见第九章），可以很方便地创建一个ajax队列库。 13.6 职责链模式的优缺点职责链模式的最大优点就是解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可。 使用了职责链模式后，链中的节点对象可以灵活地拆分重组。增加或者删除一个节点，或者改变节点在链中的位置都是轻而易举的事情。 还有一个优点，可以手动指定起始节点。 这种模式并非没有弊端。首先我们不能保证某个请求一定会被链中的节点处理，此时的请求就得不到答复，而是径直从链尾离开，或者抛出一个异常错误。在这种情况下，可以在链尾增加一个保底的接受者来处理这种即将离开链尾的请求。 另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，仅仅是让请求传递下去，从性能方面考虑，要避免过长的职责链带来的性能损耗。 13.7 用 AOP 实现职责链之前的实现中，我们用一个 Chain 类来把普通函数包装成职责链的节点。利用 JavaScript 的函数式特性，有一种更方便的方法来创建职责链。 改写一下第三章 3.2.3 的 Function.prototype.after 函数，使得第一个函数返回 ‘nextSuccessor’ 时，将请求继续传递给下一个函数。 123456789101112131415Function.prototype.after = function(fn) &#123; var self = this; return function() &#123; var ret = self.apply(this, arguments) if (ret === &#x27;nextSuccessor&#x27;) &#123; return fn.apply(this, arguments) &#125; return ret &#125;&#125;var order = order500yuan.after(order200yuan).after(orderNormal)order(1, true, 500) // 输出：500元定金预购，得到100优惠券 13.8 用职责链模式获取文件上传对象在第七章有一个用迭代器获取文件上传对象的例子，其实用职责链模式可以更简单。 1234567891011121314151617181920212223var getActiveUploadObj = function() &#123; try &#123; return new ActiveXObject(&#x27;TXFNActiveX.FTNUpload&#x27;) // IE &#125; catch (e) &#123; return &#x27;nextSuccessor&#x27; &#125;&#125;var getFlashUploadObj = function() &#123; if (supportFlash()) &#123; var str = &#x27;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&#x27; return $(str).appendTo($(&#x27;body&#x27;)) &#125; return &#x27;nextSuccessor&#x27;&#125;var getFormUploadObj = function() &#123; return $(&#x27;&lt;form&gt;&lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&lt;/form&gt;&#x27;).appendTo($(&#x27;body&#x27;))&#125;var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUploadObj)console.log(getUploadObj()) 13.9 小结无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 12","path":"/2017/03/15/js-design-patterns-12/","content":"第十二章 享元模式 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。 12.1 初识享元模式假设有 50 种男士内衣和 50 种女士内衣，需生产一些塑料模特穿内衣拍照片。 123456789101112131415161718var Model = function (sex, underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function () &#123; console.log(&#x27;sex= &#x27; + this.sex + &#x27; underwear=&#x27; + this.underwear);&#125;;for (var i = 1; i &lt;= 50; i++) &#123; var maleModel = new Model(&#x27;male&#x27;, &#x27;underwear&#x27; + i); maleModel.takePhoto();&#125;;for (var j = 1; j &lt;= 50; j++) &#123; var femaleModel = new Model(&#x27;female&#x27;, &#x27;underwear&#x27; + j); femaleModel.takePhoto();&#125;; 要得到一张照片，每次都需要传入 sex 和 underwear 参数，现有 50 种男内衣和 50 种女内衣，一共产生 100 个对象。如果有 10000 种内衣，程序可能因为存在太多对象而崩溃。 优化：男模特和女模特各有一个就够了。 123456789101112131415161718192021222324// 先把 underwear 参数从构造函数中移除，构造函数只接收 sex 参数。var Model = function (sex) &#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function () &#123; console.log(&#x27;sex= &#x27; + this.sex + &#x27; underwear=&#x27; + this.underwear);&#125;;// 分别创建一个男模特对象和一个女模特对象。var maleModel = new Model(&#x27;male&#x27;), femaleModel = new Model(&#x27;female&#x27;);// 给男模特一次穿上所有男装并拍照。for (var i = 1; i &lt;= 50; i++) &#123; maleModel.underwear = &#x27;underwear&#x27; + i; maleModel.takePhoto();&#125;;// 给女模特一次穿上所有女装并拍照。for (var j = 1; j &lt;= 50; j++) &#123; femaleModel.underwear = &#x27;underwear&#x27; + j; femaleModel.takePhoto();&#125;; 12.2 内部状态与外部状态享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量。 内部状态存储于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。 剥离了外部状态的对象称为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。享元模式是一种用时间换空间的优化模式。 通常来讲，内部状态有多少种组合，系统中便存在多少个对象。 12.3 享元模式的通用结构上述例子中还存在以下问题： 通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始就需要所有的共享对象。 给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，不是最好的方法，因为外部状态可能会相当复杂，与共享对象之间的联系会变得困难。 通过对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，才从工厂中被创建出来。第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。 12.4 文件上传的例子12.4.1 对象爆炸每一个文件对应一个 JavaScript 上传对象的创建，若同时往程序里 new 了极多个对象，则会造成浏览器崩溃。 当用户选择文件之后，插件和 Flash 都会通知 Window 下的一个全局 JavaScript 函数 startUpload，文件列表被组合成一个数组 files 塞进该函数的参数列表里： 12345678var id = 0;window.startUpload = function (uploadType, file) &#123; // upload 区分是控件还是 flash for (var i = 0, file; file = files[i++];) &#123; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); uploadObj.init(id++); // 给 upload 对象设置一个唯一的 id &#125;&#125; 当用户选择完文件之后，startUpload 函数会遍历 files 数组来创建对应的 upload 对象。Upload 构造函数接受 3 个参数，分别是插件类型、文件名和文件大小。这些信息已经被组装在 files 数组里返回： 1234567891011121314151617var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;;Upload.prototype.init = function (id) &#123; var that = this; this.id = id; this.dom = document.createElement(&#x27;div&#x27;); this.dom.innerHTML = &#x27;&lt;span&gt;文件名称：&#x27; + this.fileName + &#x27;，文件大小：&#x27; + this.fileSize + &#x27;&lt;/span&gt;&#x27; + &#x27;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&#x27;; this.dom.querySelector(&#x27;.delFile&#x27;).onclick = function () &#123; that.delFile(); &#125; document.body.appendChild(this.dom);&#125;; 为了简化示例，该对象只有删除文件的功能，对应方法是 Upload.prototype.delFile。该方法中又一个逻辑：当被删除的文件小于 3000KB 时，该文件将被直接删除。否则页面中会弹出一个提示框，询问用户是否确认删除。 123456789Upload.prototype.delFile = function () &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm(&#x27;确定要删除该文件吗？&#x27; + this.fileName) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 创建上传对象： 123456789101112131415161718192021startUpload(&#x27;plugin&#x27;, [ &#123; fileName: &#x27;1.txt&#x27;, fileSize: 1000 &#125;, &#123; fileName: &#x27;2.html&#x27;, fileSize: 3000 &#125;]);startUpload(&#x27;flash&#x27;, [ &#123; fileName: &#x27;4.txt&#x27;, fileSize: 1000 &#125;, &#123; fileName: &#x27;5.html&#x27;, fileSize: 3000 &#125;]); 12.4.2 享元模式重构文件上传upload 对象必须依赖 uploadType 属性才能工作，这是因为插件上传、Flash 上传、表单上传的实际工作原理有很大的区别，各自调用的接口也是完全不一样的，必须在对象创建之初就明确其上传类型，才可以在程序的运行过程中，分别调用各自的 start、pause、cancel、del 等方法。 一旦明确了 uploadType，无论使用什么方法上传，这个上传对象都可被人和文件共用的。而 fileName 和 fileSize 是根据场景变化的，每个文件的 fileName 和 fileSize 不一样，无法共享，划分为外部状态。 12.4.3 剥离外部状态123var Upload = function (uploadType) &#123; this.uploadType = uploadType;&#125;; Upload.prototype.init 函数也不再需要，因为 upload 对象初始化的工作被放在了 uploadManager.add 函数里面，接下来只需定义 Upload.prototype.del 函数即可： 12345678910Upload.prototype.delFile = function (id) &#123; uploadManager.setExternalState(id, this); // (1) if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm(&#x27;确定要删除该文件吗？&#x27; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 在删除文件前，需读取文件大小，而文件大小的信息被储存在外部管理器 uploadManager 中，所以需要通过 uploadManager.setExternalState 方法给共享对象设置正确的 fileSize，(1) 中表示把当前 id 对应的对象的外部状态都组装到共享对象中。 12.4.4 工厂进行对象实例化如果某种内部状态对应的共享对象已经被创建过，则直接返回这个对象，否则创建一个新的对象： 12345678910111213var UploadFactory = (function () &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function (uploadType) &#123; if (createFlyWeightObjs[uploadType]) &#123; return createFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;&#125;)(); 12.4.5 管理器封装外部状态uploadManager 对象负责向 UploadFactory 提交创建对象的请求，并用一个 uploadDatabase 对象保存所有 upload 对象的外部状态，以便在程序运行过程中给 upload 共享对象设置外部状态： 1234567891011121314151617181920212223242526272829303132var uploadManager = (function () &#123; var uploadDatabase = &#123;&#125;; return &#123; add: function (id, uploadType, fileName, fileSize) &#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement(&#x27;div&#x27;); dom.innerHTML = &#x27;&lt;span&gt;文件名称：&#x27; + fileName + &#x27;，文件大小：&#x27; + fileSize + &#x27;&lt;/span&gt;&#x27; + &#x27;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&#x27;; dom.querySelector(&#x27;.delFile&#x27;).onclick = function () &#123; flyWeightObj.delFile(id); &#125; document.body.appendChild(dom); uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;; return flyWeightObj; &#125;, setExternalState: function (id, flyWeightObj) &#123; var uploadData = uploadDatabase[id]; for (var i in uploadData) &#123; flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;&#125;)(); 触发上传动作的 startUpload 函数： 1234567var id = 0;window.startUpload = function (uploadType, files) &#123; for (var i = 0, file; file = files[i++];) &#123; var uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125;&#125;; 运行同样的代码创建上传对象，结果与之前的一致： 123456789101112131415161718192021startUpload(&#x27;plugin&#x27;, [ &#123; fileName: &#x27;1.txt&#x27;, fileSize: 1000 &#125;, &#123; fileName: &#x27;2.html&#x27;, fileSize: 3000 &#125;]);startUpload(&#x27;flash&#x27;, [ &#123; fileName: &#x27;4.txt&#x27;, fileSize: 1000 &#125;, &#123; fileName: &#x27;5.html&#x27;, fileSize: 3000 &#125;]); 重构前的代码里一共创建了 4 个 upload 对象，用享元模式重构后，对象数量减为 2，就算现在同时上传 2000 个文件，需要创建的 upload 对象数量依然是 2。 12.5 享元模式的适用性享元模式是一种比较好的性能优化方案，但也会带来一些复杂性的问题，前面的例子中，使用享元模式后需要分别多维护一个 factory 对象和一个 manager 对象，在大部分不必要使用享元模式的情境下，这些开销是可以避免的。 一般来说，以下情况发生时便可以使用享元模式： 一个程序中使用了大量的相似对象。 由于使用了大量对象，造成很大的内存开销。 对象的大多数状态都可以变为外部状态。 剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象。 12.6 再谈内部状态和外部状态实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便存在多少个共享对象，而外部状态储存在共享对象的外部，必要时被传入共享对象来组装成一个完整的对象。现在来考虑两种极端的情况，即对象没有内部状态和没有外部状态的情况。 12.6.1 没有内部状态的享元在前面的例子中，如果一个网站只支持单一上传方式，这意味着之前代码中作为内部状态的 uploadType 属性是可以删除掉的。 1var Upload = function () &#123;&#125;; 其他属性依然可以作为外部状态保存在共享对象外部。 123456789101112var UploadFactory = (function () &#123; var uploadObj; return &#123; create: function () &#123; if (uploadObj) &#123; return uploadObj; &#125; return uploadObj = new Upload(); &#125; &#125;&#125;)(); 管理器部分的代码不需要改动，还是负责剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。这时的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，仍倾向于称之为享元模式。 12.6.2 没有外部状态的享元没有剥离外部状态的过程，a1 和 a2 指向同一个对象，所以即使使用了共享的技术，也不是纯粹的享元模式。 12.7 对象池对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责后，再进入池子等待被下一次获取。 在 Web 前端开发中，对象池使用最多的场景大概就是跟 DOM 有关的操作。很多时间和空间都消耗在了 DOM 节点上。 12.7.1 对象池实现以地图为例，某两次搜索结果数量分别为 2 和 4。按照对象池的思想，第二次搜索开始前，并不会把第一次创建的 2 个气泡删除掉，而是放进对象池，这样在现实第二次搜索结果时，只需再创建 4 个气泡而不是 6 个。 先定义一个获取小气泡节点的工厂，作为对象池的数组称为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create 表示获取一个 div 节点，recover 表示回收一个节点： 123456789101112131415161718var toolTipFactory = (function () &#123; var toolTipPool = []; // toolTip 对象池 return &#123; create: function () &#123; if (toolTipPool.length == 0) &#123; // 如果对象池为空 var div = document.createElement(&#x27;div&#x27;); // 创建一个节点 document.body.appendChild(div); return div; &#125; else &#123; return toolTipPool.shift(); // 则从对象池中取出一个dom &#125; &#125;, recover: function (tooltipDom) &#123; return toolTipPool.push(tooltipDom); // 对象池回收 dom &#125; &#125;&#125;) 第一次搜索时需要创建 2 个小气泡节点，为方便回收，用一个数组 ary 来记录它们： 123456var ary = [];for (var i = 0, str; str = [&#x27;A&#x27;, &#x27;B&#x27;][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; ary.push(toolTip);&#125;; 接下来假设地图要开始重新绘制，在此之前把这两个节点回收进对象池： 123for (var i = 0, toolTip; toolTip = ary[i++];) &#123; recover(toolTip);&#125;; 再创建 6 个气泡： 1234for (var i = 0, str; str = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str;&#125;; 对象池和享元模式的思想有点相似，虽然 innerHTML 的值 A、B、C、D 等也可看成节点的外部状态，但在这里没有主动分离内部状态和外部状态。 12.7.2 通用对象池实现可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池： 1234567891011121314var objectPoolFactory = function (createObjFn) &#123; var objectPool = []; return &#123; create: function () &#123; var obj = objectPool.length === 0 ? createObjFn.apply(this, arguments) : objectPool.shift(); return obj; &#125;, recover: function (obj) &#123; objectPool.push(obj); &#125; &#125;&#125;; 现在利用 objectPoolFactory 来创建一个装载一些 iframe 的对象池： 12345678910111213141516171819202122var iframeFactory = objectPoolFactory(function () &#123; var iframe = document.createElement(&#x27;iframe&#x27;); document.body.appendChild(iframe); iframe.onload = function () &#123; iframe.onload = null; // 防止 iframe 重复加载的 bug iframeFactory.recover(iframe); // iframe 加载完成之后回收节点 &#125; return iframe;&#125;);var iframe1 = iframeFactory.create();iframe.src = &#x27;http://baidu.com&#x27;;var iframe2 = iframeFactory.create();iframe.src = &#x27;http://QQ.com&#x27;;setTimeout(function () &#123; var iframe3 = iframeFactory.create(); iframe3.src = http://163.com&#125;, 3000) 对象池是另一种性能优化方案，和享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 11","path":"/2017/03/04/js-design-patterns-11/","content":"第十一章 模版方法模式 11.1 模版方法模式的定义和组成模版方法模式是一种只需使用继承机制，但我们可以通过原型 prototype 来变相地实现集成。 模版方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 在模版方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。 11.2 Coffee or Tea11.2.1 先泡一杯咖啡 (1) 把水煮沸 (2) 用沸水冲泡咖啡 (3) 把咖啡倒进杯子 (4) 加糖和牛奶 123456789101112131415161718192021222324252627var Coffee = function () &#123;&#125;;Coffee.prototype.boilWater = function () &#123; console.log(&#x27;把水煮沸&#x27;);&#125;;Coffee.prototype.brewCoffeeGriends = function () &#123; console.log(&#x27;用沸水冲泡咖啡&#x27;);&#125;;Coffee.prototype.pourInCup = function () &#123; console.log(&#x27;把咖啡倒进杯子&#x27;);&#125;;Coffee.prototype.addSugarAndMilk = function () &#123; console.log(&#x27;加糖和牛奶&#x27;);&#125;;Coffee.prototype.init = function () &#123; this.boilWater(); this.brewCoffeeGriends(); this.pourInCup(); this.addSugarAndMilk();&#125;;var coffee = new Coffee();coffee.init(); 11.2.2 泡一壶茶 (1) 把水煮沸 (2) 用沸水浸泡茶叶 (3) 把茶水倒进杯子 (4) 加柠檬 123456789101112131415161718192021222324252627var Tea = function () &#123;&#125;;Tea.prototype.boilWater = function () &#123; console.log(&#x27;把水煮沸&#x27;);&#125;;Tea.prototype.steepTeaBag = function () &#123; console.log(&#x27;用沸水浸泡茶叶&#x27;);&#125;;Tea.prototype.pourInCup = function () &#123; console.log(&#x27;把茶水倒进杯子&#x27;);&#125;;Tea.prototype.addLemon = function () &#123; console.log(&#x27;加柠檬&#x27;);&#125;;Tea.prototype.init = function () &#123; this.boilWater(); this.steepTeaBag(); this.pourInCup(); this.addLemon();&#125;;var tea = new Tea();tea.init(); 11.2.3 分离出共同点 泡咖啡 泡茶 把水煮沸 把水煮沸 用沸水冲泡咖啡 用沸水浸泡茶叶 把咖啡倒进杯子 把茶水倒进杯子 加糖和牛奶 加柠檬 不同点： 原料不同，但都可以抽象成“饮料”。 泡的方式不同，但都可以抽象成“泡”。 加入的调料不同，但都可以抽象成“调料”。 整理成： (1) 把水煮沸 (2) 用沸水冲泡饮料 (3) 把饮料倒进杯子 (4) 加调料 123456789101112131415161718var Beverage = function () &#123;&#125;;Beverage.prototype.boilWater = function () &#123; console.log(&#x27;把水煮沸&#x27;);&#125;;Beverage.prototype.brew = function () &#123;&#125;; // 空方法，应该由子类重写Beverage.prototype.pourInCup = function () &#123;&#125;; // 空方法，应该由子类重写Beverage.prototype.addCondiments = function () &#123;&#125;; // 空方法，应该由子类重写Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;; 11.2.4 创建 Coffee 子类和 Tea 子类1234567891011121314151617var Coffee = function () &#123;&#125;;Coffee.prototype = new Beverage();Coffee.prototype.brew = function () &#123; console.log(&#x27;用沸水冲泡咖啡&#x27;);&#125;Coffee.prototype.pourInCup = function () &#123; console.log(&#x27;把咖啡倒进杯子&#x27;);&#125;Coffee.prototype.addCondiments = function () &#123; console.log(&#x27;加糖和牛奶&#x27;);&#125;var coffee = new Coffee();coffee.init(); Tea 同理。 Beverage.prototype.init 被称为模版方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模版，指导子类以何种顺序去执行哪些方法。在 Beverage.prototype.init 方法中，算法内的每一个步骤都清楚地展示在我们眼前。 11.3 抽象类模版方法模式是一种严重依赖抽象类的设计模式。JavaScript 在语言层面并没有提供对抽象类的支持，也很难模拟抽象类的实现，但可以进行一定的让步和变通。 11.3.1 抽象类的作用在 Java 中，类分为两种，一种为具体类，另一种为抽象类。具体类可被实例化（咖啡），抽象类不可被实例化（饮料）。因此抽象类是用类被具体类继承的。 抽象类和接口一样可用于向上转型，把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。 抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果在子类中删掉了这些方法中的某一个，将不能通过编译器的检查。 11.3.2 抽象方法和具体方法抽象方法被声明在抽象类中，并没有具体的实现过程，是一些“哑”方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。 除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫具体方法。当代码需要改变时，只需改动抽象类里的具体方法就可以了。 11.3.4 JavaScript 没有抽象类的缺点和解决方案JavaScript 并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于 JavaScript 是一门“类型模糊”的语言，所以此作用并不重要。 另一方面，当我们在 JavaScript 中使用原型继承来模拟传统的类式继承时，并没有编译器进行检查，也无法保证子类会重写父类中的“抽象方法”。 两种变通的解决方案： 用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，会在业务代码中添加一些与业务无关的代码。 让抽象类的方法直接抛出一个异常，如果没有在子类中编写相关方法则会在程序运行时得到一个错误。 第二种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息时间点太靠后。 一共有 3 次机会得到这个错误信息，第 1 次是在编写代码的时候，通过编译器的检查来得到错误信息；第 2 次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不使用最后一次机会，在程序运行过程中才知道哪里发生了错误。 11.4 模版方法模式的使用场景比如构建一系列的 UI 组件，过程一般如下： 初始化一个 div 容器； 通过 ajax 请求拉取相应的数据； 把数据渲染到 div 容器里面，完成组件的构造； 通知用户组建渲染完毕。 其中第 1 步和第 4 步是相同的。第 2 步不同的地方是请求 ajax 的远程地址，第 3 步不同的地方是渲染数据的方式。 于是可以把这 4 个步骤都抽象到父类的模版方法里面，父类中还可以顺便提供第 1 步和第 4 步的具体实现。当子类继承这个父类之后，会重写模版方法里面的第 2 步和第 3 步。 11.5 钩子方法模版方法模式在父类中封装了子类的算法框架，在正常状态下适用于大多数子类，如果有一些子类是特殊的？比如有一些客人是不加调料的。 钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现。钩子方法的返回结果决定了模版方法后面部分的执行步骤。 1234567891011121314151617181920212223242526272829var Bevarage = function () &#123;&#125;;// ...Beverage.prototype.customerWantsCondiments = function () &#123; return true; // 默认需要调料&#125;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) &#123; // 如果挂钩返回 true，则需要调料 this.addCondiments(); &#125;&#125;var CoffeeWithHook = function () &#123;&#125;;CoffeeWithHook.prototype = new Beverage();// ...CoffeeWithHook.prototype.customerWantsCondiments = function () &#123; return window.confirm(&#x27;请问需要调料吗？&#x27;);&#125;;var coffeeWithHook = new CoffeeWithHook();coffeeWithHook.init(); 11.6 好莱坞原则在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件决定什么时候、以何种方式去使用这些底层组件。 模版方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模版方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，改为父类通知子类，哪些方法应该在什么时候被调用。子类只负责提供设计上的细节。 好莱坞原则还常用于其他模式和场景，如发布-订阅模式和回调函数。 发布-订阅模式 在发布订阅-订阅模式中，发布者会吧消息推送给订阅者，取代了原先不断去 fetch 消息的形式。 回调函数 把需要执行的操作封装在回调函数里， 然后把主动权交给另外一个函数。 11.7 真的需要“继承”吗模版方法是基于继承的设计模式，但 JavaScript 实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。 在好莱坞原则的指导下，可以这样写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var Beverage = function (param) &#123; var boilWater = function () &#123; console.log(&#x27;把水煮沸&#x27;) &#125; var brew = param.brew || function () &#123; throw new Error(&#x27;必须传递 brew 方法&#x27;) &#125; var pourInCup = param.pourInCup || function () &#123; throw new Error(&#x27;必须传递 pourInCup 方法&#x27;) &#125; var addCondiments = param.addCondiments || function () &#123; throw new Error(&#x27;必须传递 pourInCup 方法&#x27;) &#125; var F = function () &#123;&#125; F.prototype.init = function () &#123; boilWater() brew() pourInCup() addCondiments() &#125; return F&#125;var Coffee = Beverage(&#123; brew: function () &#123; console.log(&#x27;用沸水冲泡咖啡&#x27;) &#125;, pourInCup: function () &#123; console.log(&#x27;把咖啡倒进杯子&#x27;) &#125;, addCondiments: function () &#123; console.log(&#x27;加糖和牛奶&#x27;) &#125;&#125;)var Tea = Beverage(&#123; brew: function () &#123; console.log(&#x27;用沸水浸泡茶叶&#x27;) &#125;, pourInCup: function () &#123; console.log(&#x27;把茶倒进杯子&#x27;) &#125;, addCondiments: function () &#123; console.log(&#x27;加柠檬&#x27;) &#125;&#125;)var coffee = new Coffee()coffee.init()var tea = new Tea()tea.init() 11.8 小结在传统的面向对象语言中，运用了模版方法模式的程序中，子类的方法种类和执行顺序是不变的，所以把这部分逻辑抽象到父类的模版方法中，子类的方法具体实现是可变的。通过增加新的子类，就能给系统增加新的功能，不需要改动父类和其他子类，符合开放-封闭原则。 在 JavaScript 中，高阶函数是更好的选择。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 10","path":"/2017/02/27/js-design-patterns-10/","content":"第十章 组合模式 组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。 10.1 回顾宏命令在第九章命令模式中，宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个 execute 方法负责执行命令。 宏命令中包含了一组子命令，它们组成了一个树形结构，macroCommand 被称为组合对象，closeDoorCommand 等都是叶对象。在 macroCommand 的 execute 方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的 execute 请求委托给这些叶对象。 macroCommand 表现得像一个命令，但实际上只是一组真正命令的“代理”。并非真正的代理，虽然结构上相似，但 macroCommand 只负责传递请求给叶对象，目的不在于控制对叶对象的访问。 10.2 组合模式的用途组合模式将对象组合成树形结构，以表示“部分-整体“的层次结构。通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。 当宏命令和普通子命令接收到执行 execute 方法的请求时，宏命令和普通子命令都会做它们认为正确的事情。这些差异是隐藏在背后的，这种透明性让我们非常自由地扩展程序。 10.3 请求在树中传递的过程请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象，组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 作为客户，只需关心树最顶层的组合对象，只要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。 10.4 更强大的宏命令1234567891011121314151617181920212223242526272829303132333435363738394041var MacroCommand = function () &#123; return &#123; commandList: [], add: function (command) &#123; this.commandList.push(command); &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandList[i++];) &#123; command.execute(); &#125; &#125; &#125;&#125;;var aCommand = &#123; execute: function () &#123; console.log(&#x27;a&#x27;); &#125;&#125;;// ...var macroCommand1 = MacroCommand();macroCommand1.add(aCommand);macroCommand1.add(bCommand);var macroCommand2 = MacroCommand();macroCommand2.add(cCommand);macroCommand2.add(dCommand);macroCommand2.add(eCommand);var macroCommand = MacroCommand();macroCommand.add(fCommand);macroCommand.add(macroCommand1);macroCommand.add(macroCommand2);var setCommand = (function (command) &#123; document.getElementById(&#x27;button&#x27;).onclick = function () &#123; command.execute(); &#125;&#125;)(macroCommand); 基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整棵树运行的步骤，只是调用最上层对象的 execute 方法。每当对最上层对象进行一次请求时，实际上是在对整棵树进行深度优化的搜索，而创建组合对象的程序员并不关心这些内在的细节，往树里面添加新的节点对象是非常容易的。 10.5 抽象类在组合模式中的作用组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要是命令，并且有 execute 方法，就可以被添加到树中。 这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在 Java 中，实现组合模式的关键是 Composite 类和 Leaf 类都必须继承在一个 Composite 抽象类。这个 Composite 抽象类既代表组合对象，又代表叶对象，能保证组合对象和叶对象拥有同样名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在 Component 抽象类身后。 针对 Component 抽象类来编写程序，客户操作的始终是 Component 对象，而不用去区分到底是组合对象还是叶对象。 然而在 JavaScript 这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个“怪异”的抽象类，JavaScript 中实现组合模式的难点在于要保证组合对象和叶对象拥有同样的方法，这通常需要鸭子类型的思想对它们进行接口检查。 在 JavaScript 中实现组合模式，看起来缺乏一些严谨性，代码算不上安全，但能更快速和自由地开发，这既是 JavaScript 的缺点，也是它的优点。 10.6 透明性带来的安全问题组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们本质上是有区别的。 组合对象可以拥有子节点，叶对象下面没有子节点，所以有可能会发生误操作，比如试图往叶对象中添加子节点。解决方案通常是给叶对象也增加 add 方法，并且在调用这个方法时，抛出一个异常来及时提醒客户： 123456789101112// ...var openTvCommand = &#123; execute: function () &#123; console.log(&#x27;打开电视&#x27;); &#125;, add: function () &#123; throw new Error(&#x27;叶对象不能添加子节点&#x27;); &#125;&#125;;// ... 10.7 组合模式的例子——扫描文件夹123456789101112131415161718192021222324252627var Folder = function (name) &#123; this.name = name; this.files = [];&#125;;Folder.prototype.add = function (file) &#123; this.files.push(file);&#125;;Folder.prototype.scan = function () &#123; console.log(&#x27;开始扫描文件夹：&#x27; + this.name); for (var i = 0, file, files = this.files; file = files[i++]) &#123; file.scan(); &#125;&#125;;var File = function (name) &#123; this.name = name;&#125;;File.prototype.add = function () &#123; throw new Error(&#x27;文件下面不能再添加文件&#x27;);&#125;;File.prototype.scan = function () &#123; console.log(&#x27;开始扫描文件：&#x27; + this.name);&#125;; 接下来创建一些文件夹和文件对象，并且组合成一棵树： 1234567891011121314var folder = new Folder(&#x27;学习资料&#x27;);var folder1 = new Folder(&#x27;JavaScript&#x27;);var folder2 = new Folder(&#x27;jQuery&#x27;);var file1 = new File(&#x27;JavaScript 设计模式与开发实践&#x27;);var file2 = new File(&#x27;精通 jQuery&#x27;);var file3 = new File(&#x27;重构与模式&#x27;);folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3); 我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放-封闭原则的。 运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，只需要操作树的最顶端对象： 1folder.scan(); 10.8 注意1. 组合模式不是父子关系组合模式是一种 HAS-A（聚合）的关系，而不是 IS-A。组合对象包含一组叶对象，但 Leaf 并不是 Composite 的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。 2. 对叶对象操作的一致性比如给全体员工发过节费，这个场景可以用组合模式，但如果公司给当天生日员工发祝福邮件，就不能用组合模式。 3. 双向映射关系给全体员工发过节费的通知步骤是从公司到部门到小组到个人，本身是组合模式的好例子。但有种情况是，也许某些员工属于多个组织架构，可能重复收过节费。 这种复合情况下必须给父节点和子节点建立双向映射关系，一个方法是给小组和员工对象都增加集合来保存对方的引用。但是这种互间的引用相当复杂，而且对象之间产生过多的耦合性，修改或删除一个对象都变得困难，此时可以引入中介者模式来管理这些对象。 4. 用职责链模式提高组合模式性能在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候可以借助一些技巧，在实际操作中避免遍历整棵树，比如借助职责链模式。职责链模式一般需要手动设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者反过来从子对象往父对象传递，知道遇到可以处理该请求的对象为止。 10.9 引用父对象有时候需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。 1234567891011121314151617181920212223242526272829var Folder = function (name) &#123; this.name = name; this.parent = null; this.files = [];&#125;;Folder.prototype.add = function (file) &#123; file.parent = this; this.files.push(file);&#125;;Folder.prototype.scan = function () &#123; console.log(&#x27;开始扫描文件夹：&#x27; + this.name); for (var i = 0, file, files = this.files; file = files[i++];) &#123; file.scan(); &#125;&#125;;Folder.prototype.remove = function () &#123; if (!this.parent) &#123; return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[i]; if (file === this) &#123; files.splice(l, 1); &#125; &#125;&#125;; 在 File.prototype.remove 方法里，首先会判断 this.parent，如果为 null，那么这个文件夹是根节点或者游离节点，则让 remove 方法直接 return，表示不做任何操作。 如果该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。 File 类的实现基本一致： 123456789101112// ...File.prototype.remove = function () &#123; if (!this.parent) &#123; return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[l]; if (file === this) &#123; files.splice(l, 1); &#125; &#125;&#125;; 10.10 何时使用组合模式 表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是在开发期间不确定这棵树存在多少层次时。树的构造最终完成后，只需请求树的最顶层对象，便能对整棵树做统一操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。 客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情。 10.11 小结组合模式可以让我们使用树形方式创建对象的结构。可以用一致的方式来处理组合组合对象和单个对象。 但可能会产生这样一个系统：系统中的每个对象看起来都差不多，只有在运行的时候才显现区别，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，可能让系统负担不起。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 9","path":"/2017/02/24/js-design-patterns-9/","content":"第九章 命令模式 9.1 命令模式的用途命令模式最常见的应用场景：需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道请求的操作是什么。希望用一种松耦合的方式来设计程序，使得请求发送者和接收者能够消除彼此之间的耦合关系。 相对于过程化的请求调用，command 对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在 command 对象的方法中，成为了这个对象的行为，可以在程序运行的任意时刻调用这个方法。 命令模式还支持撤销、排队等操作。 9.2 菜单程序setCommand 函数负责往按钮上安装命令，可以肯定的是，点击按钮会执行某个 command 命令，执行命令的动作被约定为调用 command 对象的 execute() 方法。 负责绘制按钮的程序员： 12345var setCommand = function (button, command) &#123; button.click = function () &#123; command.execute(); &#125;&#125;; 负责编写点击按钮之后具体行为的程序员： 1234567891011121314var MenuBar = &#123; refresh: function () &#123; console.log(&#x27;刷新菜单目录&#x27;); &#125;&#125;;var SubMenu = &#123; add: function () &#123; console.log(&#x27;增加子菜单&#x27;); &#125;, del: function () &#123; console.log(&#x27;删除子菜单&#x27;); &#125;&#125;; 先把这些行为都封装在命令类中： 1234567891011121314151617181920212223var RefreshMenuBarButton = function (receiver) &#123; this.receiver = receiver;&#125;;RefreshMenuBarCommand.prototype.execute = function () &#123; this.receiver.refresh();&#125;;var AddSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;AddSubMenuCommand.prototype.execute = function () &#123; this.receiver.add();&#125;;var DelSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;DelSubMenuCommand.prototype.execute = function () &#123; console.log(&#x27;删除子菜单&#x27;);&#125;; 把命令接收者传入到 command 对象中，并且把 command 对象安装到 button 上面： 1234567var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var delSubMenuCommand = new DelSubMenuCommand(SubMenu);setCommand(button1, refreshMenuBarCommand);setCommand(button2, addSubMenuCommand);setCommand(button3, delSubMenuCommand); 9.3 JavaScript 中的命令模式上节是模拟传统面向对象语言的命令模式实现。命令模式将过程式的请求调用封装在 command 对象的 execute 方法里，通过封装方法调用。 命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。 JavaScript 将函数作为一等对象，命令模式已融入到语言之中。运算块不一定要封装在 command.execute 方法中，也可以封装在普通函数中。即使我们依然需要请求“接收者”，也未必适用面向对象的方式，闭包可以完成。 面向对象设计中，命令模式的接收者被当成 command 对象的属性保存起来，同时约定执行命令的操作调用 command.execute 方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。 闭包实现的命令模式： 123456789101112131415161718192021var setCommand = function (button, func) &#123; button.onclick = function () &#123; func(); &#125;&#125;;var MenuBar = &#123; refresh: function () &#123; console.log(&#x27;刷新菜单界面&#x27;); &#125;&#125;;var RefreshMenuBarCommand = function (receiver) &#123; return function () &#123; receiver.refresh(); &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(button1, refreshMenuBarCommand); 如果想更明确地表达当前正在使用命令模式，活着除了执行命令之外，将来有可能要提供撤销命令等操作，最好还是把执行函数改为调用 execute 方法： 12345678910var RefreshMenuBarCommand = function (receiver) &#123; return &#123; execute: function () &#123; receiver.refresh(); &#125; &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(button1, refreshMenuBarCommand); 9.4 撤销命令给 5.4 节中小球动画添加撤销动作，点击后小球回到上一次的位置。 先把代码改为命令模式： 1234567891011121314151617181920var ball = document.getElementById(&#x27;ball&#x27;);var pos = document.getElementById(&#x27;pos&#x27;);var moveBtn = document.getElementById(&#x27;moveBtn&#x27;);var MoveCommand = function (receiver, pos) &#123; this.receiver = receiver; this.pos = pos;&#125;;MoveCommand.prototype.execute = function () &#123; this.receiver.start(&#x27;left&#x27;, this.pos, 1000, &#x27;strongEaseOut&#x27;);&#125;;var moveCommand;moveBtn.onclick = function () &#123; var animate = new Animate(ball); moveCommand = new MoveCommand(animate, pos.value); moveCommand.execute();&#125;; 撤销操作的实现一般是给命令对象增加一个名为 unexecute 或者 undo 的方法来执行 execute 的反向操作。在 command.execute 方法让小球开始运动之前，需要先记录小球的当前位置，在 unexecute 或者 undo 操作中，再让小球回到刚刚记录下的位置。 1234567891011121314151617181920212223242526272829303132var ball = document.getElementById(&#x27;ball&#x27;);var pos = document.getElementById(&#x27;pos&#x27;);var moveBtn = document.getElementById(&#x27;moveBtn&#x27;);var cancelBtn = document.getElementById(&#x27;cancelBtn&#x27;);var MoveCommand = function (receiver, pos) &#123; this.receiver = receiver; this.pos = pos; this.oldPos = null;&#125;;MoveCommand.prototype.execute = function () &#123; this.receiver.start(&#x27;left&#x27;, this.pos, 1000, &#x27;strongEaseOut&#x27;); this.oldPos = this.receiver.dom.getBoundingClientRect()[this.receiver.propertyName]; // 记录小球开始移动前的位置&#125;;MoveCommand.prototype.undo = function () &#123; this.receiver.start(&#x27;left&#x27;, this.oldPos, 1000, &#x27;strongEaseOut&#x27;); // 回到小球移动前记录的位置&#125;;var moveCommand;moveBtn.onclick = function () &#123; var animate = new Animate(ball); moveCommand = new MoveCommand(animate, pos.value); moveCommand.execute();&#125;;cancelBtn.onclick = function () &#123; moveCommand.undo(); // 撤销命令&#125; 9.5 撤销和重做上一节是撤销一个命令，如果需要撤销一系列的命令，在这之前，可以把所有执行过的命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的 undo 操作。 但是在某些情况下无法顺利利用 undo 操作让对象回到 execute 之前的状态。比如在 Canvas 中，很难为命令对象定义一个擦除某条线的 undo 操作，因为在 Canvas 画图中，擦除一条线相对不容易实现。 这时最好的方法是清除画布，然后把刚才执行的命令全部重新执行一遍，这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好办法。 如 HTML5 版游戏中，命令模式可用来实现播放录像功能。原理同上，把用户的输入封装成指令，执行过的命令存放在堆栈中，播放录像时只需要从头开始依次执行这些命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Ryu = &#123; attack: function () &#123; console.log(&#x27;攻击&#x27;); &#125;, defense: function () &#123; console.log(&#x27;防御&#x27;); &#125;, jump: function () &#123; console.log(&#x27;跳跃&#x27;); &#125;, crouch: function () &#123; console.log(&#x27;蹲下&#x27;); &#125;&#125;;var makeCommand = function (receiver, state) &#123; return function () &#123; receiver[state](); &#125;&#125;;var commands = &#123; &#x27;119&#x27;: &#x27;jump&#x27;, &#x27;115&#x27;: &#x27;crouch&#x27;, &#x27;97&#x27;: &#x27;defense&#x27;, &#x27;100&#x27;: &#x27;attack&#x27;&#125;;var commandStack = [];document.onkeypress = function (ev) &#123; var keyCode = ev.keyCode, command = makeCommand(Ryu, commands[keyCode]); if (command) &#123; command(); // 执行命令 commandStack.push(command); // 将刚刚执行过的命令保存进堆栈 &#125;&#125;;document.getElementById(&#x27;replay&#x27;).onclick = function () &#123; var command; while (command = commandStack.shift()) &#123; // 从堆栈里依次取出命令并执行 command(); &#125;&#125;; 9.6 命令队列把请求封装成命令对象的优点在这里再次体现，对象的生命周期几乎是永久的，除非主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，command 对象的 execute 方法可以在程序运行的任何时刻执行。 所以可以把运动过程封装成命令对象，压进一个队列堆栈，当动画执行完，也就是当前 command 对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。 比较关注的问题是，一个动画结束后如何通知队列。通常可以使用回调函数来通知队列，还可以使用订阅-发布模式。 9.7 宏命令宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。 宏命令 MacroCommand，其 add 方法表示把子命令添加进宏命令对象，当调用宏命令对象的 execute 方法时，会迭代这一组子命令对象，并依次执行它们的 execute 方法： 12345678910111213141516171819202122232425var closeDoorCommand = &#123; execute: function () &#123; console.log(&#x27;关门&#x27;); &#125;&#125;;var MacroCommand = function () &#123; return &#123; commandList: [], add: function (command) &#123; this.commandList.push(command), &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandList[i++];) &#123; command.execute(); &#125; &#125; &#125;&#125;;var macroCommand = MacroCommand();macroCommand.add(closeDoorCommand);// ...macroCommand.execute(); 还可以为宏命令添加撤销功能，跟 macroCommand.execute 类似，当调用 macroCommand.undo 方法时，宏命令里包含的所有子命令对象要依次执行各自的 undo 操作。 宏命令是命令模式与组合模式的联用产物。 9.8 智能命令与傻瓜命令回看 9.7 节中 closeDoorCommand 中没有包含任何 receiver 的信息，它本身就包揽了执行请求的行为，这跟之前看到的命令对象都包含一个 receiver 是矛盾的。 一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，好处是请求发起者和请求接收者之间尽可能地解耦。 但也可以定义一些直接实现请求的命令对象，这就不需要接收者的存在，这种命令对象也叫智能命令。没有接收者的智能命令，退化到和策略模式非常接近，从代码结构上无法分辨，只有通过意图。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，command 对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 8","path":"/2017/02/20/js-design-patterns-8/","content":"第八章 发布-订阅模式 发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 在 JavaScript 开发中，我们一般用事件模型来替代传统的发布-订阅模式。 8.2 发布-订阅模式的作用发布-订阅模式可以广泛应用于异步编程中，是替代传统回调函数的方案。在异步编程中使用发布-订阅模式，无需过多关注对象在异步运行期间的内部状态，只需订阅感兴趣的事件发生点。 发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由使用它们。 8.3 DOM 事件123document.body.addEventListener(&#x27;click&#x27;, function () &#123; alert(2);&#125;, false); 订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。 8.4 自定义事件 指定谁充当发布者； 给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者； 发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 还可以往回调函数里填入一些参数，订阅者可以接收这些参数。 同时也有必要增加一个标示 key，让订阅者只订阅自己感兴趣的消息。 123456789101112131415161718192021222324252627282930var salesOffices = &#123;&#125;;salesOffices.clientList = [];salesOffices.listen = function (key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn);&#125;;salesOffices.trigger = function () &#123; var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该消息类型的回调函数集合 if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // arguments 是发布消息时附带的参数 &#125;&#125;// 小明订阅 88 平方米房子的消息salesOffices.listen(&#x27;squareMeter88&#x27;, function (price) &#123; console.log(&#x27;价格= &#x27; + price);&#125;);salesOffice.trigger(&#x27;squareMeter88&#x27;, 2000000); // 发布 88 平方米房子的价格 8.5 发布-订阅模式的通用实现现在把发布-订阅的功能提取出来，放在一个单独的对象内： 123456789101112131415161718192021var event = &#123; clientList: [], listen: function (key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进缓存列表 &#125;, trigger: function () &#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;&#125;; 再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布-订阅功能： 12345var installEvent = function (obj) &#123; for (var i in event) &#123; obj[i] = event[i]; &#125;&#125;; 给某个对象增加发布-订阅功能： 1234var obj = &#123;&#125;;installEvent(obj);// ... 8.6 取消订阅的事件123456789101112131415161718event.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); // 删除订阅者的回调函数 &#125; &#125; &#125;&#125;; 8.7 网站登陆假设页面各个模块的渲染都有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。 异步的问题通常可以用回调函数来解决。 但此处用发布-订阅模式的原因是，我们不知道除了现有的模块，将来还有哪些模块需要使用这些用户信息。如果它们和信息模块产生了强耦合，比如这样： 123456login.succ(function () &#123; header.setAvatar(data.avatar); // 设置 header 模块的头像 nav.setAvatar(data.avatar); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表&#125;); 编写者必须了解 header 模块里设置头像的方法叫 setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身也不能改名。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。 用发布-订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而不需要关心业务方要做什么，也不需要了解它们的内部细节。 1234$.ajax(&#x27;http://xxx.com?login&#x27;, function (data) &#123; // 登录成功 login.trigger(&#x27;loginSucc&#x27;, data); // 发布登录成功的消息&#125;) 各模块监听登录成功的消息： 12345678910var header = (function () &#123; login.listen(&#x27;loginSucc&#x27;, function (data) &#123; header.setAvatar(data.avatar); &#125;); return &#123; setAvatar: function (data) &#123; console.log(&#x27;设置 header 模块的头像&#x27;); &#125; &#125;&#125;)(); 我们随时可以把 setAvatar 的方法改名。如果在登录完成后增加一个刷新收货地址列表的行为，只要在收货地址模块里加上监听消息的方法即可。 8.8 全局的发布-订阅对象两个小问题： 给每一个发布者都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList，资源浪费。 订阅者与发布者仍有一定的耦合性，订阅者至少要知道发布者的名字，才能订阅到事件。 发布-订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不需要知道消息推送给哪些订阅者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var Event = (function () &#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function (key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments), fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)(); 8.9 模块间通信上一节的发布-订阅模式的实现，是基于一个全局的 Event 对象，利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。 但是，模块之间如果用了太多的全局发布-订阅模式来通信，那么模块与模块之间的联系就会被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块。 8.10 必须先订阅再发布吗之前实现的订阅-发布模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。 某些情况下，需要先将消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。 建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包裹函数将被存入堆栈，等到有对象来订阅此事件的时候，我们将遍历堆栈并依次执行这些包裹函数。 8.11 全局事件的命名冲突全局的发布-订阅对象里只有一个 clientList 来存放消息名和回调函数，会出现命名冲突的情况，因此可以给 Event 对象提供创建命名空间的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133var Event = (function () &#123; var global = this, Event, _default = &#x27;default&#x27;; Event = function () &#123; var _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function (ary, fn) &#123; var ret; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; var n = ary[i]; ret = fn.call(n, i, n); &#125; return ret; &#125;; _listen = function (key, fn, cache) &#123; if (!cache[key]) &#123; cache[key] = []; &#125; cache[key].push(fn); &#125;; _remove = function (key, cache, fn) &#123; if (cache[key]) &#123; if (fn) &#123; for (var i = cache[key].length; i &gt;= 0; i--) &#123; if (cache[key] === fn) &#123; cache[key].splice(i, 1); &#125; &#125; &#125; else &#123; cache[key] = []; &#125; &#125; &#125;; _trigger = function () &#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, ret, stack = cache[key]; if (!stack || !stack.length) &#123; return; &#125; return each(stack, function () &#123; return this.apply(_self, args); &#125;); &#125;; _create = function (namespace) &#123; var namespace = namespace || _default; var cache = &#123;&#125;, offlineStack = [], // 离线事件 ret = &#123; listen: function (key, fn, last) &#123; _listen(key, fn, cache); if (offlineStack === null) &#123; return; &#125; if (last === &#x27;last&#x27;) &#123; offlineStack.length &amp;&amp; offlineStack.pop()(); &#125; else &#123; each(offlineStack, function () &#123; this(); &#125;); &#125; offlineStack = null; &#125;, one: function (key, fn, last) &#123; _remove(key, cache); this.listen(key, fn, last); &#125;, remove: function (key, fn) &#123; _remove(key, cache, fn); &#125;, trigger: function () &#123; var fn, args, _self = this; _unshift.call(arguments, cache); args = arguments; fn = function () &#123; return _trigger.apply(_self, args); &#125;; if (offlineStack) &#123; return offlineStack.push(fn); &#125; return fn(); &#125; &#125;; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret; &#125;; return &#123; create: _create, one: function (key, fn, last) &#123; var event = this.create(); event.one(key, fn, last); &#125;, remove: function (key, fn) &#123; var event = this.create(); event.remove(key, fn); &#125;, listen: function (key, fn, last) &#123; var event = this.create(); event.listen(key, fn, last); &#125;, trigger: function () &#123; var event = this.create(); event.trigger.apply(this, arguments); &#125; &#125;; &#125;(); return Event;&#125;)(); 客户调用： 123456789101112131415161718// 先发布后订阅Event.trigger(&#x27;click&#x27;, 1);Event.listen(&#x27;click&#x27;, function (a) &#123; console.log(a); // 输出：1&#125;);// 使用命名空间Event.create(&#x27;namespace1&#x27;).listen(&#x27;click&#x27;, function (a) &#123; console.log(a); // 输出：1&#125;);Event.create(&#x27;namespace1&#x27;).trigger(&#x27;click&#x27;, 1);Event.create(&#x27;namespace2&#x27;).listen(&#x27;click&#x27;, function (a) &#123; console.log(a); // 输出：2&#125;);Event.create(&#x27;namespace2&#x27;).trigger(&#x27;click&#x27;, 2); 8.12 JavaScript 实现发布-订阅模式的便利性在 Java 中实现一个自己的订阅-发布模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如 update 的方法，供发布者在适合的时候调用。在 JavaScript 中，用注册回调函数的形式来代替传统的发布-订阅模式，更加优雅和简单。 在 JavaScript 中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有变更的状态和数据都推送给订阅者。拉模型中，发布者仅仅通知订阅者事件已经发生，此外发布者要提供一些公开的接口供订阅者主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时会增加代码量和复杂度。 在 JavaScript 中，arguments 可以很方便地表示参数列表，所以一般会选择推模型，使用 Function.prototype.apply 方法把所有参数推送给订阅者。 8.13 小结优点：一为时间上的解耦，二为对象之间的解耦。既可以用在异步编程中，也可以帮助完成更松耦合的代码编写，还可以用来实现一些别的设计模式，比如中介者模式。架构上看，MV* 少不了发布-订阅模式，JavaScript 本身也是一门基于事件驱动的语言。 缺点：创建订阅者本身消耗一定的时间和内存，当订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布-订阅模式虽可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也会被深埋在背后，导致程序难以跟踪维护和理解，特别是有多个发布者和订阅者嵌套到一起的时候。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 7","path":"/2017/02/17/js-design-patterns-7/","content":"第七章 迭代器模式 迭代器模式指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 7.1 jQuery 中的迭代器1234$.each([1, 2, 3], function (i, n) &#123; console.log(&#x27;当前下标为：&#x27; + i); console.log(&#x27;当前值为：&#x27; + n);&#125;); 7.2 实现自己的迭代器123456789var each = function (ary, callback) &#123; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; callback.call(ary[i], i, ary[i]); // 把下标和元素当作参数传给 callback 函数 &#125;&#125;;each([1, 2, 3], function (i, n) &#123; alert([i, n]);&#125;); 7.3 内部迭代器和外部迭代器1. 内部迭代器上节的 each 函数属于内部迭代器，each 函数的内部已经定义好了迭代规则，完全接手整个迭代过程，外部只需要一次初始调用。内部迭代器调用非常方便，外界不用关心迭代器内部实现，跟迭代器的交互也仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的 each 函数就无法同时迭代 2 个数组了。 1234567891011121314// 比较两个数组是否相等var compare = function (ary1, ary2) &#123; if (ary1.length !== ary2.length) &#123; throw new Error(&#x27;ary1 和 ary2 不相等&#x27;); &#125; each(ary1, function (i, n) &#123; if (n !== ary2[i]) &#123; throw new Error(&#x27;ary1 和 ary2 不相等&#x27;); &#125; &#125;); alert(&#x27;ary1 和 ary2 相等&#x27;);&#125;;compare([1, 2, 3], [1, 2, 4]); // throw new Error(&#x27;ary1 和 ary2 不相等&#x27;); 这个函数不好看，能顺利完成需求，得益于 JavaScript 里可以把函数当作参数传递的特性。在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如 C 语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外部传递进去。 2. 外部迭代器外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，可以手工控制迭代的过程或顺序。 1234567891011121314151617181920212223242526272829303132333435363738var Iterator = function (obj) &#123; var current = 0; var next = function () &#123; current += 1; &#125;; var isDone = function () &#123; return current &gt;= obj.length; &#125;; var getCurrItem = function () &#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrItem: getCurrItem &#125;&#125;;var compare = function (iterator1, iterator2) &#123; while (!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123; if (iterator1.getCurrItem() !== iterator2.getCurrItem()) &#123; throw new Error(&#x27;iterator1 和 iterator2 不相等&#x27;); &#125; iterator1.next(); iterator2.next(); &#125; alert(&#x27;iterator1 和 iterator2 相等&#x27;);&#125;var iterator1 = Iterator([1, 2, 3]);var iterator2 = Iterator([1, 2, 3]);compare(iterator1, iterator2); // 输出：iterator1 和 iterator2 相等 外部迭代器虽然调用方式相对复杂，但适用面更广，也能满足更多变的需求。 两种迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。 7.4 迭代类数组对象和字面量对象只要被迭代的聚合对象拥有 length 属性而且可以用下标访问，就可以被迭代。 在 JavaScript 中，for in 语句可以用来迭代普通字面量对象的属性。jQuery 中提供了 $.each 函数来封装各种迭代行为： 12345678910111213141516171819202122232425$.each = function (obj, callback) &#123; var value, i = 0, length = obj.length, isArray = isArraylike(obj); if (isArray) &#123; // 迭代类数组 for (; i &lt; length; i++) &#123; value = callback.call(obj[i], i, obj[i]); if (value === false) &#123; break; &#125; &#125; &#125; else &#123; for (i in obj) &#123; // 迭代 object 对象 value = callback.call(obj[i], i, obj[i]); if (value === false) &#123; break; &#125; &#125; &#125; return obj;&#125;; 7.5 倒序迭代器GoF 中对迭代器模式的定义非常松散，因此可以有多种迭代器的实现。 如倒序迭代器： 123456789var reverseEach = function (ary, callback) &#123; for (var l = ary.length - 1; l &gt;= 0; l--) &#123; callback(l, ary[l]); &#125;&#125;;reverseEach([0, 1, 2], function (i, n) &#123; console.log(n); // 分别输出：2，1，0&#125;); 7.6 中止迭代器迭代器可以像普通 for 循环中的 break 一样，提供一种跳出循环的方法。 1234567891011121314var each = function (ary, callback) &#123; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; if (callback(i, ary[i]) === false) &#123; // callback 的执行结果返回 false，提前终止迭代 break; &#125; &#125;&#125;;each([1, 2, 3, 4], function (i, n) &#123; if (n &gt; 3) &#123; // n 大于 3 的时候终止循环 return false; &#125; console.log(n); // 分别输出：1，2，3&#125;); 7.7 迭代器模式的应用举例假设需求：根据不同的浏览器获取相应的上传组件对象： 1234567891011121314// 旧代码var getUploadObj = function () &#123; try &#123; return new ActiveXObject(&#x27;TXFTNActiveX.FTNUpload&#x27;); // IE 上传控件 &#125; catch (e) &#123; if (supportFlash()) &#123; // supportFlash 函数未提供 var str = &#x27;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&#x27;; return $(str).appendTo($(&#x27;body&#x27;)); &#125; else &#123; var str = &#x27;&lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&#x27;; // 表单上传 return $(str).appendTo($(&#x27;body&#x27;)); &#125; &#125;&#125;; 以上代码为了得到一个 upload 对象，函数里充斥着 try，catch 以及 if 条件分支。缺点第一难以阅读，第二严重违反封闭-开放原则。在开发和调试过程中，需要来回切换不同的上传方式，每次改动都很痛苦。如果要增加支持另外的上传方式，唯一的方法是继续往函数里增加条件分支。 重构代码，把每种获取 upload 对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些 upload 对象，知道获取到一个可用的为止： 1234567891011121314151617181920var getActiveUploadObj = function () &#123; try &#123; return new ActiveXObject(&#x27;TXFTNActiveX.FTNUpload&#x27;); &#125; catch (e) &#123; return false; &#125;&#125;var getFlashUploadObj = function () &#123; if (supportFlash()) &#123; var str = &#x27;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&#x27;; return $(str).appendTo($(&#x27;body&#x27;)); &#125; return false;&#125;var getFormUploadObj = function () &#123; var str = &#x27;&lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&#x27;; return $(str).appendTo($(&#x27;body&#x27;));&#125;; 以上三个函数都有同一个约定：如果该函数里面的 upload 对象是可用的，则让函数返回该对象，反之返回 false，提示迭代器继续往后面进行迭代。 迭代器的工作： 提供一个可以被迭代的方法，使得 getActiveUploadObj、getFlashUploadObj 以及 getFormUploadObj 依照优先级被循环迭代。 如果正在被迭代的函数返回一个对象，则表示找到了正确的 upload 对象，反之如果该函数返回 false，则让迭代器继续工作。 12345678910var iteratorUploadObj = function () &#123; for (var i = 0, fn; fn = arguments[i++];) &#123; var uploadObj = fn(); if (uploadObj !== false) &#123; return uploadObj; &#125; &#125;&#125;;var uploadObj = iteratorUploadObj(getActiveUploadObj, getFlashUploadObj, getFormUploadObj); 重构代码后，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try、catch 和 if 分支不再纠缠在一起，使得我们可以很方便地维护和扩展代码。比如后来再增加 Webkit 控件上传和 HTML5 上传，只需： 123456789var getWebkitUploadObj = function () &#123; // 具体代码略&#125;var getHtml5UploadObj = function () &#123; // 具体代码略&#125;var uploadObj = iteratorUploadObj(getActiveUploadObj, getWebkitUploadObj, getFlashUploadObj, getHtml5UploadObj, getFormUploadObj);"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 6","path":"/2017/02/13/js-design-patterns-6/","content":"第六章 代理模式 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。 6.2 保护代理和虚拟代理代理可以帮助本体过滤掉一些请求，这种代理叫做保护代理。把一些开销很大的对象，延迟到真正需要它的时候才去创建，这种代理叫做虚拟代理。 保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式。 6.3 虚拟代理实现图片预加载场景：先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里。 首先创建一个普通的本体对象，这个对象负责往页面中创建一个 img 标签，并且提供一个对外的 setSrc 接口，外界调用这个接口，便可以给该 img 标签设置 src 属性： 123456789101112var myImage = (function () &#123; var imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)();myImage.setSrc(&#x27;a.jpg&#x27;); 代理对象 proxyImage，在图片被真正加载好之前，页面中将出现一张占位的菊花图 loading.gif 来提示用户图片正在加载。 1234567891011121314var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function (src) &#123; myImage.setSrc(&#x27;loading.gif&#x27;); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc(&#x27;a.jpg&#x27;); 现在我们通过 proxyImage 间接地访问 MyImage。proxyImage 控制了客户对 MyImage 的访问，并且在此过程中加入一些额外的操作，比如在真正的图片加载好之前，先把 img 节点的 src 设置为一张本地的 loading 图片。 6.4 代理的意义不用代理的预加载图片函数： 123456789101112131415161718var MyImage = (function () &#123; var imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); var img = new Image; img.onload = function () &#123; imgNode.src = img.src; &#125;; return &#123; setSrc: function (src) &#123; imgNode.src = &#x27;loading.gif&#x27;; img.src = src; &#125; &#125;&#125;)();MyImage.setSrc(&#x27;a.jpg&#x27;); 单一职责原则：就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。 如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。 上段代码中的 MyImage 对象除了负责给 img 节点设置 src 外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。 另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放-封闭原则。如果只是从网络上获取一些体积很小的图片，或者以后的网速快到根本不需要预加载，可能希望把预加载图片的代码从 MyImage 对象里删除，这时就不得不改动 MyImage 对象了。 纵观整个程序，我们没有改变或者增加 MyImage 的接口，但是通过代理对象，实际上给系统添加了新的行为。这是符合开放-封闭原则的。给 img 节点设置 src 和图片预加载这两个功能，被隔离在两个对象里，它们可以各自变化而不影响对方。如果有一天不需要预加载，只需改成请求本体而不是请求代理对象即可。 6.5 代理和本体接口的一致性如果有一天不需要预加载，就不需要代理对象，直接请求本体。关键是代理对象和本体都对外提供了 setSrc 方法，在客户看来，代理对象和本体是一致的，代理接受请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别。 用户可以放心地请求代理，只关心能否得到想要的结果。 在任何使用本体的地方都可以替换成使用代理。 在 Java 等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口向上转型，从而避开编译器的类型检查，代理和本体将来可以被替换使用。 在 JavaScript 这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了 setSrc 方法，大多数时候干脆不做检测，全部依赖程序猿的自觉性，这对于程序的健壮性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内。 如果代理对象和本体对象都为一个函数（函数也是对象），函数必然都能被执行，则可以认为它们也具有一致的“接口”： 12345678910111213141516171819202122var myImage = (function () &#123; var imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); return function (src) &#123; imgNode.src = src; &#125;&#125;)();var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage(this.src); &#125; return function (src) &#123; myImage(&#x27;loading.gif&#x27;); img.src = src; &#125;&#125;)();proxyImage(&#x27;a.jpg&#x27;); 6.6 虚拟代理合并 HTTP 请求在 Web 开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同步到另外一台备用服务器上面。给这些 checkbox 绑定点击事件，并在点击的同时往另一台服务器同步文件： 123456789101112var synchronousFile = function (id) &#123; console.log(&#x27;开始同步文件，id 为：&#x27; + id);&#125;;var checkbox = document.getElementsByTagName(&#x27;input&#x27;);for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function () &#123; if (this.checked === true) &#123; synchronousFile(this.id); &#125; &#125;&#125;; 当选中多个 checkbox 的时候，依次往服务器发送了多次同步文件的请求，频繁的网络操作将会带来巨大的开销。 我们可以通过一个代理函数 proxySynchronousFile 来收集一段时间之内的请求，最后一次性发送给服务器。如果不是对实时性要求非常高的系统，短时间的延迟不会带来太大的副作用，却能大大减轻服务器的压力。 1234567891011121314151617181920212223242526272829303132var synchronousFile = function (id) &#123; console.log(&#x27;开始同步文件，id 为：&#x27; + id);&#125;;var proxySynchronousFile = (function () &#123; var cache = [], // 保存一段时间内需要同步的 ID timer; // 定时器 return function (id) &#123; cache.push(id); if (timer) &#123; // 保证不会覆盖已经启动的定时器 return; &#125; timer = setTimeout(function () &#123; synchronousFile(cache.join(&#x27;,&#x27;)); // 2 秒后向本体发送需要同步的 ID 集合 clearTimeout(timer); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 &#125;, 2000); &#125;&#125;)();var checkbox = document.getElementsByTagName(&#x27;input&#x27;);for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function () &#123; if (this.checked === true) &#123; proxySynchronousFile(this.id); &#125; &#125;&#125;; 6.7 虚拟代理在惰性加载中的应用假设存在一个仿控制台的组件 miniConsole.js，代码量在 1000 行左右，我们并不想一开始就加载这么大的 JS 文件，因为也许不是每个用户都需要打印 log。我们希望在有必要的时候才开始加载它，比如当用户按下 F2 主动唤出控制台的时候。 在 miniConsole.js 加载之前，为了能够让用户正常使用里面的 API，通常是用一个占位 miniConsole 代理对象来给用户提前使用，这个代理对象提供给用户的接口，跟实际的 miniConsole 是一样的。 用户使用这个代理对象来打印 log 的时候，并不会真正在控制台内打印日志，更不会在页面中创建任何 DOM 节点，真正的 miniConsole.js 还没有被加载。 可以把打印 log 的请求都包裹在一个函数里面，这个包装了请求的函数就相当于其他语言中命令模式中的 Command 对象。随后这些函数将全部被放到缓存队列中，这些逻辑都是在 miniConcole 代理对象中完成实现的。等用户唤出控制台的时候，才开始加载真正的 miniConcole.js 的代码，加载完成之后将遍历 miniConcole 代理对象中的缓存函数队列，同时依次执行它们。 123456789101112var cache = [];var miniConsole = &#123; log: function () &#123; var args = arguments; cache.push(function () &#123; return miniConcole.log.apply(miniConcole, args); &#125;); &#125;&#125;;miniConcole.log(1); 当用户按下 F2 时，开始加载真正的 miniConsole.js： 12345678910111213141516171819202122var handler = function (ev) &#123; if (ev.keyCode == 113) &#123; var script = document.createElement(&#x27;script&#x27;); script.onload = function () &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125; &#125;; script.src = &#x27;miniConsole.js&#x27;; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); &#125;&#125;;document.body.addEventListener(&#x27;keydown&#x27;, handler, false);// miniConsole.js 代码：miniConsole = &#123; log: function () &#123; //真正代码略 console.log(Array.prototype.join.call(arguments)); &#125;&#125;; 这里还要注意一个问题，就是我们要保证在 F2 被重复按下的时候，miniConsole.js 只被加载一次。另外整理一下 minConsole 代理对象的代码，使它成为一个标准的虚拟代理对象： 123456789101112131415161718192021222324252627var miniConcole = (function () &#123; var cache = []; var handler = function (ev) &#123; if (ev.keyCode === 113) &#123; var script = document.createElement(&#x27;script&#x27;); script.onload = function () &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125; &#125;; script.src = &#x27;miniConsole.js&#x27;; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); document.body.removeEventListener(&#x27;keydown&#x27;, handler); // 只加载一次 miniConsole.js &#125; &#125;; document.body.addEventListener(&#x27;keydown&#x27;, handler, false); return &#123; log: function () &#123; var args = arguments; cache.push(function () &#123; return miniConsole.log.apply(miniConsole, args); &#125;); &#125; &#125;&#125;)(); 6.8 缓存代理缓存代理可以为一些开销大的运算结果提供暂时的缓存，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。 6.8.1 计算乘积1234567891011var mult = function () &#123; console.log(&#x27;开始计算乘积&#x27;); var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3); // 输出：6mult(2, 3, 4); // 输出：24 加入缓存代理函数： 12345678910111213var proxyMult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, &#x27;,&#x27;); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = mult.apply(this, arguments); &#125;&#125;)();proxyMult(1, 2, 3, 4); // 输出：24proxyMult(1, 2, 3, 4); // 输出：24 当我们第二次调用 proxyMult(1, 2, 3, 4) 的时候，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果。 6.8.2 缓存代理用于 ajax 异步请求数据实现方式跟计算计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放倒代理对象的缓存中，而是要通过回调的方式。 6.9 用高阶函数动态创建代理通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中。 1234567891011121314151617181920212223var mult = function () &#123; // 乘法 // ...&#125;;var plus = function () &#123; // 加法 // ...&#125;;var createProxyFactory = function (fn) &#123; var cache = []; return function () &#123; var args = Array.prototype.join.call(arguments, &#x27;,&#x27;); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = fn.apply(this, arguments); &#125;&#125;;var proxyMult = createProxyFactory(mult), proxyPlus = createProxyFactory(plus); 6.10 其他代理模式 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。 远程代理：为一个对象在不同的地址空间提供局部代表。 保护代理：用于对象应该有不同访问权限的情况。 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。DLL（操作系统中的动态链接库）是其典型运用场景。 6.11 小结代理模式包括许多小分类，在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式，当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 5","path":"/2017/02/11/js-design-patterns-5/","content":"第五章 策略模式 策略模式的定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 5.1 使用策略模式计算奖金1. 最初的代码实现12345678910111213141516var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === &#x27;S&#x27;) &#123; return salary * 4; &#125; if (performanceLevel === &#x27;A&#x27;) &#123; return salary * 3; &#125; if (performanceLevel === &#x27;B&#x27;) &#123; return salary * 2; &#125;&#125;;calculateBonus(&#x27;B&#x27;, 20000); // 输出：40000calculateBonus(&#x27;S&#x27;, 6000); // 输出：24000 这段代码十分简单，但是缺点显而易见： calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑分支。 calculateBonus 函数缺乏弹性，如果增加新的绩效等级，或者修改奖金系数，必须深入 calculateBonus 函数的内部实现，违反开放-封闭原则。 算法复用性差，如果在程序其他地方需要重用这些算法，只能复制粘贴。 2. 使用组合函数重构代码把各种算法封装到一个个的小函数里面，这些小函数有着良好的命名，可以一目了然知道其对应的算法，也可以复用在程序的其他地方。 12345678910111213141516171819202122232425var performanceS = function (salary) &#123; return salary * 4;&#125;var performanceA = function (salary) &#123; return salary * 3;&#125;var performanceB = function (salary) &#123; return salary * 2;&#125;var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === &#x27;S&#x27;) &#123; return performanceS(salary); &#125; if (performanceLevel === &#x27;A&#x27;) &#123; return performanceA(salary); &#125; if (performanceLevel === &#x27;B&#x27;) &#123; return performanceB(salary); &#125;&#125;; 程序得到了有限的改善，依然没有解决最重要的问题：calculateBonus 函数又可能越来越庞大，而且在系统变化的时候缺乏弹性。 3. 使用策略模式重构代码策略模式的目的是将算法的使用与算法的实现分离开来。 一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，Context 中要维持对某个策略对象的引用。 第一个版本是模仿传统面向对象语言中的实现。 策略类： 1234567891011121314151617var performanceS = function () &#123;&#125;;performanceS.prototype.calculate = function (salary) &#123; return salary * 4;&#125;;var performanceA = function () &#123;&#125;;performanceA.prototype.calculate = function (salary) &#123; return salary * 3;&#125;;var performanceB = function () &#123;&#125;;performanceB.prototype.calculate = function (salary) &#123; return salary * 2;&#125;; 奖金类： 12345678910111213141516var Bonus = function () &#123; this.salary = null; // 原始工资 this.strategy = null; // 绩效等级对应的策略对象&#125;;Bonus.prototype.setSalary = function (salary) &#123; this.salary = salary; // 设置员工的原始工资&#125;;Bonus.prototype.setStrategy = function (strategy) &#123; this.strategy = strategy; // 设置员工绩效等级对应的策略对象&#125;;Bonus.prototype.getBonus = function () &#123; // 取得奖金数额 return this.strategy.calculate(this.salary); // 把计算奖金的操作委托给对应的策略对象&#125;; 使用： 123456789var bonus = new Bonus();bonus.setSalary(10000);bonus.setStrategy(new performanceS()); // 设置策略对象console.log(bonus.getBonus()); // 输出：40000bonus.setStrategy(new performanceA()); // 设置策略对象console.log(bonus.getBonus()); // 输出：30000 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 详细说就是：定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些策略对象中间的某一个进行计算。 “并且使它们可以相互替换”，这句话很大程度上是相对于静态类型语言而言的。因为静态类型语言中有类型检查机制，所以各个策略类需要实现同样的接口。当它们的真正类型被隐藏在接口后面时，它们才能被相互替换。而在 JavaScript 这种“类型模糊”的语言中没有这种困扰，任何对象都可以被替换使用。因此，JavaScript 中的“可以相互替换使用”表现为它们具有相同的目标和功能。 5.2 JavaScript 版本的策略模式上一节的代码中，strategy 是对象从各个策略类中创建而来。在 JavaScript 语言中，函数也是对象，所以更简单和直接的做法是把 strategy 定义为函数。同样，Context 也没有必要用 Bonus 类来表示。 123456789101112131415161718var strategies = &#123; &quot;S&quot;: function (salary) &#123; return salary * 4; &#125;, &quot;A&quot;: function (salary) &#123; return salary * 3; &#125;, &quot;B&quot;: function (salary) &#123; return salary * 2; &#125;&#125;;var calculateBonus = function (level, salary) &#123; return strategies[level](salary);&#125;;console.log(calculateBonus(&#x27;S&#x27;, 20000)); // 输出：80000console.log(calculateBonus(&#x27;A&#x27;, 10000)); // 输出：30000 5.3 多态在策略模式中的体现通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算奖金”的请求时，它们会返回不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 5.4 使用策略模式实现缓动动画5.4.1 实现动画效果的原理动画片是把一些差距不大的原画以较快的帧数播放，来达到视觉上的动画效果。在 JavaScript 中，可以通过连续改变元素的某个 CSS 属性，比如 left、top、background-position 来实现动画效果。 5.4.2 思路和一些准备工作编写一个动画类和一些缓动算法，让小球以各种缓动效果在页面中运动。 在运动开始之前，需要提前记录一些有用的信息，至少包括： 动画开始时，小球所在的原始位置； 小球移动的目标位置； 动画开始时的准确时间点； 小球运动持续的时间。 随后会用 setInterval 创建一个定时器，定时器每隔 19ms 循环一次。在定时器的每一帧里，我们会把动画已消耗的时间、小球原始位置、小球目标位置和动画持续的总时间等信息传入缓动算法。该算法会根据这几个参数，计算出小球当前应该所在的位置。最后更新该 div 对应的 CSS 属性。 5.4.3 让小球运动起来常见运动算法，这些算法接受 4 个参数，分别是动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间，返回的值则是动画元素应该处在的当前位置。 1234567891011121314151617181920var tween = &#123; linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function (t, b, c, d) &#123; return c * ((t = t / d + 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;&#125;; 接下来定义 Animate 类，Animate 的构造函数接受一个参数：即将运动起来的 dom 节点。Animate 类的代码如下： 123456789var Animate = function (dom) &#123; this.dom = dom; // 进行动画的 dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom 节点的位置，即 dom 的初始位置 this.endPos = 0; // 动画结束时，dom 节点的位置，即 dom 的目标位置 this.propertyName = null; // dom 节点需要被改变的 css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间&#125;; Animate.prototype.start 方法负责启动这个动画，动画启动的瞬间要记录一些信息，供缓动算法在以后计算小球当前位置的时候使用。在记录完这些信息后启动定时器： 123456789101112131415Animate.prototype.start = function (propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名 this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续时间 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function () &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;, 19);&#125;; Animate.prototype.start 方法接受 4 个参数： propertyName：要改变的 CSS 属性名，比如 ‘left’、’top’。 endPos：小球运动的目标位置。 duration：动画持续时间。 easing：缓动算法。 Animate.prototype.step 方法代表小球运动的每一帧要做的事。在此处，这个方法负责计算小球的当前位置和调用更新 CSS 属性值的方法 Animate.prototype.update。 123456789Animate.prototype.step = function () &#123; var t = +new Date; // 取得当前时间 if (t &gt;= this.startTime + this.duration) &#123; // (1) this.update(this.endPos); // 更新小球的 CSS 属性值 return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); // 计算小球当前位置 this.update(pos); // 更新小球的 CSS 属性值&#125;; (1) 处的意思是，如果当前时间大于动画开始时间加上动画持续时间之和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让 Animate.prototype.step 方法返回 false，可以通知 Animate.prototype.start 方法清除计时器。 负责更新小球 CSS 属性值的 Animate.prototype.update 方法： 123Animate.prototype.update = function (pos) &#123; this.dom.style[this.propertyName] = pos + &#x27;px&#x27;;&#125;; 测试： 1234var div = document.getElementById(&#x27;div&#x27;);var animate = new Animate(div);animate.start(&#x27;left&#x27;, 500, 1000, &#x27;strongEaseOut&#x27;); 5.5 更广义的“算法”从定义上看，策略模式就是用来封装算法的。在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，就可以用策略模式来封装它们。 5.6 表单校验假设我们正在编写一个注册页面，在点击注册按钮之前，有如下几条校验逻辑： 用户名不能为空 密码长度不能少于 6 位 手机号码必须符合格式 5.6.1 第一个版本没有引入策略模式： 123456789101112131415161718var registerForm = document.getElementById(&#x27;registerForm&#x27;);registerForm.onsubmit = function () &#123; if (registerForm.userName.value === &#x27;&#x27;) &#123; alert(&#x27;用户名不能为空&#x27;); return false; &#125; if (registerForm.password.value.length &lt; 6) &#123; alert(&#x27;密码长度不能少于 6 位&#x27;); return false; &#125; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123; alert(&#x27;手机号码格式不正确&#x27;); return false; &#125;&#125; 缺点： registerForm.onsubmit 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的校验规则。 registerForm.onsubmit 函数缺乏弹性，如果增加或修改校验规则，都必须深入 registerForm.onsubmit 函数的内部实现，违反开放-封闭原则。 算法复用性差。 5.6.2 策略模式重构表单校验将校验逻辑封装成策略对象： 1234567891011121314151617var strategies = &#123; isNonEmpty: function (value, errorMsg) &#123; if (value === &#x27;&#x27;) &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; Validator 类作为 Context，负责接收用户的请求并委托给 strategy 对象。在编写 Validator 类的代码之前，有必要先了解用户是如何向 Validator 类发送请求的，这有助于我们知道如何去编写 Validator 类的代码。 123456789101112131415161718var validateFunc = function () &#123; var validator = new Validator(); // 创建一个 validator 对象 validator.add(registerForm.userName, &#x27;isNonEmpty&#x27;, &#x27;用户名不能为空&#x27;); validator.add(registerForm.password, &#x27;minLength: 6&#x27;, &#x27;密码长度不能少于 6 位&#x27;); validator.add(registerForm.phoneNumber, &#x27;isMobile&#x27;, &#x27;手机号码格式不正确&#x27;); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果&#125;var registerForm = document.getElementById(&#x27;registerForm&#x27;);registerForm.onsubmit = function () &#123; var errorMsg = validateFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if (errorMsg) &#123; alert(errorMsg); return false; // 阻止表单提交 &#125;&#125; 先创建一个 validator 对象，然后通过 validator.add 方法，往 validator 对象中添加一些校验规则。validator.add 方法接受 3 个参数： 1validator.add(registorForm.password, &#x27;minLength:6&#x27;, &#x27;密码长度不能少于6位&#x27;); registerForm.password 为参与校验的 input 输入框。 ‘minLength:6’ 是一个以冒号隔开的字符串。冒号前面的 minLength 代表客户挑选的 strategy 对象，冒号后面的数字 6 表示在校验过程中所必须的一些参数。 第 3 个参数是当校验未通过时返回的错误信息。 当添加完一系列的校验规则之后，会调用 validator.start() 方法来启动校验。如果 validator.start() 返回了一个确切的 errorMsg 字符串当作返回值，说明该次校验没有通过，此时需让 registerForm.onsubmit 方法返回 false 来阻止表单的提交。 12345678910111213141516171819202122var Validator = function () &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function (dom, rule, errorMsg) &#123; var ary = rule.split(&#x27;:&#x27;); // 把 strategy 和参数分开 this.cache.push(function () &#123; // 把校验的步骤用空函数包装起来，并且放入 cache var strategy = ary.shift(); // 用户挑选的 strategy ary.unshift(dom.value); // 把 input 的 value 添加进参数列表 ary.push(errorMsg); // 把 strategy 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 使用策略模式重构代码之后，仅通过“配置”的方式就可以完成一个表单的校验，这些校验规则可以复用在程序的任何地方，还能作为插件的形式，方便地被移植到其他项目中。 在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想将用户名输入框的校验规则改成用户名不能少于 10 个字符： 1234validator.add(registerForm.userName, &#x27;isNonEmpty&#x27;, &#x27;用户名不能为空&#x27;);// 改成：validator.add(registerForm.userName, &#x27;minLength:10&#x27;, &#x27;用户名长度不能少于10位&#x27;); 5.6.3 给某个文本输入框添加多种校验规则1234567891011121314151617181920212223242526272829303132// ...Validator.prototype.add = function (dom, rules) &#123; var self = this; for (var i = 0, rule; rule = rules[i++];) &#123; (function (rule) &#123; var strategyAry = rule.strategy.split(&#x27;:&#x27;); var errorMsg = rule.errorMsg; self.cache.push(function () &#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategies[strategy].apply(dom, strategyAry); &#125;); &#125;)(rule) &#125;&#125;;//...var validateFunc = function () &#123; var validator = new Validator(); validator.add(registerForm.userName, [&#123; strategy: &#x27;isNonEmpty&#x27;, errorMsg: &#x27;用户名不能为空&#x27; &#125;, &#123; strategy: &#x27;minLength:10&#x27;, errorMsg: &#x27;用户名长度不能少于10位&#x27; &#125;]); //...&#125; 5.7 策略模式的优缺点优点： 策略模式利用组合、委托和多态等技术和思想，有效避免多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方。 策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 缺点： 在程序中增加许多策略类或者策略对象，但实际上比把它们负责的逻辑堆砌在 Context 中要好。 使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点。这样才能选择一个合适的 strategy。此时 strategy 要向用户暴露它的所有实现，这是违反最少知识原则的。 5.8 一等函数对象与策略模式在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中，Context 将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样便能表现出对象的多态性。 在函数作为一等对象的语言中，策略模式是隐形的。strategy 就是值为函数的变量。 在 JavaScript 中，除了使用类来封装算法和行为之外，使用函数当然也是一种选择。这些“算法”可以被封装到函数中并且四处传递，也就是我们常说的“高阶函数”。实际上在 JavaScript 这种讲函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。在 JavaScript 中，“函数对象的多态性”来得更加简单。 5.9 小结本章既有接近传统面向对象语言的策略模式实现，也有更适合 JavaScript 语言的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 4","path":"/2017/01/28/js-design-patterns-4/","content":"第四章 单例模式 单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是一种常见的模式，有一些对象我们只需要一个，比如线程池、全局缓存、浏览器中的 window 对象等。 4.1 实现单例模式用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。 12345678910111213141516171819202122var Singleton = function (name) &#123; this.name = name;&#125;;Singleton.prototype.getName = function () &#123; alert(this.name);&#125;;Singleton.getInstance = (function () &#123; var instance = null; return function (name) &#123; if (!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)();var a = Singleton.getInstance(&#x27;sven1&#x27;);var b = Singleton.getInstance(&#x27;sven2&#x27;);alert(a === b); // true 通过 Singleton.getInstance 来获取 Singleton “类”的唯一对象。简单但增加了这个“类”的“不透明性”，Singleton “类”的使用者必须知道这是一个单例“类”，跟以往通过 new XXX 方式获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。 1234var a = Singleton.getInstance(&#x27;sven1&#x27;);var b = Singleton.getInstance(&#x27;sven2&#x27;);alert( a === b); // true 4.2 透明的单例模式123456789101112131415161718192021222324var CreateDiv = (function () &#123; var instance; var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function () &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = this.html; document.body.appendChild(div); &#125;; return CreateDiv;&#125;)();var a = new CreateDiv(&#x27;sven1&#x27;);var b = new CreateDiv(&#x27;sven2&#x27;);alert(a === b); // true 为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，这增加了一些程序的复杂度。 CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。这是一种不好的做法。 假设某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成一个普通的可产生多个实例的类，那就必须改写 CreateDiv 构造函数。 4.3 用代理实现单例模式1234567891011121314151617181920212223242526var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;CreateDiv.prototype.init = function () &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = this.html; document.body.appendChild(div);&#125;;// 代理类var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var a = new ProxySingletonCreateDiv(&#x27;sven1&#x27;);var b = new ProxySingletonCreateDiv(&#x27;sven2&#x27;);console.log(a === b); // true 把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。CreateDiv 变成普通的类，跟 proxySingletonCreateDiv 组合起来达到单例模式的效果。 4.4 JavaScript 中的单例模式前面提到的实现更接近传统面向对象语言中的实现，单例对象从“类”中创建出来。在以类为中心的语言中，这是很自然的做法。但 JavaScript 是一门无类（class-free）语言，在 JavsScript 中创建对象的方法非常简单，既然只需要一个“唯一”的对象，为什么要先创建一个“类”呢？ 单例模式的核心是确保只有一个实例，并提供全局访问。 全局变量不是单例模式，但在 JavaScript 开发中，经常会把全局变量当成单例来使用。例如： 1var a = &#123;&#125;; 独一无二且提供全局访问，满足单例模式两个条件。 但全局变量，容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能会存在很多这样的变量。JavaScript 中的变量也很容易被不小心覆盖。JavaScript 的创造者 Brendan Eich 本人也承认全局变量是设计上的失误。 以下几种方式可以相对降低全局变量带来的命名污染。 1. 使用命名空间合理使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。 123456789101112131415161718192021222324252627282930313233343536// 对象字面量var namespace = &#123; a: function () &#123; alert(1); &#125;, b: function () &#123; alert(2); &#125;&#125;;// 动态创建命名空间var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split(&#x27;.&#x27;); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;;MyApp.namespace(&#x27;event&#x27;);MyApp.namespace(&#x27;dom.style&#x27;);console.dir(MyApp);// 上述代码等价于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;; 2. 使用闭包封装私有变量把一些变量封装在闭包的内部，只暴露一些接口跟外界通信： 12345678910var user = (function () &#123; var __name = &#x27;Sven&#x27;, __age = 29; return &#123; getUserInfo: function () &#123; return __name + &#x27;-&#x27; + __age; &#125; &#125;&#125;)(); 用下划线来约定私有变量 __name 和 __age，封装在闭包产生的作用域中，外部是访问不到这两个变量的，避免对全局的命令污染。 4.5 惰性单例惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度可能超出了我们的想象。 123456789101112131415161718var createLoginLayer = (function () &#123; var div; return function () &#123; if (!div) &#123; div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录窗&#x27;; div.style.display = &#x27;none&#x27;; document.body.appendColor(div); &#125; return div; &#125;&#125;)();document.getElementById(&#x27;loginBtn&#x27;).onclick = function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = &#x27;block&#x27;;&#125;; 4.6 通用的惰性单例上一节的惰性单例代码还有一些问题： 违反单一职责原则，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。 如果下次需要创建页面中唯一的 iframe 或其他，就必须把 createLoginLayer 函数几乎照抄一遍。 管理单例的逻辑可以抽象出来：用一个变量来标识是否创建过对象，如果是，则下次直接返回这个已经创建好的对象： 1234var obj;if (!obj) &#123; obj = xxx;&#125; 把管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数： 123456var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;; 接下来将用于创建登录浮窗的方法用参数 fn 的形式传入 getSingle。之后再让 getSingle 返回一个新的函数，并且用一个变量 result 来保存 fn 的计算结果。result 变量因为身在闭包中，永远不会被销毁。 1234567891011121314var createLoginLayout = function () &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录浮窗&#x27;; div.style.display = &#x27;none&#x27;; document.body.appendChild(div); return div;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById(&#x27;loginBtn&#x27;).onclick = function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = &#x27;block&#x27;;&#125;; 把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。 单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于 jQuery，通常选择给节点绑定 one 事件： 1234567891011121314var bindEvent = function () &#123; $(&#x27;div&#x27;).one(&#x27;click&#x27;, function () &#123; alert(&#x27;click&#x27;); &#125;);&#125;;var render = function () &#123; console.log(&#x27;开始渲染列表&#x27;); bindEvent();&#125;;render();render();render(); 如果利用 getSingle 函数，也能达到一样的效果。 123456789101112131415var bindEvent = getSingle(function () &#123; document.getElementById(&#x27;div1&#x27;).onclick = function () &#123; alert(&#x27;click&#x27;); &#125; return true;&#125;);var render = function () &#123; console.log(&#x27;开始渲染列表&#x27;); bindEvent();&#125;;render();render();render(); render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个事件。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 3","path":"/2017/01/22/js-design-patterns-3/","content":"第三章 闭包和高阶函数 3.1 闭包3.1.1 变量的作用域带 var，局部变量；不带 var，全局变量。 在 JavaScript 中，函数可以用来创造函数作用域。变量的搜索是从内到外而飞从外到内的。 3.1.2 变量的生存周期全局变量的生存周期是永久，除非主动销毁之。 局部变量随着函数调用的结束而被销毁。注意： 1234567891011var f = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;&#125;;f(); // 输出：2f(); // 输出：3f(); // 输出：4 当执行 var f = func() 时，f 返回了一个匿名函数的引用，它可以访问到 func() 被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 假设页面上有 5 个 div 节点，通过循环为每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出 0，点击第 2 个 div 时弹出1。 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;script&gt;var nodes = document.getElementsByTagName( &#x27;div&#x27; );for ( var i = 0, len = nodes.length; i &lt; len; i++ ) &#123; nodes[ i ].onclick = function () &#123; alert( i ); &#125;&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试发现无论点击哪个 div，最后弹出的结果都是 5。因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 解决办法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i： 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ ) &#123; (function ( i ) &#123; nodes[ i ].onclick = function () &#123; console.log(i); &#125; &#125;)( i )&#125;; 同样的道理： 123456789101112var Type = &#123;&#125;for ( var i = 0, type; type = [ &#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27; ][ i++ ];) &#123; (function ( type ) &#123; Type[ &#x27;is&#x27; + type ] = function ( obj ) &#123; return Object.prototype.toString.call( obj ) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)( type )&#125;;Type.isArray( [] ); // 输出：trueType.isString( &#x27;str&#x27; ); // 输出：true 3.1.3 闭包的更多作用1. 封装变量假设有一个计算乘积的简单函数： 1234567var mult = function () &#123; var a = 1; for (var i = 0, l = arguments.length; i &lt; 1; i++) &#123; a = a * arguments[i]; &#125;; return a;&#125;; 现在我们觉得对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能： 123456789101112131415161718var cache = &#123;&#125;var mult = function () &#123; var args = Array.prototype.join.call( arguments, &#x27;,&#x27; ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; 1; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a;&#125;alert ( mult( 1, 2, 3 ) ); // 输出：6alert ( mult( 1, 2, 3 ) ); // 输出：6，从缓存中输出 我们看到 cache 这个变量仅仅在 mult 函数中被使用，与其让 cache 变量跟 mult 函数一起平行地暴露在全局作用域下，不如把它封闭在 mult 函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。 1234567891011121314var mult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call( arguments, &#x27;,&#x27; ); if ( args in cache ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; 1; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)() 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封装起来。 123456789101112131415161718var mult = (function () &#123; var cache = &#123;&#125; var calculate = function () &#123; // 封闭 calculate 函数 var a = 1; for ( var i = 0, l = arguments.length; i &lt; 1; i++ ) &#123; a = a * arguments[i]; &#125; return a; &#125; return function () &#123; var args = Array.prototype.join.call( arguments, &#x27;,&#x27; ); if (args in cache) &#123; return cache[ args ]; &#125; return cache[ args ] = calculate.apply( null, arguments ); &#125;&#125;)(); 2. 延续局部变量的寿命img 对象经常用于进行数据上报： 123456var report = function ( src ) &#123; var img = new Image(); img.src = src;&#125;;report( &quot;http://xxx.com/getUserInfo&quot; ); 一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据。原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失。 把 img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function () &#123; var imgs = []; return function ( src ) &#123; var img = new Image(); imgs.push( img ); img.src = src; &#125;&#125;) 3.1.4 闭包与面向对象设计过程与数据结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。在 JavaScript 语言的祖先 Scheme 语言中，甚至都没有提供面向对象的原生设计，但可以使用闭包来实现一个完整的面向对象系统。 下面来看看这段跟闭包相关的代码： 123456789101112131415var extent = function () &#123; var value = 0; return &#123; call: function () &#123; value ++; console.log( value ) &#125; &#125;&#125;;var extent = extent();extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3 如果换成面向对象的写法，就是： 1234567891011var extent = &#123; value: 0, call: function () &#123; this.value ++; console.log( this.value ) &#125;&#125;;extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3 或者： 1234567891011121314var Extent = function () &#123; this.value = 0;&#125;;Extent.prototype.call = function () &#123; this.value ++; console.log( this.value );&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 用闭包实现命令模式在 JavaScript 版本的各种设计模式实现中，闭包的运用非常广泛。 在完成闭包实现的命令模式之前，我们先用面向对象的方式来编写一段命令模式的代码。 123456789101112131415161718192021222324252627282930var Tv = &#123; open: function () &#123; console.log(&#x27;打开电视机&#x27;); &#125;, close: function () &#123; console.log(&#x27;关上电视机&#x27;); &#125;&#125;;var OpenTvCommand = function ( receiver ) &#123; this.receiver = receiver;&#125;;OpenTvCommand.prototype.execute = function () &#123; this.receiver.open(); // 执行命令，打开电视机&#125;;OpenTvCommand.prototype.undo = function () &#123; this.receiver.close(); // 撤销命令，关闭电视机&#125;;var setCommand = function ( command ) &#123; document.getElementById( &#x27;execute&#x27; ).onclick = function () &#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( &#x27;undo&#x27; ).onclick = function () &#123; command.undo(); // 输出：关闭电视机 &#125;&#125;;setCommand( new OpenTvCommand( Tv ) ) 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 但在 JavaScript 中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来；而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成环境中： 12345678910111213141516171819202122232425262728293031323334var Tv = &#123; open: function () &#123; console.log( &#x27;打开电视机&#x27; ); &#125;, close: function () &#123; console.log( &#x27;关上电视机&#x27; ); &#125;&#125;;var createCommand = function ( receiver ) &#123; var execute = function () &#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function () &#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125;&#125;;var setCommand = function ( command ) &#123; document.getElementById( &#x27;execute&#x27; ).onclick = function () &#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( &#x27;undo&#x27; ).onclick = function () &#123; command.undo(); // 输出：关闭电视机 &#125;&#125;;setCommand( createCommand( Tv ) ); 3.1.6 闭包与内存管理局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄漏。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄漏。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄漏在本质上也不是闭包造成的。 如果要解决循环引用带来的内存泄漏问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 3.2 高阶函数高阶函数是指至少满足以下条件之一的函数： 函数可以作为参数被传递； 函数可以作为返回值输出。 3.2.1 函数作为参数传递把参数作为函数传递，可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来我们可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是回调函数。 1. 回调函数在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 callback 函数当作参数传入发起 ajax 请求的方法中，待请求完成之后执行 callback 函数。 另外，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。 2. Array.prototype.sortArray.prototype.sort 接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从 Array.prototype.sort 的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入 Array.prototype.sort，使 Array.prototype.sort 方法成为了一个非常灵活的方法： 1234567891011// 从小到大排列[1, 4, 3].sort(function(a, b)&#123; return a - b;&#125;);// 输出：[1,3,4]// 从大到小排列[1, 4, 3].sort(function(a, b)&#123; return b - a;&#125;);// 输出：[4, 3, 1] 3.2.2 函数作为返回值输出1. 判断数据的类型判断一个数据是否数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有 length 属性，有没有 sort 方法或者 slice 方法等。更好的方式是用 Object.prototype.toString 来计算。Object.prototype.toString.call(obj) 返回一个形如 [object Array] 的字符串。所以我们可以编写一系列的 isType 函数。 123456789var isString = function (obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object String]&#x27;;&#125;var isArray = function (obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;&#125;... 可以发现，这些函数的大部分实现是相同的，不同的只是 Object.prototype.toString.call(obj) 返回的字符串，为了避免多余的代码，我们尝试把这些字符串作为参数提前值入 isType 函数： 1234567891011var isType = function (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125;&#125;var isString = isType(&#x27;String&#x27;)var isArray = isType(&#x27;Array&#x27;)var isNumber = isType(&#x27;Number&#x27;)console.log(isArray([1, 2, 3])); // 输出：true 可以用循环语句注册这些 isType 函数： 123456789101112var Type = &#123;&#125;;for (var i = 0, type; type = [&#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27;][i++]) &#123; (function (type) &#123; Type[&#x27;is&#x27; + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)(type)&#125;Type.isArray([]); // 输出：trueType.isString(&#x27;str&#x27;); // 输出：true 2. getSingle单例模式将在后面章节学习，此处仅作举例。 123456var getString = function (fn) &#123; var ret; return function () &#123; return ret || (ret = fn.apply(this, arguments)); &#125;&#125; 这个例子既把函数当作参数传递，又让函数执行后返回了另外一个函数。我们可以看看 getSingle 函数的效果： 12345678var getSingle = getSingle(function () &#123; return document.createElement(&#x27;script&#x27;);&#125;);var script1 = getScript();var script2 = getScript();alert(script1 === script2); // 输出：true 3.2.3 高阶函数实现 AOPAOP（面向切面编程）主要作用是把一些跟核心业务无关的功能抽离出来，这些跟业务无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面是通过扩展 Function.prototype 来做到的例子。 1234567891011121314151617181920212223242526272829303132Function.prototype.before = function (beforefn) &#123; var __self = this; // 保存原函数的引用 return function () &#123; // 返回包含了原函数和新函数的“代理”函数 beforefn.apply(this, arguments); // 执行新函数，修正 this return __self.apply(this, arguments) &#125;&#125;Function.prototype.after = function (afterfn) &#123; var __self = this; return function () &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;var func = function () &#123; cons ole.log(2)&#125;func = func.before(function () &#123; console.log(1);&#125;).after(function () &#123; console.log(3);&#125;);func();// 1// 2// 3 这种使用 AOP 的方式来给函数添加职责，也是 JavaScript 语言中一种非常特别和巧妙的装饰者模式实现。 3.2.4 高阶函数的其他应用1. function currying（函数柯里化）currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 1234567891011121314151617181920212223242526272829var currying = function (fn) &#123; var args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; &#125; &#125;&#125;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; 1; i++) &#123; money += arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying(cost); // 转化成 currying 函数cost(100); // 未真正求值cost(200); // 未真正求值alert(cost()); // 求值并输出 这是一个 currying 函数。当调用 cost() 时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另外一个函数。只有当我们以不带参数的形式执行 cost() 时，才利用前面保存的所有参数，真正开始进行求值计算。 2. uncurrying1234567Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; var obj = Array.prototype.shift.call( arguments ); return self.apply( obj, arguments ); &#125;;&#125;; 作用： 在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call 这句代码转换为一个通用的 push 函数： 123456var push = Array.prototype.push.uncurrying();(function () &#123; push( arguments, 4 ); console.log( arguments ); // 输出：[1, 2, 3, 4]&#125;)(1, 2, 3); 通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数。这样一来 push 的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。 还可以一次性把 Array.prototype 上的方法“复制”到 array 对象上，同样这些方法可操作的对象也不仅仅只是 array 对象： 123for (var i = 0, fn, ary = [&#x27;push&#x27;, &#x27;shift&#x27;, &#x27;forEach&#x27;]; fn = ary[i++];) &#123; Array[fn] = Array.prototype[fn].uncurrying();&#125;; 上面是 Function.prototype.uncurrying 的一种实现。下面是分析： 12345678910111213141516171819202122Function.prototype.uncurrying = function () &#123; var self = this; // self 此时是 Array.prototype.push return function () &#123; var obj = Array.prototype.shift.call( arguments ); // obj 是 &#123; // &quot;length&quot;: 1, // &quot;0&quot;: 1 // &#125; // arguments 对象的第一个元素被截去，剩下[2] return self.apply( obj, arguments ); // 相当于 Array.prototype.push.apply( obj, 2 ) &#125;;&#125;;var push = Array.prototype.push.uncurrying();var obj = &#123; &quot;length&quot;: 1, &quot;0&quot;: 1&#125;;push( obj, 2 );console.log(obj); // 输出：&#123;0: 1, 1: 2, length: 2&#125; 另一种实现方式： 123456Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; return Function.prototype.call.apply( self, arguments ); &#125;;&#125;; 3. 函数节流少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能会被非常频繁地调用，而造成大的性能问题。 window.onresize 事件。 mouseover 事件。 上传进度。 原理 按时间段忽略掉一些请求，比如确保在 500ms 内只打印一次。可以借助 setTimeout。 将即将被执行的函数用 setTimeout 延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。 throttle 函数接受 2 个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间。 1234567891011121314151617181920212223242526272829var throttle = function (fn, interval) &#123; var __self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function () &#123; var args = arguments, __me = this; if (firstTime) &#123; // 如果是第一次调用，不需延迟执行 __self.apply(__me, args); return firstTime = false; &#125; if (timer) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false &#125; timer = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timer); timer = null; __self.apply(__me, args); &#125;, interval || 500); &#125;;&#125;;window.onresize = throttle(function () &#123; console.log( 1 );&#125;, 500); 4. 分时函数某些函数是用户主动调用的，但因为一些客观的原因，这些函数会严重影响页面性能，如创建长列表。 在短时间内往页面中大量添加 DOM 节点显然也会让浏览器吃不消，结果往往是浏览器的卡顿甚至假死。 12345678910111213var ary = [];for (var i = 1; i &lt;= 1000; i++) &#123; ary.push(i); // 假设 ary 装载了 1000 个好友的数据&#125;;var renderFriendList = function (data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = i; document.body.appendChild(div); &#125;&#125;; timeChunk 函数让创建节点的工作分批进行，比如把 1 秒钟创建 1000 个节点，改为每隔 200 毫秒创建 8 个节点。 12345678910111213141516171819var timeChunk = function (ary, fn, count) &#123; var obj, t; var len = ary.length; var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift(); fn(obj); &#125; &#125;; return function () &#123; t = setInterval(function () &#123; if (ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t); &#125; &#125;, 200); // 分批执行的时间间隔，也可以用参数的形式传入 &#125;;&#125;; 使用 timeChunk 函数，每一批只往页面中创建 8 个节点： 12345var renderFriendList = timeChunk(ary, function (n) &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = i; document.body.appendChild(div);&#125;, 8); 5. 惰性加载函数由于浏览器间的实现差异，一些嗅探工作在所难免。比如一个在各浏览器中通用的事件绑定函数 addEvent，常见的写法如下： 12345678910var addEvent = function (elem, type, handler) &#123; if (window.addEventListener) &#123; return elem.addEventListener(type, handler, false); &#125; if (window.attachEvent) &#123; return elem.attachEvent(&#x27;on&#x27; + type, handler); &#125;&#125;;// 每次被调用都会执行 `if` 条件分支。 把嗅探浏览器的操作提前到代码加载的时候，返回一个包裹了正确逻辑的函数。 123456789101112var addEvent = (function () &#123; if (window.addEventListener) &#123; return function (elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; if (window.attachEvent) &#123; return function (elem, type, handler) &#123; elem.attachEvent(&#x27;on&#x27; + type, handler); &#125; &#125;&#125;)(); 也许从头到尾都没有使用过 addEvent 函数，这样看来，前一次的浏览器嗅探就是完全多余的动作，也会稍稍延长页面 ready 的时间。 惰性载入方案： 1234567891011var addEvent = function (elem, type, handler) &#123; if (window.addEventListener) &#123; addEvent = function (elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; else if (window.attachEvent) &#123; elem.attachEvent(&#x27;on&#x27; + type, handler); &#125; addEvent(elem, type, handler);&#125;"},{"title":"（译）React AJAX 最佳实践","path":"/2017/01/18/react-ajax-best-practices/","content":"当你开始注意 AJAX 与 React 问题时，专家们告诉你的第一件事就是 React 是个视图类库，没有网络、AJAX 功能。 虽然知道这点挺好的，但没什么用，尤其是当你只想在 React 组件里向服务器获取数据的时候。 真相是，有很多方法可以做到。你自己可能就想到几种，但要是你选择了错误的方法，你的代码就回变得一团糟。 因此你就有疑问：什么事“对的”或者“首选”的方法？ 在 React 组件中向服务器获取数据的最佳实践是怎样的？ 答案是……看情况。 四种方法我列举了四种在 React 中使用 AJAX 的不错的方法。 你使用哪种方法取决于你 app 的体量及复杂程度，以及你已经在使用的类库和技术。 根组件 容器组件 Redux 异步 Actions Relay 1. 根组件 这是最简单的方法，因此很适合原型或者小型应用。 在此方法中，你构建一个单一的根&#x2F;父组件，用它来执行你所有的 AJAX 请求。 做为例子，可以看看 React 官方的教程。CommentBox 组件就是一个发送所有 AJAX 请求的根组件。 我不喜欢官方例子的原因：他们使用 jQuery 发送 AJAX 请求。jQuery 是一个很庞大有很多功能的类库，仅用于 AJAX 并不合理。 我推荐使用 fetch()。这是一个简单、标准化的 AJAX API。它已经被 Chrome 和 Firefox 所支持，node 和其他浏览器也有“补丁”。具体细节，或者供选择 AJAX 类库时参考，请看我的《AJAX 库对比》（原作者的）。 其他说明：如果你有一个很深的组件树（子组件甚至后代组件）那么你就需要从根组件经过一条很长的路将数据传递给深层的组件。 什么时候适合在根组件发起 AJAX 请求？ app 的组件树不深； app 中没有使用 Redux 或者 Flux。 2. 容器组件 一个容器组件“给表现层或其他容器组件提供数据和行为”。如果你从没听过这个说法，我建议你读一下 Dan Abramov 的《Presentational and Container Components》。 对于我们的目标，容器组件方法和根组件方法非常相似，除了复数可与服务器交互的组件。 它的工作原理是这样的：给每一个需要从服务器获取数据的表现层组件创建一个容器组件，用此容器组件发送 AJAX 请求获取数据，通过属性传递给子组件。 举个具体例子，想象你想展示一个用户简介，有名字和一张照片。 首先创建一个 &lt;UserProfile /&gt; 表现层组件，其接收一个 name 和 profileImage 属性。这个组件不应该有任何的 AJAX 代码。 然后创建一个 &lt;UserProfileContainer /&gt; 组件接收 userId。它会下载关于那个用户的数据，然后通过参数传递给 &lt;UserProfile /&gt; 组件。 容器组件可以通过一个简单的 AJAX 库来发起 AJAX 请求。我推荐 fetch()。 什么时候适合在容器组件发起 AJAX 请求？ app 的组件树很深； 大部分组件不从服务端请求数据，只有一部分需要； 要从不同的 API 或者终端请求数据； app 中没有使用 Redux 或者 Flux，或者相比 “异步 actions” 你更喜欢容器组件。 3. Redux 异步 Actions Redux 管理数据，AJAX 从服务端获取数据，由 Redux 代码来处理网络请求是合理的。 如果你正在使用 Redux，别把 AJAX 放在你的 React 组件中。而是放在你的异步 Actions 中。 我推荐使用 fetch() 来发起真正的网络请求。幸运地，这也是 Redux 官方文档中使用的。他们甚至写了一个含 Redux、React、fetch() 和 reddit API 的例子。 如果你正在使用另外一种 flux 库，方法是简单的——在 actions 中发起网络请求。 什么时候适合在 Redux 异步 Actions 中发起 AJAX 请求？ 如果你在使用 Redux，这就是合适的方法； 如果你在使用其他的 flux 库，会有相似能用的方法。 4. Relay 通过 GraphQL 声明 React 组件所需的数据，Relay 就会自动下载数据并会填充到组件属性。 Relay 在大型应用中使用良好，但需要较大的学习成本。你需要： 学习 Relay 和 GraphQL； 用 GraphQL（而不是用 propTypes）指出 React 组件所需的数据； 搭建一个 GraphQL 服务器； Relay 只用于与 GraphQL 服务器通信，对于任何第三方 API 将无能为力。 目前，Relay 只能与一个 GraphQL 服务器通信，因此如果你从多个源获取数据，这个方法不适合你。未来将实现与多个服务器通信的功能，这个 github issue 中有更深入的讨论。 如果你想用这个方法，Relay Playground 是一个非常好的地方让你弄明白 Relay 是如何工作的。 什么时候适合使用 Relay？ 你在构建大型应用，而且你所担忧的问题正好是 Relay 所解决的； 还没构建 JSON API； 你愿意搭建一个 GraphQL 服务器； 你的 app 仅仅与单一服务端通信。 反面模式如果上述所有的方法都是正确的，那么哪些方法是错误的？这里有两种典型的方法是我所反对的。 反面模式1: 在表现层组件中发起 AJAX 请求不要在已经有其他职责的组件中添加 AJAX 代码——比如复杂的交互渲染。这样做会违反关注分离的设计原则。 反面模式2: ReactDOM.render()你可以将 AJAX 逻辑与 React 完全分离，从服务器获取到数据之后再执行 ReactDOM.render() 方法。 这个方法或许可行，我将之列为反面模式是因为我相信根组件方法与之类似且更简洁。 结束语用 React 构建的应用是模块化的。React 只是其中的一个模块，AJAX 库也是。这不是 Rails 或 Angular。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 2","path":"/2017/01/15/js-design-patterns-2/","content":"第二章 this、call 和 apply 2.1 thisJavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 2.1.1 this 的指向除去不常用的 with 和 eval 的情况： 作为对象的方法调用 作为普通函数调用 构造器调用 Function.prototype.call 或 Function.prototype.apply 调用 1. 作为对象的方法调用123456789var obj = &#123; a: 1, getA: function () &#123; alert ( this === obj ); // 输出：true alert ( this.a ); // 输出：1 &#125;&#125;;obj.getA(); 2. 作为普通函数调用指向全局对象，在浏览器的 JavaScript 中，这个全局对象是 window 对象。 1234567window.name = &#x27;globalName&#x27;;var getName = function () &#123; return this.name;&#125;;console.log( getName() ); // 输出：globalName 或者： 1234567891011window.name = &#x27;globalName&#x27;;var myObject = &#123; name: &#x27;sven&#x27;, getName: function () &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log( getName() ); // globalName 有时，在 div 节点的事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向该 div 节点，此时可以用一个变量保存 div 节点的引用。在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined。 3. 构造器调用除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指返回的这个对象。 123456var MyClass = function () &#123; this.name = &#x27;sven&#x27;;&#125;var obj = new MyClass();console.log( obj.name ); // 输出：sven 但用 new 调用构造器时，如果构造器显式地返回了一个 sven 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this： 123456789var MyClass = function () &#123; this.name = &#x27;sven&#x27;; return &#123; // 显式地返回一个对象 name: &#x27;anne&#x27; &#125;&#125;;var obj = new MyClass();console.log( obj.name ); // 输出：anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。 5. Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this： 12345678910111213var obj1 = &#123; name: &#x27;sven&#x27;, getName: function () &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: &#x27;anne&#x27;&#125;;console.log( obj1.getName() ); // 输出：svenconsole.log( obj1.getName().call( obj2 ) ); // 输出：anne 2.1.2 丢失的 this1234567891011var obj = &#123; myName: &#x27;sven&#x27;, getName: function () &#123; return this.myName &#125;&#125;;console.log( obj.getName() ); // 输出：svenvar getName2 = obj.getName;console.log( getName2() ); // 输出：undefined 当调用 obj.getName 时，getName 方法是作为 obj 对象的属性被调用的，此时的 this 指向 obj 对象，所以 obj.getName() 输出 sven。当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，此时是普通函数调用方式，this 是指向全局 window 的，所以程序执行的结果是 undefined。 12var getId = document.getElementById;getId(&#x27;div1&#x27;); 上面这段代码抛出了一个错误，因为许多浏览器引擎的 getElementById 方法的内部实现中需要用到 this。这个 this 本来被期望指向 document，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正” this： 12345678910document.getElementById = (function (fun) &#123; return function () &#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;var div = getId( &#x27;div1&#x27; );alert(div.id); // 输出：div1 2.2 call 和 apply2.2.1 call 和 apply 的区别Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下表的集合（数组或类数组），apply 方法把这个集合中的元素作为参数传递给被调用的函数： 12345var func = function ( a, b, c ) &#123; alert( [a, b, c] ) // 输出 [ 1, 2, 3]&#125;func.apply( null, [ 1, 2, 3 ] ); call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数： 12345var func = function ( a, b, c ) &#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.call( null, 1, 2, 3 ); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比 call 的使用率更高。call 是包装在 apply 上的一颗语法糖。 当传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中就是 window： 12345var func = function ( a, b, c ) &#123; alert ( this === window ); // 输出 true&#125;;func.apply( null, [ 1, 2, 3 ] ); 但如果在严格模式下，函数体内的 this 还是为 null： 123456var func = function ( a, b, c ) &#123; &quot;use strict&quot;; alert ( this === window ); // 输出 true&#125;;func.apply( null, [ 1, 2, 3 ] ); 有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象： 1Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出：5 2.2.2 call 和 apply 的用途1. 改变 this 指向call 和 apply 最常见的用途是改变函数内部的 this 指向： 1234567891011121314151617var obj1 = &#123; name: &#x27;sven&#x27;&#125;;var obj2 = &#123; name: &#x27;anne&#x27;&#125;;window.name = &#x27;window&#x27;;var getName = function () &#123; alert ( this.name );&#125;;getName(); // 输出：windowgetName.call( obj1 ); // 输出：svengetName.call( obj2 ); // 输出：anne 2. Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的实现，也可以模拟一个： 12345678910111213141516Function.prototype.bind = function ( context ) &#123; var self = this; // 保存原函数 return function () &#123; return self.apply( context, arguments ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this &#125;&#125;;var obj = &#123; name: &#x27;sven&#x27;&#125;;var func = function () &#123; alert ( this.name ); // 输出：sven&#125;.bind(obj);func(); 通常会实现得稍微复杂一些： 123456789101112131415161718192021Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call( arguments ), // 需要绑定的 this 上下文 args = [].slice.call( arguments ); // 剩余的参数转成数组 return function () &#123; // 返回一个新的函数 return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) ); // 执行新的函数的时候，会把之前传入的 `context` 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;;&#125;;var obj = &#123; name: &#x27;sven&#x27;&#125;;var func = function ( a, b, c, d ) &#123; alert ( this.name ); // 输出：sven alert ( [ a, b, c, d ] ) // 输出：[ 1, 2, 3, 4 ]&#125;.bind( obj, 1, 2 );func( 3, 4 ); 3. 借用其他对象的方法借用构造函数可以实现一种类似继承的效果： 1234567891011121314var A = function ( name ) &#123; this.name = name;&#125;;var B = function () &#123; A.apply( this, arguments );&#125;;B.prototype.getName = function () &#123; return this.name;&#125;;var b = new B( &#x27;sven&#x27; );console.log( b.getName() ); // 输出：&#x27;sven&#x27; 函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。在操作 arguments 时，我们常常会借用 Array.prototype 对象上的方法。 1234(function () &#123; Array.prototype.push.call( arguments, 3 ); console.log( arguments ); // 输出[1,2,3]&#125;)( 1, 2 ); 以 Array.prototype.push 为例，看看 V8 引擎中的具体实现： 123456789function ArrayPush () &#123; var n = TO_UINT32( this.length ); // 被 push 的对象的 length var m = %_ArgumentsLength(); // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[ i + n ] = %_Arguments( i ); // 复制元素 &#125; this.length = n + m; // 修正 length 属性的值 return this.length;&#125;; Array.prototype.push 实际上是一个属性复制的过程，把参数按照下标一次添加到被 push 的对象上面，顺便修改了这个对象的 length 属性。至于被修改的对象是数组还是类数组对象，并不重要。 12345var a = &#123;&#125;;Array.prototype.push.call( a, &#x27;first&#x27; );alert( a.length ); // 输出：1alert( a[ 0 ] ); // first 如果在低版本的 IE 浏览器中执行，必须显式地给对象 a 设置 length 属性： 123var a = &#123; length: 0&#125;; 可以借用 Array.prototype.push 方法的对象还要满足以下两个条件： 对象本身要可以存取属性； 对象的 length 属性可读写。"},{"title":"《JavaScript 设计模式与开发实战》读书笔记 1","path":"/2017/01/12/js-design-patterns-1/","content":"第一章 面向对象的 JavaScript 1.1 动态类型语言和鸭子类型 静态类型语言在编译时便已确定变量的类型 动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型 鸭子类型：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” 即我们只关注对象的行为（HAS-A），而不关注对象本身（IS-A）。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。 1.2 多态 多态：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放-闭合原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。 1.2.5 JavaScript的多态JavaScript 的变量类型在运行期是可变的，这意味着 JavaScript 对象的多态性是与生俱来的。JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。并不存在任何程度上的“类型耦合”。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。 1.2.6 多态在面向对象程序设计中的作用多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。 1.2.7 设计模式与多态在 JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现的原因。 1.3 封装封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 1.3.1 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、public、protected 等关键字来提供不同的访问权限。 但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。 除了 ECMAScrip 6 中提供的 let 之外，一般我们通过函数来创建作用域： 1234567891011var myObject = (function () &#123; var __name = &#x27;sven&#x27;; // 私有（private）变量 return &#123; getName: function () &#123; // 公开（public）变量 return __name; &#125; &#125;&#125;)();console.log( myObject.getName() ); // 输出：svenconsole.log( myObject.__name ); // 输出：undefined 1.3.2 封装实现从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。 1.3.3 封装类型封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的。把对象的真正类型隐藏在抽象类或接口之后，相比对象的类型，客户更关心对象的行为。在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语言。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。 1.3.4 封装变化从设计模式的角度出发，封装在更重要的层面体现为封装变化。 从意图上区分，设计模式可被划分为创建型模式、结构型模式和行为型模式。 创建型模式封装创建对象的变化，结构型模式封装的是对象之间的组合关系，行为型模式封装的是对象的行为变化。 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。 1.4 原型模式和基于原型继承的 JavaScript 对象系统在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，一个对象是通过克隆另外一个对象所得到的。 原型模式不单是一种设计模式，也被称为一种编程范型。 1.4.1 使用克隆的原型模式原型模式的实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5 提供了 Object.create 方法，可以用来克隆对象。 12345678910111213var Plane = function () &#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;&#125;;var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create(plane);console.log(clonePlane); // 输出：Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125; 在不支持 Object.create 方法的浏览器中，则可以使用以下代码： 123456Object.create = Object.create || function (obj) &#123; var F = function () &#123;&#125;; F.prototype = obj; return new F();&#125; 1.4.5 JavaScript 中的原型继承原型编程的基本规则。 所有的数据都是对象。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 1. 所有的数据都是对象在 JavaScript 中不能说所有的数据都是对象，但可以说绝大部分数据都是对象。JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空对象。我们在 JavaScript 中遇到的每个对象，实际上都是以 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。 12var obj1 = new Object();var obj2 = &#123;&#125;; 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型： 12console.log( Object.getPrototypeOf(obj1) === Object.prototype ); // 输出：trueconsole.log( Object.getPrototypeOf(obj2) === Object.prototype ); // 输出：true 2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它12345678910111213function Person (name) &#123; this.name = name;&#125;;Person.prototype.getName = function () &#123; return this.name;&#125;;var a = new Person (&#x27;sven&#x27;);console.log( a.name ); // 输出：svenconsole.log( a.getName() ); // 输出：svenconsole.log( Object.getPrototypeOf(a) === Person.prototype ); // 输出：true 在这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。 3. 对象会记住它的原型就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。 JavaScript 给对象提供了一个 __proto__ 的隐藏属性，某个对象的 __proto__ 属性默认会指向它的构造器的原型对象，即 &#123;Constructor&#125;.prototype。在一些浏览器中，__proto__ 被公开出来。 12var a = new Object();console.log( a.__proto__ === Object.prototype ); // 输出：true __proto__ 就是对象跟“对象构造器的原型”联系起来的纽带。 4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型这条规则即是原型继承的精髓所在。 虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果。 1234567var obj = &#123; name: &#x27;sven&#x27; &#125;;var A = function () &#123;&#125;;A.prototype = obj;var a = new A();console.log( a.name ); // 输出： sven 当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现： 12345678var A = function () &#123;&#125;;A.prototype = &#123; name: &#x27;sven&#x27; &#125;;var B = function () &#123;&#125;;B.prototype = new A();var b = new B();console.log( b.name ); // 输出：sven Object.prototype 的原型是 null。 1.4.6 原型继承的未来Object.create 是原型模式的天然实现，目前大多数主流浏览器都提供了 Object.create 方法。但在当前的 JavaScript 引擎下，通过 Object.create 来创建对象的效率并不高，通常比通过构造函数创建对象要慢。通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个原型。而通过 Object.create(null) 可以创建出没有原型的对象。 ECMAScript 6 带来新的 class 语法，背后仍是通过原型机制来创建对象。 1234567891011121314151617181920class Animal &#123; constructor (name) &#123; this.name = name; &#125; getName () &#123; return this.name &#125;&#125;class Dog extends Animal &#123; constructor (name) &#123; super(name); &#125; speak () &#123; return &quot;woof&quot;; &#125;&#125;var dog = new Dog(&quot;Scamp&quot;);console.log(dog.getName() + &#x27; says &#x27; + dog.speak())"},{"title":"小智的2015","path":"/2015/12/29/my-2015/","content":"一转眼又是一年，去年的今天我在干什么？ 2015年的关键词：生病、健身、游戏、工作。 生病元旦去了湖南一趟，回来之后扁桃体发炎，发烧了一个星期。 10月下旬肺炎，在医院住了两个星期，每天打点滴，生日都是在病房里过的。医生说在我这样的年龄，这么严重的肺炎还是很少见的，CT 里右下肺部一大片阴影。不过肺炎还是能治好的，只是比其他人用的时间长。 感谢在我生病期间无微不至照顾我的父母，以及支持我的各位朋友。 健身经过这两次大病之后，我意识到自己的身体素质真不是一般的差，因此就走进了健身房。目前为止练了一个多月，变化比较明显的是前胸和上臂，都大了一圈，另外就是肚子也小了一些。但健身真的是个大坑啊，开卡好多钱，请私教好多钱，买补剂好多钱……只能勒紧裤腰带过日子。11 月底也着凉感冒了，但奇迹地2天就好了，因为健身吗？ 2016 年的计划就是自学更多的健身知识，锻炼好身体，提高健康指数，少生病。 游戏一直都有自己做一款游戏的想法，做一款 srpg&#x2F;slg 游戏，但限于技术及策划水平一直难以开始。10月底的病床上我看了一本《游戏设计之道》，大概了解了一下做游戏的方法论，感觉稍微有了一点底气。 计划是做一款类似《火炎之纹章》的游戏，工具用 SRPG Studio。这个工具的脚本语言竟然是 JavaScript 而不是 C++ 或者别的语言，对我来说算是更容易上手吧。另外要提升的是剧本的设计能力，美工方面就无能为力了，只能用默认的素材。可恶的是这个东东竟然没有 osx 版本，要开虚拟机真是麻烦…… 2016 年的目标是设计出整个游戏背景，实现前 2~3 章。 工作这一年主要工作是负责公司主产品的前端部分，偶尔支援一下公司的其他项目，另外就是前端团队的扩张。过年前后公司的发展方向大调整，从红海里跳出来，转去做跨境医疗预约平台，目前整个市场还在发掘当中，场内玩家也不多，竞争不算激烈，现在最前列的应该是我们公司。至于这个市场以后会不会迎来爆发，以我粗浅的见识也看不出什么，只能跟着老大走，暂时还是乐观的。 技术方面，近几年前端的知识呈爆炸性增长，有时很火爆的事物转眼就变成明日黄花，在这种背景下，身为局中人难免会感到迷茫。我的做法是将前端大致地分出方向，选择其中相对比较健壮的一条作为学习的主线，其他的大致了解，有余力再深挖。接下来一段时间内我的方向应该就是 React 的生态圈了。 其他表妹结婚了啊，一起长大的小人儿嫁了，心情还是挺奇特的~ 尾声该怎么结尾呢？这一年回顾下来，生活不怎么有趣，偶尔也磕磕绊绊，但前路也稍微清晰了一点，给自己打个 65 分吧，希望新一年也能踏踏实实地走下去。"},{"title":"React 编程规范","path":"/2015/12/23/react-style-guide/","content":"#React 编程规范(by Airbnb) 基本规则 命名 声明 对齐 引号 空格 属性 括号 标签 方法 顺序 ##基本规则 每个文件只包含一个 React 组件 使用 JSX 语法 除非是从一个非 JSX 文件中初始化 app，否则不要使用 React.createElement Class vs React.createClass 除非有更好的理由使用混淆(mixins)，否则就使用组件类继承 React.Component。eslint 规则：react&#x2F;prefer-es6-class 12345678910111213// badconst Listing = React.createClass(&#123; render() &#123; return &lt;div /&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; render() &#123; return &lt;div /&gt;; &#125;&#125; ##命名 扩展名: 使用 jsx 作为 React 组件的扩展名 文件名: 文件命名采用帕斯卡命名法，如：ReservationCard.jsx 引用名: 组件引用采用帕斯卡命名法，其实例采用驼峰式命名法。eslint rules: react&#x2F;jsx-pascal-case 1234567891011// badconst reservationCard = require(&#x27;./ReservationCard&#x27;);// goodconst ReservationCard = require(&#x27;./ReservationCard&#x27;);// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 组件命名: 使用文件名作为组件名。例如：ReservationCard.jsx 组件的引用名应该是 ReservationCard。然而，对于一个目录的根组件，应该使用 index.jsx 作为文件名，使用目录名作为组件名。 12345678// badconst Footer = require(&#x27;./Footer/Footer.jsx&#x27;)// badconst Footer = require(&#x27;./Footer/index.jsx&#x27;)// goodconst Footer = require(&#x27;./Footer&#x27;) ##声明 不要通过 displayName 来命名组件，通过引用来命名组件 123456789// badexport default React.createClass(&#123; displayName: &#x27;ReservationCard&#x27;, // stuff goes here&#125;);// goodexport default class ReservationCard extends React.Component &#123;&#125; ##对齐 对于 JSX 语法，遵循下面的对齐风格。eslint rules: react&#x2F;jsx-closing-bracket-location 1234567891011121314151617181920// bad &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; // good &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; // if props fit in one line then keep it on the same line &lt;Foo bar=&quot;bar&quot; /&gt; // children get indented normally &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; &gt; &lt;Spazz /&gt; &lt;/Foo&gt; ##引号 对于 JSX 使用双引号，对其它所有 JS 属性使用单引号 为什么？因为 JSX 属性不能包含被转移的引号，并且双引号使得如 &quot;don&#39;t&quot; 一样的连接词很容易被输入。常规的 HTML 属性也应该使用双引号而不是单引号，JSX 属性反映了这个约定。 eslint rules: jsx-quotes 1234567891011// bad &lt;Foo bar=&#x27;bar&#x27; /&gt; // good &lt;Foo bar=&quot;bar&quot; /&gt; // bad &lt;Foo style=&#123;&#123; left: &quot;20px&quot; &#125;&#125; /&gt; // good &lt;Foo style=&#123;&#123; left: &#x27;20px&#x27; &#125;&#125; /&gt; ##空格 在自闭和标签之前留一个空格 123456789101112// bad&lt;Foo/&gt;// very bad&lt;Foo /&gt;// bad&lt;Foo /&gt;// good&lt;Foo /&gt; ##属性 属性名采用驼峰式命名法 123456789101112// bad&lt;Foo UserName=&quot;hello&quot; phone_number=&#123;12345678&#125;/&gt;// good&lt;Foo userName=&quot;hello&quot; phoneNumber=&#123;12345678&#125;/&gt; ##括号 当组件跨行时，要用括号包裹 JSX 标签。eslint rules: react&#x2F;wrap-multilines 123456789101112131415161718192021/// bad render() &#123; return &lt;MyComponent className=&quot;long body&quot; foo=&quot;bar&quot;&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;; &#125; // good render() &#123; return ( &lt;MyComponent className=&quot;long body&quot; foo=&quot;bar&quot;&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; ); &#125; // good, when single line render() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;; &#125; ##标签 没有子组件的父组件使用自闭和标签。eslint rules: react&#x2F;self-closing-comp 12345// bad &lt;Foo className=&quot;stuff&quot;&gt;&lt;/Foo&gt; // good &lt;Foo className=&quot;stuff&quot; /&gt; 如果组件有多行属性，闭合标签应写在新的一行上。eslint rules: react&#x2F;jsx-closing-bracket-location 12345678910// bad &lt;Foo bar=&quot;bar&quot; baz=&quot;baz&quot; /&gt; // good &lt;Foo bar=&quot;bar&quot; baz=&quot;baz&quot; /&gt; ##方法 不要对 React 组件的内置方法使用 underscore 前缀 1234567891011121314151617// badReact.createClass(&#123; _onClickSubmit() &#123; // do stuff &#125; // other stuff&#125;);// goodclass extends React.Component &#123; onClickSubmit() &#123; // do stuff &#125; // other stuff&#125;); ##顺序 继承 React.Component 的类的方法遵循下面的顺序 constructor optional static methods getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render 怎么定义 propTypes，defaultProps，contextTypes 等等… 1234567891011121314151617181920212223242526import React, &#123; PropTypes &#125; from &#x27;react&#x27;;const propTypes = &#123; id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string,&#125;;const defaultProps = &#123; text: &#x27;Hello World&#x27;,&#125;;class Link extends React.Component &#123; static methodsAreOk() &#123; return true; &#125; render() &#123; return &lt;a href=&#123;this.props.url&#125; data-id=&#123;this.props.id&#125;&gt;&#123;this.props.text&#125;&lt;/a&gt; &#125;&#125;Link.propTypes = propTypes;Link.defaultProps = defaultProps;export default Link; 使用 React.createClass 时，方法顺序如下： displayName propTypes contextTypes childContextTypes mixins statics defaultProps getDefaultProps getInitialState getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render eslint rules: react&#x2F;sort-comp","tags":["ReactJS"]},{"title":"使用 React JS 的一些心得","path":"/2015/07/15/reactjs-idea/","content":"公司的某个项目二期前端使用了 ReactJS 库，略有心得，在此记录。望有缘人共同交流。 项目背景 本项目改造之前，前后端协作都是前端写页面 demo，后端写模版。缺点基本上有: 使用 jQuery 编写页面逻辑会涉及非常多 DOM 操作，尤其是写后台界面这种富交互的 web 应用时，费时费力； 前端页面和后端模版有许多重复工作； 效率低 前端的修改后端不一定能完全覆盖 后端要参与到视图层面的开发； 后端要等前端出 demo 才能进行模版编写&#x2F;修改。 改造前的项目是一个用 zepto（一个类似 jquery 的库）编写的单页面应用，流程只能从固定的入口进入，固定的出口离开（如同一个黑盒）。而新的需求要能直接到达其中某一步，因此决定将其拆分，由前端编写锚点路由进行流程的引导。 目录结构 改造后的目录结构如下（省略部分项目构建文件）： |- assets| |- css| |- img| |- fonts| |- lib||- scripts| |- build| |- components| |- views| |- 各模块文件夹| |- app.js||- index.html index.html 项目入口，除此之外没有其他 html 文件； assets 存放静态资源； build 存放工程化后的 js 代码，被 index 所引用； components 通用 react 组件 views 里面按业务模块分文件夹，存放了一系列的 react 组件，与 components 文件夹里的相比，只是通用和不通用； app.js 路由及各板块主脚本的引用。 由于是从一期项目改造，样式方面变化不大，而且项目比较紧急，因此 css 部分没有用预处理器重新编写，然而也并不是本篇文章的重点。 锚点路由 本项目中，路由的作用就是监视浏览器地址栏，根据预设的规则调用不同的 react 组件。比如地址是 /#/usercenter 就调用 &lt;UserCenter /&gt; 组件进行页面的渲染。为什么叫“锚点”路由？因为路由规则所监视的形如 /#/usercenter 的地址，就是用的浏览器锚点的功能，这样也是为了能使浏览器的“前进”“后退”这样的 location 操作可以生效，也避免了 SEO 无力的问题。 组件树 React 的一大特点就是组件化，组件内部的改变可以通过组件 state 的设置实现，父子组件之间的通讯由子组件的 props 实现。组件层层嵌套，形成一个类似 DOM 树一般的组件树。而数据在“树根”处通过 Ajax 获取，层层传递往“树梢”处“流动”。而与服务器的交互（典型的比如增删改查，由 ajax 实现）。 前后端分离 本次项目中，后端不再参与到表现方面的开发，可以专注于业务逻辑，通过合理的约定，前后端可以“异步”开发。许多人将 React 看作是 MVC 中的 V，我之前也是这么认为的。但实际上 React 遵循的并不是典型的 MVC 之道，甚至不太赞同 MVC。前后端分离近年来是业界热议的话题，React 的出现让人们看到了 MV* 以外的可能。 一些问题组件树间通讯 刚开始改写的时候，我是将一些关键数据写在 localStorage 中，供组件树间共用。但有从别的域名跳转至某棵“组件树”中这样的需求实现，而 localStorage 是不能在不同的域名间共享，因此作废，改为路由传递参数，也方便其他域名作跳转。但不同的路由规则所对应的组件是相对独立的，即有若干棵“组件树”。同一棵组件树内，组件间的通讯如上文所说，但组件树之间的通讯并不方便，暂时没发现比较符合 React 之道的方法，我个人是更希望一整个 web app 可以成为一棵庞大的“组件树”。 Flux&#x2F;Reflux 尝试过使用 Reflux + React 搭建框架，后来发现本项目中不是很有必要，可能是我对 Flux&#x2F;Reflux + React 的数据流模型理解不够深刻，有待学习。 目录结构 目录结构比较粗糙，可以根据前端工程化的原则进行适度的优化。 小结 ReactJS 入门不难，坑也不多，编写代码结构比较清晰，在移动端上兼容性良好（本项目只在移动端），据说性能比其他 JS 框架高出不少（主要是因为 Virtual DOM），开发体验也不错，不妨一试。","tags":["ReactJS"]},{"title":"通宵加班后的碎碎念","path":"/2015/06/02/work-out-all-night/","content":"公司步入上升轨道，项目一下子多起来，但是新人还没到位，因此我们这些元老们每个人身上的项目就多了。这不刚刚通宵搞项目，通宵之后还很精神也是醉了。 很多时候真是环境逼人成长，还没毕业的时候想着跟个高手学两年，结果毕业之后基本靠自学，一年后的现在是公司的前端负责人，要带实习生，是别人眼中的“高手”（虽然自己知道几斤几两）。就因为知道自己只有半桶水，才要努力去加水。 今年的目标已经实现了俩（macbook和全栈入门），正朝着第三个努力。 给我加油吧～（意思是请我吃饭） 成长的感觉真爽！和理想越来越近的感觉真棒！","tags":["工作"]},{"title":"SegmentFault D-Day 所思所想","path":"/2015/04/26/segmentfault-d-day-gz/","content":"昨天参加 SegmentFault Developer Day 活动，略有感悟，在此记录。 出发比较早，到的时候连接待的摊位都还没开始布置，给师弟师妹占位（其实前面两排几乎没人坐）。 首先是 SegmentFault 的 90 后创始人高阳致辞，关于他像不像 90 后的问题估计已经被人吐槽过无数次了。讲了一点关于创立 SegmentFault 的事情，创业不易啊，且行且珍惜。 高阳 第一位分享的是 UC 的张云龙，主题“前端工程”。介绍前端工程的前世今生，从蛮荒时代的少量文件到如今的大规模 web 应用，随着发展而衍生出的资源、性能、安全、测试、协作等问题，需要工程化的指导，最后提出一个分而治之的概念，和一个构想中的前端工程模型。组件化听得不少，但都是在页面上的代码组件化，分而治之概念是在目录结构中就达成组件化，方便维护和资源管理。而不是将静态资源、无联系的代码放在一起，久而久之项目越来越大维护成本越来越高。 第二位分享的是朱宏旭，介绍 WatchKit。其实更像是 WatchKit API 手册图文版配人工解说……目前 Apple Watch 的功能相对简单，给开发者开放的 API 也不多。自从 Apple Watch 发布以来一直被各路人士所吐槽，段子满天飞，就连小道消息也专门写了一篇《我为什么不想买 Apple Watch》。我觉得目前的 Apple Watch 确实比较鸡肋，不过才第一代嘛，还是可以给时间展望一下的，比如结合投影技术，比如结合 glass 等等，在 Apple Watch 的底子上发挥想象力，这个可以有，拭目以待吧。 第三位分享的是工作室 07 级的 demo 师兄杨德模，现在唯品会，主题是 hybrid。介绍 hybrid 这种模式以及遇到的坑。开发模式听得懂，具体问题听不懂。 杨德模 后面还有两位分享者，不过我撤了。之前看过有人做过《如何做一场受欢迎的技术分享》的分享，里面总结了几种常见的分享形式，最吸引人的是“介绍演进历程”，毕竟人人都喜欢听故事嘛，第一场和第三场分享就是这种形式，还是能起到调动观众情绪作用的。 两次来 UC 参加分享会都有所收获，真是个福地。","tags":["分享会"]},{"title":"（译）异步加载 CSS 资源","path":"/2015/04/21/loading-css-without-blocking render/","content":"本文由小智根据 Keith Clark 的 《Loading CSS without blocking render》所译。译文带有我自己的理解和思想，如需转载请注明相关信息： 原文地址：http://keithclark.co.uk/articles/loading-css-without-blocking-render/——作者：Keith Clark——译者：小智 本文演示如何在阻塞页面渲染之前通过异步加载尽快于用户前获取资源。 警告！我发出这篇文章后，迅速收到大量的社区反馈而且明显地这个技巧没有我想象中的好用。我自己测试以及在项目中使用都是成功的，但是许多开发者在 IE 和 Firefox 中发现问题（据说导致 Firefox beta 崩溃），另外一些开发者则报告 Chrome 和 Safari 中成功。 这些技巧背后的原则并不新，比如 Filament group 早已就载入 CSS 和字体写过很棒的文章。我写这篇文章为了记录我关于非阻塞加载资源的一些思考。 触发样式表异步加载的技巧是使用 &lt;link&gt; 标签并且给 media 属性设置无效值（我用 media=&quot;none&quot;，但任何值都可以）。当一条媒体查询为 false 时，浏览器会加载样式表，但其中的资源则不会，直到需要用于渲染页面。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot; media=&quot;none&quot;&gt; 一旦样式表加载完成，media 属性必须改设有效值以使其样式应用到页面中。onload 事件就是用来将 media 属性的值切换至 all的： &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot; media=&quot;none&quot; onload=&quot;if(media!=&#39;all&#39;)media=&#39;all&#39;&quot;&gt; 这种加载 CSS 的方法载入有用资源的速度会比一般方法迅速得多。关键的 CSS 仍能通过通常的阻塞载入路径（或者对于个别样式写成行内式），非关键 CSS 能渐进地下载并稍晚应用于浏览器分析渲染。 这个技巧用到 JavaScript，但对于禁用了 JS 的浏览器也能通过 &lt;noscript&gt; 标签载入 &lt;link&gt;。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot; media=&quot;none&quot; onload=&quot;if(media!=&#39;all&#39;)media=&#39;all&#39;&quot;&gt; &lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot;&gt;&lt;/noscript&gt; 下面是这个技巧的副作用。一旦非阻塞样式表加载完成，文档将会重新渲染以响应相关的新规则。插入新样式到页面中会触发内容重排，但仅会是首次页面加载没有缓存时才会出现的状况。你需要自行判断何时控制重排，何时加快速度。 使用非阻塞 CSS 加载字体字体是页面首次渲染时的大问题，它是阻塞型资源，下载时会使内容无法呈现。使用如上所示的非阻塞链接，能在背后下载包含字体数据的样式表，而不阻塞页面渲染。 &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;font.css&quot; media=&quot;none&quot; onload=&quot;if(media!=&#39;all&#39;)media=&#39;all&#39;&quot;&gt; font.css 包含了 Merriweather 字体的 base64 编码 WOFF 版本。 @font-face &#123; font-family: Merriweather; font-style: normal; font-weight: 400; src: local(&#39;Merriweather&#39;), url(&#39;data:application/x-font-woff;charset=utf-8;base64,...&#39;) &#125; main.css 包含了网站的所有样式，这里是关于字体的声明。 body &#123; font-family: Merriweather, &quot;Lucida Grande&quot;, ...; &#125; 当字体正在下载时，第一个符合的回调字体（本例中是 Lucinda Granda）会被用于渲染页面内容。一旦字体样式表加载好后，将转而使用 Merriweather。我尝试使用与所需字体样式相近的回调字体，从而使不可避免的重排影响最小。 我在 Chrome 中用我的谷歌分析工具（https://keithclark.github.io/gadebugger/）模拟 3G 环境测试阻塞和非阻塞两种方法。本地测试结果如下图所示，可以发现使用非阻塞方法时 DOMContentLoaded 事件早触发 450ms，而且静态资源也更早开始加载。 模拟 3G 网络的示意图，上面是阻塞方法，下面是非阻塞方法。 在服务器上测试，使用 webpagetest（http://www.webpagetest.org/）模拟 3G 环境的示意图如下： 上面是阻塞方法，下面是非阻塞方法。 两种方法都要用 2.8 秒来完全呈现页面，但是非阻塞方法中早一秒开始渲染。对于主样式表也进行了测试。 上面是阻塞方法，下面是非阻塞方法。 对于字体，这个技巧使用良好，但我建议留意新的 CSS 字体加载模块（http://dev.w3.org/csswg/css-font-loading/），有非常好的字体加载控制。 总结加载字体只是非阻塞技巧的其中一个例子，这个技巧也能用于其他地方，比如从核心 CSS 中分离出针对 JavaScript 加强的样式。 我已经开始试验将 CSS 拆分成结构类（核心布局）和表现类（其他样式），让页面基础布局先渲染，而视觉样式稍后。 2015-04-01 更新 本方法不适用低于 4.4 版本的安卓系统，onload 回调并没有触发。 有些浏览器会像阻塞方法一样加载 media=&quot;none&quot; 的样式表，这意味着与平时一样渲染页面。","tags":["css","js"]},{"title":"（译）如何使用HTML5章节标签","path":"/2015/03/03/how-to-use-the-html5-sectioning-elements/","content":"本文由小智根据 Matt West 的 《How to Use The HTML5 Sectioning Elements》所译。译文带有我自己的理解和思想，如需转载请注明相关信息： 原文地址：http://blog.teamtreehouse.com/use-html5-sectioning-elements——作者：Matt West——译者：小智 HTML5 已经出现了许多可以用来标记网页的章节标签。使用这些元素能让你的页面更加“语义化”，让计算机程序能更好地读懂你的内容。 你可以从这篇文章中学到如何在你的网站中运用这些章节元素。我会解释为何用某个元素而不是另外一些，或者什么时候应该坚持使用经典的 &lt;div&gt;。 走起！ main 元素&lt;main&gt; 元素应当包含网页中的主要内容。所有的这些内容都应该是独立页面中特有的，也不应出现在网站的其他地方。任何在复数页面中出现的内容（如logo、搜索框、底部链接等）都不应放置在 &lt;main&gt; 元素中。 下面的例子用 &lt;main&gt; 元素来代表页面的主要内容。 &lt;body&gt; &lt;header&gt; &lt;div id=&quot;logo&quot;&gt;Rocking Stone&lt;/div&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;/header&gt; &lt;main role=&quot;main&quot;&gt; &lt;h1&gt;Guitars&lt;/h1&gt; &lt;p&gt;The greatest guitars ever built.&lt;/p&gt; &lt;article&gt; &lt;h2&gt;Gibson SG&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;Fender Telecaster&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/article&gt; &lt;/main&gt; &lt;/body&gt; 注意：这里我们使用 ARIA role=&quot;main&quot; 属性，因为这能告诉不支持 &lt;main&gt; 元素的程序（比如某些屏幕阅读软件），这个标签是什么意义。 你只应在一个页面中使用一个 &lt;main&gt; 元素，而且不能用 &lt;article&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt; 或者 &lt;nav&gt; 元素替代。 article 元素&lt;article&gt; 元素应该包括一段即使脱离页面语境也能独立的内容，比如新闻、博客文章或者用户评论。 &lt;article&gt; &lt;header&gt; &lt;h1&gt;Blog Post Title&lt;/h1&gt; &lt;p&gt;Posted 13th February 2014&lt;/p&gt; &lt;/header&gt; &lt;p&gt; ... &lt;/p&gt; &lt;/article&gt; 你可以在一个 &lt;article&gt; 元素中嵌套另一个。这就暗示着嵌套的 &lt;article&gt; 元素与外层的有关联。 &lt;article&gt; &lt;header&gt; &lt;h1&gt;Blog Post Title&lt;/h1&gt; &lt;p&gt;Posted 13th February 2014&lt;/p&gt; &lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;section&gt; &lt;h2&gt;Comments&lt;/h2&gt; &lt;article&gt; &lt;footer&gt; &lt;p&gt;Posted by: Joe Balochio&lt;/p&gt; &lt;/footer&gt; &lt;p&gt;This was a great article&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;footer&gt; &lt;p&gt;Posted by: Casey Brock&lt;/p&gt; &lt;/footer&gt; &lt;p&gt;How do you think this applies to the plan for world domination?&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;/article&gt; 本例中我们用 &lt;article&gt; 元素来标记博客文章以及每条评论。这种嵌套结构表示这些评论与这篇博客文章的主题有关。 section 元素&lt;section&gt; 用来表示一组相关联的内容。这很像 &lt;article&gt; 元素，主要的区别是 &lt;section&gt; 元素不必在脱离页面语境时也要有意义。 建议用标题元素（&lt;h1&gt; - &lt;h6&gt;）来定义 section 的主题。 就用这篇文章为例，用 &lt;section&gt; 元素来代表文章中每个独立的部分。 &lt;article&gt; &lt;h1&gt;How to use HTML5 Sectioning Elements&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;section&gt; &lt;h2&gt;The &lt;main&gt; Element&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;The &lt;article&gt; Element&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;The &lt;section&gt; Element&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;/section&gt; ... &lt;/article&gt; 这里我们用 &lt;article&gt; 元素来总括整篇文章，然后用几个 &lt;section&gt; 元素来包裹文章中讨论的每个小主题。 如果你仅仅是想包裹住一些内容来赋予样式，你应该用 &lt;div&gt; 元素而不是 &lt;section&gt;。 nav 元素&lt;nav&gt; 元素用来标记一系列导向外部页面或者当前页面某个锚点的链接，也会用作站点的主导航、文章的目录或者博客列表。 &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#chapter-one&quot;&gt;Chapter One&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;#chapter-two&quot;&gt;Chapter Two&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;#chapter-three&quot;&gt;Chapter Three&lt;/a&gt; &lt;/ul&gt; &lt;/nav&gt; 用列表来标记链接会让你的导航更易用，但这不是必须的。 aside 元素&lt;aside&gt; 元素表示与主内容相关却相对独立的内容。包括侧边栏（就像书中那些）、&lt;nav&gt; 元素组、插图和醒目的引文。 &lt;article&gt; &lt;header&gt; &lt;h1&gt;Google Buys Nest&lt;/h1&gt; &lt;p&gt;Posted at 11:34am 13th January 2014&lt;/p&gt; &lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;Google (GOOG)&lt;/h1&gt; &lt;p&gt;Google was founded in 1998 by Larry Page and Sergey Brin. The company...&lt;/p&gt; &lt;/aside&gt; &lt;/article&gt; 我们在一篇新闻中使用 &lt;aside&gt; 元素来标记 Google 的信息。&lt;aside&gt; 中的公司信息可认为是对读者有用的，但不是与新闻直接相关。 header 元素&lt;header&gt; 元素用于呈现文章或网页的介绍性内容。通常包含标题元素以及与内容相关的元数据比如新闻的发表日期。也可以包含长文档的目录（使用 &lt;nav&gt; 元素）。 &lt;header&gt; 元素会与最近的章节元素相关联，通常是页面结构中的父元素。 &lt;header&gt; &lt;h1&gt;Google buys Nest&lt;/h1&gt; &lt;p&gt;Posted at 11:34am 13th January 2014&lt;/p&gt; &lt;/header&gt; 本例是 &lt;header&gt; 元素带有新闻的标题和发表日期。 footer 元素&lt;footer&gt; 元素用于呈现作者、版权、相关链接等信息。 &lt;footer&gt; Copyright Matt West 2014 &lt;/footer&gt; As with &lt;header&gt;, the &lt;footer&gt; element is associated with the nearest sectioning element. 如同 &lt;header&gt;，&lt;footer&gt; 元素会与最近的章节元素相关联。 address 元素&lt;address&gt; 元素是其中一个最被误解的 HTML 元素。这个元素不是用来标记邮件地址，而是用来呈现文章或网页的联系信息。可以是通向作者网站的链接或者他们的电子邮件地址。 &lt;address&gt; Contact &lt;a href=&quot;mailto:matt@example.com&quot;&gt;Matt West&lt;/a&gt; &lt;/address&gt; This element is often used within the &lt;footer&gt; for an &lt;article&gt;. 这个元素经常用在 &lt;article&gt; 的 &lt;footer&gt; 中。 &lt;article&gt; &lt;header&gt; &lt;h1&gt;Google buys Nest&lt;/h1&gt; &lt;p&gt;Posted at 11:34am 13th January 2014&lt;/p&gt; &lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;footer&gt; &lt;address&gt; By &lt;a href=&quot;mailto:matt@example.com&quot;&gt;Matt West&lt;/a&gt; &lt;/address&gt; &lt;p&gt;Copyright Matt West 2014&lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; 关于章节元素的一些想法在文中你能学到在标记网页时如何使用 HTML5 章节元素。使用这些元素有很多好处。最大的好处就是让你的网页区域划分更加语义化，让计算机程序识别关键元素（比如主内容和页面导航）。这些信息对屏幕阅读器之类的应用非常有用。 注意：不是所有的屏幕阅读器都支持这些语义化的元素。你或许想继续使用 ARIA 以防万一（回复“aria”或者“20141010”可查看小智以前翻译的一篇关于“ARIA”的文章）。 使用这些章节元素也让开发者们更多地思考他们网页的结构。针对一段内容，对元素的选择不总是明显的，但让人更多地思考内容的意义。这是网络标准不仅提升标记语言质量，还整体上提升网页质量的例子。","tags":["html"]},{"title":"（译）CSS Guidelines (3)","path":"/2015/02/08/css-guidelines_3/","content":"注释编写 CSS 之前的认知工作是非常巨大的。有很多事情要注意，不同项目中有很多细微的差别要记住，最糟糕的情况是大部分开发者发现他们“不是写这代码的人”。在一定程度上记忆你自己写的类名、规则、对象、辅助方法是可行的，但接受 CSS 的开发者则不然。 CSS 需要更多的注释。 CSS 是一种不会留下太多痕迹的声明式语言，但看 CSS 通常很难辨别： 一段 CSS 是否与其他地方的代码相关联； 一段 CSS 修改了其它地方会有什么影响； 有没有别的 CSS 会用到； 有何样式会被继承（有意无意的）； 有何样式会被忽略（有意无意的）； 某段 CSS 作者计划用在何处。 我们甚至无需重视一些会让接手项目的开发者更棘手的诡异地方（比如 overflow 会触发 BFC，或者某些 transform 属性会触发硬件加速）。 由于 CSS 没有将自己的特性表述清楚，因此需要大量的注释。 一条规则是，你应该在任何有不直接明显信息的代码处写注释。意思是说，没必要告诉别人 color: red; 是用来变红的，但如果你用 overflow: hidden; 来清除浮动（和闭合浮动相对），这可能是值得记入文档的。 高级我们用一块80字符宽的多行注释来为整个小节或组件写注释。 这是一个真实的例子，CSS Wizardry 的页头样式注释： /** * The site’s main page-head can have two different states: * * 1) Regular page-head with no backgrounds or extra treatments; it just * contains the logo and nav. * 2) A masthead that has a fluid-height (becoming fixed after a certain point) * which has a large background image, and some supporting text. * * The regular page-head is incredibly simple, but the masthead version has some * slightly intermingled dependency with the wrapper that lives inside it. */ 这种级别的细节应是对规定、序列、条件、处理方案等进行代码描述的样板。 对象扩展指针 （Objective-Extension Pointers）当你要维护众多的模块，或者应用 OOCSS 的概念，你会发现相关联的 CSS 规则不总是在同一个文件或位置。例如，你会有一个按钮类的对象（纯粹提供结构样式），在皮肤组件部分中会有所扩展。我们用简单的对象扩展指针来记录这些跨文件的关系。在对象文件中： /** * Extend `.btn &#123;&#125;` in _components.buttons.scss. */ .btn &#123;&#125; 在主题文件中： /** * These rules extend `.btn &#123;&#125;` in _objects.buttons.scss. */ .btn--positive &#123;&#125; .btn--negative &#123;&#125; 这种简单的注释能极大地方便那些不知道项目间关系，或者想知道样式是如何、为何、从何继承的开发者。 低级（Low-level）很多时候我们想对一条规则中的多条声明进行注释。我们用一种颠倒的脚注。下面是一段更复杂的关于生面说到的网站头的注释。 /** * Large site headers act more like mastheads. They have a faux-fluid-height * which is controlled by the wrapping element inside it. * * 1. Mastheads will typically have dark backgrounds, so we need to make sure * the contrast is okay. This value is subject to change as the background * image changes. * 2. We need to delegate a lot of the masthead’s layout to its wrapper element * rather than the masthead itself: it is to this wrapper that most things * are positioned. * 3. The wrapper needs positioning context for us to lay our nav and masthead * text in. * 4. Faux-fluid-height technique: simply create the illusion of fluid height by * creating space via a percentage padding, and then position everything over * the top of that. This percentage gives us a 16:9 ratio. * 5. When the viewport is at 758px wide, our 16:9 ratio means that the masthead * is currently rendered at 480px high. Let’s… * 6. …seamlessly snip off the fluid feature at this height, and… * 7. …fix the height at 480px. This means that we should see no jumps in height * as the masthead moves from fluid to fixed. This actual value takes into * account the padding and the top border on the header itself. */ .page-head--masthead &#123; margin-bottom: 0; background: url(/img/css/masthead.jpg) center center #2e2620; @include vendor(background-size, cover); color: $color-masthead; /* [1] */ border-top-color: $color-masthead; border-bottom-width: 0; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1) inset; @include media-query(lap-and-up) &#123; background-image: url(/img/css/masthead-medium.jpg); &#125; @include media-query(desk) &#123; background-image: url(/img/css/masthead-large.jpg); &#125; &gt; .wrapper &#123; /* [2] */ position: relative; /* [3] */ padding-top: 56.25%; /* [4] */ @media screen and (min-width: 758px) &#123; /* [5] */ padding-top: 0; /* [6] */ height: $header-max-height - double($spacing-unit) - $header-border-width; /* [7] */ &#125; &#125; &#125; 这类注释允许我们将所有的文档写到一起，并且指向各自标注的地方。 预处理注释在大部分的预处理程序中，我们可以通过配置项使注释不会在编译时被省略掉。用这种注释来记录不需被省略的代码。如果有些代码要在编译时被省略则使用会被省略的注释。例如： // Dimensions of the @2x image sprite: $sprite-width: 920px; $sprite-height: 212px; /** * 1. Default icon size is 16px. * 2. Squash down the retina sprite to display at the correct size. */ .sprite &#123; width: 16px; /* [1] */ height: 16px; /* [1] */ background-image: url(/img/sprites/main.png); background-size: ($sprite-width / 2 ) ($sprite-height / 2); /* [2] */ &#125; 我们用预处理注释来记录变量（这些代码不会被写进 CSS 文件），而 CSS 则使用 CSS 注释。这意味着当我们 debug 样式表的时候只有正确的相关联的信息。 删除注释产品环境中应该没有注释，发布前所有的 CSS 都经过压缩。","tags":["css"]},{"title":"（译）CSS Guidelines (2)","path":"/2015/02/05/css-guidelines_2/","content":"语法及格式样式指导的一种最简单的形式是关于语法和格式的一系列规则。以标准方法书写 CSS 意味着对于团队的所有成员来说代码看起来总是很熟悉。 另外，整洁的代码让人感觉清爽。这是个更容易投入工作的环境，促进其他团队成员去维持他们发现的整洁代码标准。丑陋的代码则会造成糟糕的先例。 代码分割伴随着最近急速发展的预处理器，开发者通常将 CSS 分割成若干文件。 尽管不使用预处理器，将不关联的代码快分割到独立的文件中也不失为一个好方法，在构建这一步中会重新拼凑起来。 出于某些原因，如果你不希望代码分割，那么下一节内容可能需要做些调整来满足你的设置。 目录目录是需要经常维护管理的，但由此带来的好处大大超出其代价。目录需要一位勤奋的开发者去持续更新，但这很值得。一个最新的目录能让团队知道 CSS 项目里有什么、做什么、按什么顺序排列。 一个简单的目录会（按顺序）列出小节的名字以及简要描述，例如： 123456789101112131415161718192021222324252627/** * CONTENTS * * SETTINGS * Global.................Globally-available variables and config. * * TOOLS * Mixins.................Useful mixins. * * GENERIC * Normalize.css..........A level playing field. * Box-sizing.............Better default &#x27;box-sizing&#x27;. * * BASE * Headings...............H1-H6 styles. * * OBJECTS * Wrappers...............Wrapping and constraining elements. * * COMPONENTS * Page-head..............The main page header. * Page-foot..............The main page footer. * Buttons................Button elements. * * TRUMPS * Text...................Text helpers. */ 每一项对应一小节及&#x2F;或其内容。 当然，多数项目中这些小节会非常庞大，但我们可以看到这些小结给开发者们提供了一个纵观全局的概览（在主样式表），可以看到哪里写了什么，为什么这么写。 80字符宽度可以的话，将 CSS 文件的宽度限制在80个字符内，原因如下： 能并排打开多个文件； 在线（如 Github）或终端中查看 CSS； 这种长度的注释看起来更舒服。 12345/** * I am a long-form comment. I describe, in detail, the CSS that follows. I am * such a long comment that I easily break the 80 character limit, so I am * broken across several lines. */ 有些不可避免的例外，比如 URL，或者渐变语法，这些都不必担心。 标题在 CSS 里每个主要部分之前都写一个标题： 12345/*------------------------------------*\\ #SECTION-TITLE\\*------------------------------------*/.selector &#123;&#125; 标题加上一个 # 前缀让我们搜索的时候更容易命中，单纯搜索标题可能会有很多结果。 在标题和代码（另一段注释、Sass 或 CSS）之间留一个空行。 如果每一小节代码在不同的文件中，标题应该出现在文件的最上面。如果一个文件中含有多个小节，则每个标题上面都应该有5个空行。这样当在大文件中快速下拉时能迅速分辨出不同的小节。 12345678910111213141516171819/*------------------------------------*\\ #A-SECTION\\*------------------------------------*/.selector &#123;&#125;/*------------------------------------*\\ #ANOTHER-SECTION\\*------------------------------------*//*** Comment*/.another-selector &#123;&#125; 规则的结构在讨论怎样写我们的规则之前，先来熟悉一下相关的术语： 1234[selector] &#123; [property]: [value]; [&lt;--declaration---&gt;]&#125; 比如： 123456.foo, .foo--bar,.baz &#123; display: block; background-color: green; color: red;&#125; 这里我们可以看到： 相关的选择器在同一行，不相关的选择器再另一行； 花括号（{）之前有个空格； 属性和值在同一行； 冒号（:）之后有个空格； 每条声明独立一行； 花括号（{）与最后一个选择器在同一行； 第一条声明在花括号（{）的下一行； 花括号（}）独立一行； 每条声明有4个空格的缩进； 最后一条声明后面也有分号（;）。 这种格式似乎是比较通用的标准（除了缩进的空格数，很多开发者倾向于2个空格）。 因此，下面的代码是不正确的： 12345.foo, .foo--bar, .baz&#123;display:block;background-color:green;color:red &#125; 这里的问题有： tab 缩进而不是空格缩进； 无关的选择器在同一行； 花括号（{）独立一行； 花括号（}）没有独立一行； 最后一个分号（;）缺失； 冒号（:）后面没有空格。 多行 CSSCSS 应该分成多行书写，特别是在某些特定的环境下。这样会有很多好处： 代码合并时冲突的概率降低，因为每一条功能独立一行； 更“真实”可靠的文件比较，因为每一行只有一个变化。 这条规则的特例显而易见，比如只有一条声明的相似规则： 1234567891011.icon &#123; display: inline-block; width: 16px; height: 16px; background-image: url(/img/sprite.svg);&#125;.icon--home &#123; background-position: 0 0 ; &#125;.icon--person &#123; background-position: -16px 0 ; &#125;.icon--files &#123; background-position: 0 -16px; &#125;.icon--settings &#123; background-position: -16px -16px; &#125; 这种规则比单行写法更好，因为： 依然服从“一个改变一行”的原则； 这几行代码有足够的相似度，因为阅读它们不像阅读其他代码那样仔细，更容易看到它们的选择器，这是我们更感兴趣的。 缩进就像突出独立声明一样，将关联的规则通过缩进来展现其相关性，例如： 12345.foo &#123;&#125;\t.foo__bar &#123;&#125; .foo__baz &#123;&#125; 这样做，开发者一看就能知道 .foo__baz &#123;&#125; 在 .foo__bar &#123;&#125; 里，而 .foo__bar &#123;&#125; 又在 .foo &#123;&#125; 里。 这种像 DOM 折叠结构的写法告诉开发者们这些类应当在哪里使用，而不必回头去看 HTML。 Sass缩进Sass 支持嵌套，如： 12345678.foo &#123;\tcolor: red;\t.bar &#123; color: blue;\t&#125;&#125; 编译后的 CSS： 12.foo &#123; color: red; &#125;.foo .bar &#123; color: blue; &#125; 书写 Sass 的缩进时，我们仍坚持4个空格，我们也会在每个嵌套的前后各加一个空行。 对齐试着将声明内一些共有的、关联的字符串对齐，比如： 1234567891011121314151617.foo &#123;\t-webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;.bar &#123;\tposition: absolute;\ttop: 0;\tright: 0;\tbottom: 0;\tleft: 0;\tmargin-right: -10px;\tmargin-left: -10px;\tpadding-right: 10px;\tpadding-left: 10px;&#125; 使用能支持多光标编辑的编辑器会更轻松，开发者们可以一次修改若干相同而对齐的代码行。 有意义的空行好比缩进，我们可以巧妙地利用规则间的空行来呈现许多信息，比如： 紧密关联的规则之间空1行； 不紧密关联的规则之间空2行； 小节之间空5行。 例如： 123456789101112131415161718192021222324/*------------------------------------*\\#FOO\\*------------------------------------*/.foo &#123;&#125;\t.foo__bar &#123;&#125;\t.foo--baz &#123;&#125;/*------------------------------------*\\#BAR\\*------------------------------------*/.bar &#123;&#125;\t.bar__baz &#123;&#125;\t.bar__foo &#123;&#125; 千万不要在两条规则之间不留空，这是不正确的： 123.foo &#123;&#125;\t.foo__bar &#123;&#125;.foo--baz &#123;&#125; HTML基于 HTML 和 CSS 相互关联的天性，我若是不谈谈标记语言的语法和格式指导这说不过去。 将属性值用引号包裹，尽管没有引号也能工作。这能减少意外的可能性，也是大部分开发者惯用的格式。下面的写法能工作（也是有效的）： 1&lt;div class=box&gt; 更倾向于这种： 1&lt;div class=&quot;box&quot;&gt; 这里要求写引号， 当 class 属性里有多个值时，用2个空格隔开： 1&lt;div class=&quot;foo bar&quot;&gt; 当多个 class 之间有关联，用方括号（[ 和 ]）包裹，就像这样： 1&lt;div class=&quot;[ box box--highlight ] [ bio bio--long ]&quot;&gt; 这一条不是强烈推荐，并且我也不太肯定，但确实带来了不少好处。详见《在标记语言中给相关的类分组》。 如同我们的规则，在 HTML 中使用有意义的空行也是可能的。你可以用5个空行表示主题间的隔断，例如： 12345678910111213141516171819&lt;header class=&quot;page-head&quot;&gt; ...&lt;/header&gt;&lt;main class=&quot;page-content&quot;&gt; ...&lt;/main&gt;&lt;footer class=&quot;page-foot&quot;&gt; ...&lt;/footer&gt; 用1个空行将独立却稍有关联的片段隔开，例如： 123456789101112131415161718192021&lt;ul class=&quot;primary-nav&quot;&gt;\t&lt;li class=&quot;primary-nav__item&quot;&gt; &lt;a href=&quot;/&quot; class=&quot;primary-nav__link&quot;&gt;Home&lt;/a&gt;\t&lt;/li&gt;\t&lt;li class=&quot;primary-nav__item primary-nav__trigger&quot;&gt; &lt;a href=&quot;/about&quot; class=&quot;primary-nav__link&quot;&gt;About&lt;/a&gt; &lt;ul class=&quot;primary-nav__sub-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/about/products&quot;&gt;Products&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about/company&quot;&gt;Company&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;\t&lt;/li&gt;\t&lt;li class=&quot;primary-nav__item&quot;&gt; &lt;a href=&quot;/contact&quot; class=&quot;primary-nav__link&quot;&gt;Contact&lt;/a&gt;\t&lt;/li&gt;&lt;/ul&gt; 这让开发者一眼就能看出 DOM 结构中的不同部分，同时也能让某些编辑器（如 Vim）去处理空行分界的代码区域。 深度阅读 《在标记语言中给相关的类分组》","tags":["css"]},{"title":"（译）CSS Guidelines (1)","path":"/2015/02/04/css-guidelines_1/","content":"一、介绍CSS 不是一门优美的语言。尽管入门容易，但在任何合理的规模下都会产生问题。对于 CSS 的工作方式我们无法改变什么，但我们可以改变编写和构建 CSS 的方法。 当进行大规模、长周期的项目时，许多不同专长和能力的开发者一起工作，我们需要以统一的方式协作以达成以下目标： 保持样式表可维护； 保持代码透明、稳健、合理； 保持样式表的可拓展性。 为了达成以上目标我们需要应用许多技巧，本篇《CSS 指导》正是这些建议和方法的集合文档。 1.1 样式指导的重要性编码样式指导（注意，不是视觉样式指导）是对以下队伍有用的工具： 在一个合理的时间长度内建设及维护产品； 有不同能力和专长的开发者； 在任何给定的时间内都有一定数量的开发者在开发产品； 定期有新员工加入； 有一定数量可供开发者贡献和使用的代码库。 同时样式指导是对产品队伍——基于长生命周期且不断进化的项目的庞大代码库，长期有大量开发者为此贡献代码——所有开发者都应努力在代码中实现高度的标准化。 一个良好的样式指导将： 为代码库设定代码质量的标准； 促进代码库的一致性； 在整个代码库中给开发者以熟悉感； 提高生产力。 1.2 声明《CSS 指导》是一篇样式指导，而不是唯一的样式标准。包含了我会向客户和团队推荐的方法论、技巧以及提示，但你自己的品味和环境可能大不相同。效果可能不一样。 这些指导是可选的，但它们都在多年大大小小的项目中被屡次尝试、测试、施压、改善、废弃、重写以及重现。","tags":["css"]},{"title":"（译）CSS Guidelines (0)","path":"/2015/02/01/css-guidelines_0/","content":"本文由小智根据 Harry Roberts 的 《CSS Guidelines》所译。译文带有我自己的理解和思想，如需转载请注明相关信息： 原文地址：http://cssguidelin.es/——作者：Harry Roberts——译者：小智 译者的话最好还是阅读原文，因为译文毕竟经过译者的再加工，受限于译者的英语水平和国语水平，或许原作者的意思不能完全理解，理解的部分书写出来也可能辞不达意。 重要说明 原文中 rule 指作者行文中的一些条目，而 ruleset 指 CSS 规则，文中暂时都翻译为“规则”，可能会造成一些表达上的误会，如果想到更合适的词语会替换； 欢迎各位指点。 前言 编写稳健、可管理、可拓展 CSS 的高级指导。 关于作者Harry Roberts 支持捐助请到原文中查找。 目录 介绍 样式指导的重要性 声明 语法及格式 代码分割 目录 80个字宽 标题 规则的结构 多行 CSS 缩进1. Sass 缩进2. 对齐 有意义的空行 HTML 注释 高级1. 对象扩展指针 低级 Proprocessor Comments Removing Comments 命名规则 Hyphen Delimited BEM-like Naming1. Starting Context2. More Layers3. Modifying Elements HTML 命名规则 JavaScript 钩子1. data-* 属性 Taking It Further CSS 选择器 Selector Intent 重用性 Location Independence Portability1. Quasi-Qualified Selectors 命名1. UI 组件命名 Selector Performance1. The Key Selector General Rules 特殊性 ID 选择器 Nesting !important Hacking Specificity 工程化原则 High-level Overview Object-orientation The Single Responsibility Principle The Open&#x2F;Closed Principle DRY Composition over Inheritance The Separation of Concerns1. Misconceptions","tags":["css"]},{"title":"CSS 计数器（下）","path":"/2015/01/23/css-counter_2/","content":"摘要技术文，不想细看可直接跳至最后的总结部分。 承接上篇《CSS 计数器（上）》，回复“20141123”、“CSS计数器”、“CSS”可查看。 上篇我们了解了 CSS 计数器的三个关键点，本篇我们来了解 CSS 计数器的用途。 计数器既然名为“CSS 计数器”，那么最基本的应用就是计数器了。 计数器1// css section.characters &#123;counter-reset: characters;&#125; section.characters input:checked &#123;counter-increment: characters;&#125; section.total1:after &#123;content: counter(characters);&#125; // 结构和样式代码就省略了，这里只写计数器相关代码，下同 效果： 什么都没选择时： 选择两个： 选择四个： 计数器2// css .container-2 &#123;counter-reset: sections boxes;&#125; .container-2 section &#123;counter-increment: sections;&#125; .container-2 section::before &#123;content: &#39;Section &#39; counter(sections);&#125; .container-2 .box &#123;counter-increment: boxes;&#125; .container-2 .box::before &#123;content: counter(boxes, upper-roman);&#125; 效果： 求和改变每个 counter-increment 的值（默认1）可以实现求和的功能。 section &#123;counter-reset: sum;&#125; .a:checked &#123;counter-increment: sum 64;&#125; .b:checked &#123;counter-increment: sum 16;&#125; .c:checked &#123;counter-increment: sum -32;&#125; .d:checked &#123;counter-increment: sum 128;&#125; .e:checked &#123;counter-increment: sum 4;&#125; .f:checked &#123;counter-increment: sum -8;&#125; .sum::before &#123;content: &#39;=&#39; counter(sum);&#125; 效果： 未选中： 16 &#x3D; 16： 16 - 32 + 4 &#x3D; -12： 总结CSS 计数器有时候确实会带来一些便利，但是为什么诞生这么多年来几乎无人问津？ 业界中种种模式都尝试让开发中的各种角色职责更清晰，分工更合理高效，比如前后端分离，甚至前端之中就会按“MVC”、“MV*”等原则分割，每一部分下面又再细分。而 CSS 计数器的工作方式则刚好相反，负责视图的 CSS 越权把本应由脚本语言做的控制也做了。 比如上面的求和 demo，把数据放到了 css 里面。 总而言之，CSS 计数器是一项有趣的技术，但使用场景有限且有时会造成开发职责混乱，比较鸡肋。 其他思考有时语言并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，这些设计思想其实挺有意思。","tags":["css"]},{"title":"CSS 计数器（上）","path":"/2014/11/23/css-counter_1/","content":"摘要CSS 计数器，古老而又冷门的技术。 简介CSS 计数器不是什么新鲜玩意，早在小智上大学之前就已经出现了，只是比较冷门，开发中不常用到，但是随着 CSS 3 的支持日益增强，结合 CSS 3 的一些新特性，或许 CSS 计数器会迸发出不一样的光芒。 兼容性CSS 计数器只能跟 content 属性一起使用，而 content 属性只用于 :before &#x2F; :after 伪元素上，因此IE6、7不支持 CSS 计数器，而其他浏览器支持良好，见下图： 技术要点CSS 计数器的关键是两个属性一个方法。 counter-reset counter-increment counter() &#x2F; counters() counter-reset 定义计数器的名字，文档流中需要出现在 counter-increment 之前，建议 counter-reset 所在元素为另外两个所在元素的父（祖）元素，原因见 counters() 部分。 counter-increment 使计数器累加。 counter() &#x2F; counters()，输出计数器当前值。 计数规则计数器当前值是指，counter-reset 和 counter() 之间，每出现一个 counter-increment 累加一次，counter() 后面的与此 counter() 无关。请看下面的例子。 /* css */ .container &#123;counter-reset: sum;&#125; /* 定义计数器 */ .item &#123;counter-increment: sum;&#125; /* 累加规则 */ .monitor:after &#123;content: counter(sum);&#125; /* 显示计数器当前值 */ &nbsp; &lt;!-- html --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 当前值：0 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 当前值：1 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 当前值：2 --&gt; &lt;div class=&quot;monitor&quot;&gt;&lt;/div&gt; &lt;!-- 输出：2 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 当前值：3 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 当前值：4 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 当前值：5 --&gt; &lt;div class=&quot;monitor&quot;&gt;&lt;/div&gt; &lt;!-- 输出：5 --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;!-- 与前面的 counter() 无关 --&gt; &lt;/div&gt; counter-resetcounter-reset 的格式如下： //css counter-reset: name1 [start1 name2 start2 ... ]; // 中括号里的代码可选（下同） name 定义的计数器名； start 计数器的起始值，默认为0； 可同时定义多个计数器，中间用空格隔开。 counter-incrementcounter-increment 的格式如下： // css counter-increment: name1 [step1 name2 step2]; name 对指定的计数器进行累加； step 每次累加的数值，可为负数； 可同时对多个计数器进行累加，中间用空格隔开。 counter() &#x2F; counters()counter()counter() 的格式如下： // css content: counter(name1[, style1]) [counter(name2, style2)] name 显示指定计数器的当前值； style 值的显示样式，与 list-style-type 的取值一样，见下文； 可同时显示多个计数器的当前值，中间用空格隔开。 list-style-type：disc | circle | square | decimal | lower-roman | upper-roman | lower-alpha | upper-alpha | none | armenian | cjk-ideographic | georgian | lower-greek | hebrew | hiragana | hiragana-iroha | katakana | katakana-iroha | lower-latin | upper-latin counters() 多了一个“s”，但是效果却大相径庭，counters()是表示嵌套计数，比如“1.1”，格式如下： // css content: counters(name1, string1[, style1]) [counters(name2, string2, style2)] name 和 style 与 counter() 中相同，不再重复； string 子序号的连接字符串，如 “1.1” 的 string 就是“.”，必须参数； 可同时显示多个计数器的嵌套计数，中间用空格隔开； 对应的 html 结构为 counter-reset层层嵌套。 // css .reset &#123; padding-left: 20px; counter-reset: sons;&#125; .counter:before &#123; content: counters(sons, &#39;-&#39;) &#39;. &#39;; counter-increment: sons;&#125; // html &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;大爷爷 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;大伯&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;爸爸 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;大儿子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;二儿子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;小儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;三叔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;二爷爷&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;三爷爷 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;什么叔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 特别注意 counters() 所在元素一定要嵌套在 counter-reset 所在元素内，否则会出现计数嵌套错误； 多个计数器时，counter-reset 不要定义在同一个节点上，否则会因为 css 的特性被覆盖而保留一个。 小细节 上面三个关键点，有的用空格隔开，有的用逗号隔开，可能会混淆。 对于 counter-reset 和 counter-increment，它们是 css 属性，其值用空格隔开； 对于 counter()，它是 content 属性的值，因此 counter() 与 counter() 之间用空格隔开； counter() 本身是方法，其参数写在括号内，用逗号隔开； counters() 同 counter()。 《CSS 计数器（上）》到此为止，下一篇谈谈 CSS 计数器的用途。","tags":["css"]}]